###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     13/Mar/2015  12:44:24 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\3.11换结构BLOCK nd        #
#                    black\common\ff.c                                        #
#    Command line =  "C:\Users\Administrator\Desktop\3.11换结构BLOCK nd       #
#                    black\common\ff.c" -D DEBUG -lCN                         #
#                    "C:\Users\Administrator\Desktop\3.11换结构BLOCK nd       #
#                    black\Debug\List\" -lB "C:\Users\Administrator\Desktop\3 #
#                    .11换结构BLOCK nd  black\Debug\List\" -o                 #
#                    "C:\Users\Administrator\Desktop\3.11换结构BLOCK nd       #
#                    black\Debug\Obj\" --no_cse --no_unroll --no_inline       #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -Ol --use_c++_inline                              #
#    List file    =  C:\Users\Administrator\Desktop\3.11换结构BLOCK nd        #
#                    black\Debug\List\ff.lst                                  #
#    Object file  =  C:\Users\Administrator\Desktop\3.11换结构BLOCK nd        #
#                    black\Debug\Obj\ff.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\3.11换结构BLOCK nd  black\common\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.08b                 (C)ChaN, 2011
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a generic FAT file system module for small embedded systems.
      5          / This is a free software that opened for education, research and commercial
      6          / developments under license policy of following terms.
      7          /
      8          /  Copyright (C) 2011, ChaN, all right reserved.
      9          /
     10          / * The FatFs module is a free software and there is NO WARRANTY.
     11          / * No restriction on use. You can use, modify and redistribute it for
     12          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     13          / * Redistributions of source code must retain the above copyright notice.
     14          /
     15          /-----------------------------------------------------------------------------/
     16          / Feb 26,'06 R0.00  Prototype.
     17          /
     18          / Apr 29,'06 R0.01  First stable version.
     19          /
     20          / Jun 01,'06 R0.02  Added FAT12 support.
     21          /                   Removed unbuffered mode.
     22          /                   Fixed a problem on small (<32M) partition.
     23          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     24          /
     25          / Sep 22,'06 R0.03  Added f_rename().
     26          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     27          / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
     28          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     29          /
     30          / Feb 04,'07 R0.04  Supported multiple drive system.
     31          /                   Changed some interfaces for multiple drive system.
     32          /                   Changed f_mountdrv() to f_mount().
     33          /                   Added f_mkfs().
     34          / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
     35          /                   Added a capability of extending file size to f_lseek().
     36          /                   Added minimization level 3.
     37          /                   Fixed an endian sensitive code in f_mkfs().
     38          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     39          /                   Added FSInfo support.
     40          /                   Fixed DBCS name can result FR_INVALID_NAME.
     41          /                   Fixed short seek (<= csize) collapses the file object.
     42          /
     43          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     44          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
     45          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     46          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     47          /                   Fixed off by one error at FAT sub-type determination.
     48          /                   Fixed btr in f_read() can be mistruncated.
     49          /                   Fixed cached sector is not flushed when create and close without write.
     50          /
     51          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     52          /                   Improved performance of f_lseek() on moving to the same or following cluster.
     53          /
     54          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
     55          /                   Added long file name feature.
     56          /                   Added multiple code page feature.
     57          /                   Added re-entrancy for multitask operation.
     58          /                   Added auto cluster size selection to f_mkfs().
     59          /                   Added rewind option to f_readdir().
     60          /                   Changed result code of critical errors.
     61          /                   Renamed string functions to avoid name collision.
     62          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     63          /                   Added multiple sector size feature.
     64          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     65          /                   Fixed wrong cache control in f_lseek().
     66          /                   Added relative path feature.
     67          /                   Added f_chdir() and f_chdrive().
     68          /                   Added proper case conversion to extended char.
     69          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
     70          /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
     71          /                   Fixed name matching error on the 13 char boundary.
     72          /                   Added a configuration option, _LFN_UNICODE.
     73          /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
     74          /
     75          / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
     76          /                   Added file lock feature. (_FS_SHARE)
     77          /                   Added fast seek feature. (_USE_FASTSEEK)
     78          /                   Changed some types on the API, XCHAR->TCHAR.
     79          /                   Changed fname member in the FILINFO structure on Unicode cfg.
     80          /                   String functions support UTF-8 encoding files on Unicode cfg.
     81          / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
     82          /                   Added sector erase feature. (_USE_ERASE)
     83          /                   Moved file lock semaphore table from fs object to the bss.
     84          /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
     85          /                   Fixed f_mkfs() creates wrong FAT32 volume.
     86          / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
     87          /                   f_lseek() reports required table size on creating CLMP.
     88          /                   Extended format syntax of f_printf function.
     89          /                   Ignores duplicated directory separators in given path names.
     90          /---------------------------------------------------------------------------*/
     91          
     92          #pragma warn_implicitconv off
     93          
     94          #include "..\K60_datatype.h"			/* FatFs configurations and declarations */
     95          
     96          
     97          /*--------------------------------------------------------------------------
     98          
     99             Module Private Definitions
    100          
    101          ---------------------------------------------------------------------------*/
    102          
    103          #if _FATFS != 8237
    104          #error Wrong include file (ff.h).
    105          #endif
    106          
    107          
    108          /* Definitions on sector size */
    109          #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
    110          #error Wrong sector size.
    111          #endif
    112          #if _MAX_SS != 512
    113          #define	SS(fs)	((fs)->ssize)	/* Multiple sector size */
    114          #else
    115          #define	SS(fs)	512U			/* Fixed sector size */
    116          #endif
    117          
    118          
    119          /* Reentrancy related */
    120          #if _FS_REENTRANT
    121          #if _USE_LFN == 1
    122          #error Static LFN work area must not be used in re-entrant configuration.
    123          #endif
    124          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
    125          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
    126          #else
    127          #define	ENTER_FF(fs)
    128          #define LEAVE_FF(fs, res)	return res
    129          #endif
    130          
    131          #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
    132          
    133          
    134          /* File shareing feature */
    135          #if _FS_SHARE
    136          #if _FS_READONLY
    137          #error _FS_SHARE must be 0 on read-only cfg.
    138          #endif
    139          typedef struct {
    140          	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
    141          	DWORD clu;				/* File ID 2, directory */
    142          	WORD idx;				/* File ID 3, directory index */
    143          	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
    144          } FILESEM;
    145          #endif
    146          
    147          
    148          /* Misc definitions */
    149          #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
    150          #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
    151          
    152          
    153          /* DBCS code ranges and SBCS extend char conversion table */
    154          
    155          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
    156          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
    157          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
    158          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
    159          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
    160          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
    161          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
    162          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
    163          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
    164          
    165          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
    166          #define _DF1S	0x81
    167          #define _DF1E	0xFE
    168          #define _DS1S	0x40
    169          #define _DS1E	0x7E
    170          #define _DS2S	0x80
    171          #define _DS2E	0xFE
    172          
    173          #elif _CODE_PAGE == 949	/* Korean */
    174          #define _DF1S	0x81
    175          #define _DF1E	0xFE
    176          #define _DS1S	0x41
    177          #define _DS1E	0x5A
    178          #define _DS2S	0x61
    179          #define _DS2E	0x7A
    180          #define _DS3S	0x81
    181          #define _DS3E	0xFE
    182          
    183          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    184          #define _DF1S	0x81
    185          #define _DF1E	0xFE
    186          #define _DS1S	0x40
    187          #define _DS1E	0x7E
    188          #define _DS2S	0xA1
    189          #define _DS2E	0xFE
    190          
    191          #elif _CODE_PAGE == 437	/* U.S. (OEM) */
    192          #define _DF1S	0
    193          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    194          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    195          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    196          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    197          
    198          #elif _CODE_PAGE == 720	/* Arabic (OEM) */
    199          #define _DF1S	0
    200          #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    201          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    202          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    203          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    204          
    205          #elif _CODE_PAGE == 737	/* Greek (OEM) */
    206          #define _DF1S	0
    207          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    208          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    209          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    210          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    211          
    212          #elif _CODE_PAGE == 775	/* Baltic (OEM) */
    213          #define _DF1S	0
    214          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    215          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    216          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    217          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    218          
    219          #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
    220          #define _DF1S	0
    221          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    222          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    223          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    224          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    225          
    226          #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
    227          #define _DF1S	0
    228          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
    229          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    230          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    231          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    232          
    233          #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
    234          #define _DF1S	0
    235          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    236          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    237          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    238          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    239          
    240          #elif _CODE_PAGE == 857	/* Turkish (OEM) */
    241          #define _DF1S	0
    242          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    243          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    244          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    245          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    246          
    247          #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
    248          #define _DF1S	0
    249          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    250          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    251          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    252          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    253          
    254          #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
    255          #define _DF1S	0
    256          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    257          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    258          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    259          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    260          
    261          #elif _CODE_PAGE == 866	/* Russian (OEM) */
    262          #define _DF1S	0
    263          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    264          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    265          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    266          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    267          
    268          #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
    269          #define _DF1S	0
    270          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    271          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    272          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    273          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    274          
    275          #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
    276          #define _DF1S	0
    277          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    278          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
    279          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    280          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    281          
    282          #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
    283          #define _DF1S	0
    284          #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    285          				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
    286          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    287          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
    288          
    289          #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
    290          #define _DF1S	0
    291          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
    292          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    293          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    294          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    295          
    296          #elif _CODE_PAGE == 1253 /* Greek (Windows) */
    297          #define _DF1S	0
    298          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    299          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    300          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
    301          				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
    302          
    303          #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
    304          #define _DF1S	0
    305          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    306          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    307          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    308          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    309          
    310          #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
    311          #define _DF1S	0
    312          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    313          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    314          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    315          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    316          
    317          #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
    318          #define _DF1S	0
    319          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    320          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    321          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    322          				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
    323          
    324          #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
    325          #define _DF1S	0
    326          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    327          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
    328          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    329          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    330          
    331          #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
    332          #define _DF1S	0
    333          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
    334          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    335          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    336          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
    337          
    338          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    339          #if _USE_LFN
    340          #error Cannot use LFN feature without valid code page.
    341          #endif
    342          #define _DF1S	0
    343          
    344          #else
    345          #error Unknown code page
    346          
    347          #endif
    348          
    349          
    350          /* Character code support macros */
    351          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    352          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    353          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    354          
    355          #if _DF1S		/* Code page is DBCS */
    356          
    357          #ifdef _DF2S	/* Two 1st byte areas */
    358          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    359          #else			/* One 1st byte area */
    360          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    361          #endif
    362          
    363          #ifdef _DS3S	/* Three 2nd byte areas */
    364          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    365          #else			/* Two 2nd byte areas */
    366          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    367          #endif
    368          
    369          #else			/* Code page is SBCS */
    370          
    371          #define IsDBCS1(c)	0
    372          #define IsDBCS2(c)	0
    373          
    374          #endif /* _DF1S */
    375          
    376          
    377          /* Name status flags */
    378          #define NS			11		/* Index of name status byte in fn[] */
    379          #define NS_LOSS		0x01	/* Out of 8.3 format */
    380          #define NS_LFN		0x02	/* Force to create LFN entry */
    381          #define NS_LAST		0x04	/* Last segment */
    382          #define NS_BODY		0x08	/* Lower case flag (body) */
    383          #define NS_EXT		0x10	/* Lower case flag (ext) */
    384          #define NS_DOT		0x20	/* Dot entry */
    385          
    386          
    387          /* FAT sub-type boundaries */
    388          /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
    389          #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
    390          #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
    391          
    392          
    393          /* FatFs refers the members in the FAT structures as byte array instead of
    394          / structure member because the structure is not binary compatible between
    395          / different platforms */
    396          
    397          #define BS_jmpBoot			0	/* Jump instruction (3) */
    398          #define BS_OEMName			3	/* OEM name (8) */
    399          #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
    400          #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
    401          #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
    402          #define BPB_NumFATs			16	/* Number of FAT copies (1) */
    403          #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
    404          #define BPB_TotSec16		19	/* Volume size [sector] (2) */
    405          #define BPB_Media			21	/* Media descriptor (1) */
    406          #define BPB_FATSz16			22	/* FAT size [sector] (2) */
    407          #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
    408          #define BPB_NumHeads		26	/* Number of heads (2) */
    409          #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
    410          #define BPB_TotSec32		32	/* Volume size [sector] (4) */
    411          #define BS_DrvNum			36	/* Physical drive number (2) */
    412          #define BS_BootSig			38	/* Extended boot signature (1) */
    413          #define BS_VolID			39	/* Volume serial number (4) */
    414          #define BS_VolLab			43	/* Volume label (8) */
    415          #define BS_FilSysType		54	/* File system type (1) */
    416          #define BPB_FATSz32			36	/* FAT size [sector] (4) */
    417          #define BPB_ExtFlags		40	/* Extended flags (2) */
    418          #define BPB_FSVer			42	/* File system version (2) */
    419          #define BPB_RootClus		44	/* Root dir first cluster (4) */
    420          #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
    421          #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
    422          #define BS_DrvNum32			64	/* Physical drive number (2) */
    423          #define BS_BootSig32		66	/* Extended boot signature (1) */
    424          #define BS_VolID32			67	/* Volume serial number (4) */
    425          #define BS_VolLab32			71	/* Volume label (8) */
    426          #define BS_FilSysType32		82	/* File system type (1) */
    427          #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
    428          #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
    429          #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
    430          #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
    431          #define MBR_Table			446	/* MBR: Partition table offset (2) */
    432          #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
    433          #define BS_55AA				510	/* Boot sector signature (2) */
    434          
    435          #define	DIR_Name			0	/* Short file name (11) */
    436          #define	DIR_Attr			11	/* Attribute (1) */
    437          #define	DIR_NTres			12	/* NT flag (1) */
    438          #define	DIR_CrtTime			14	/* Created time (2) */
    439          #define	DIR_CrtDate			16	/* Created date (2) */
    440          #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
    441          #define	DIR_WrtTime			22	/* Modified time (2) */
    442          #define	DIR_WrtDate			24	/* Modified date (2) */
    443          #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
    444          #define	DIR_FileSize		28	/* File size (4) */
    445          #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
    446          #define	LDIR_Attr			11	/* LFN attribute (1) */
    447          #define	LDIR_Type			12	/* LFN type (1) */
    448          #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
    449          #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
    450          #define	SZ_DIR				32		/* Size of a directory entry */
    451          #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
    452          #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
    453          #define	NDDE				0x05	/* Replacement of a character collides with DDE */
    454          
    455          
    456          /*------------------------------------------------------------*/
    457          /* Work area                                                  */
    458          
    459          #if _VOLUMES
    460          static

   \                                 In section .bss, align 4
    461          FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
   \                     FatFs:
   \   00000000                      DS8 4
    462          #else
    463          #error Number of drives must not be 0.
    464          #endif
    465          
    466          static

   \                                 In section .bss, align 2
    467          WORD Fsid;				/* File system mount ID */
   \                     Fsid:
   \   00000000                      DS8 2
    468          
    469          #if _FS_RPATH
    470          static

   \                                 In section .bss, align 1
    471          BYTE CurrVol;			/* Current drive */
   \                     CurrVol:
   \   00000000                      DS8 1
    472          #endif
    473          
    474          #if _FS_SHARE
    475          static
    476          FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
    477          #endif
    478          
    479          #if _USE_LFN == 0			/* No LFN */
    480          #define	DEF_NAMEBUF			BYTE sfn[12]
    481          #define INIT_BUF(dobj)		(dobj).fn = sfn
    482          #define	FREE_BUF()
    483          
    484          #elif _USE_LFN == 1			/* LFN with static LFN working buffer */

   \                                 In section .bss, align 4
    485          static WCHAR LfnBuf[_MAX_LFN+1];
   \                     LfnBuf:
   \   00000000                      DS8 512
    486          #define	DEF_NAMEBUF			BYTE sfn[12]
    487          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    488          #define	FREE_BUF()
    489          
    490          #elif _USE_LFN == 2 		/* LFN with dynamic LFN working buffer on the stack */
    491          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
    492          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
    493          #define	FREE_BUF()
    494          
    495          #elif _USE_LFN == 3 		/* LFN with dynamic LFN working buffer on the heap */
    496          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
    497          #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
    498          							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
    499          							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
    500          #define	FREE_BUF()			ff_memfree(lfn)
    501          
    502          #else
    503          #error Wrong LFN configuration.
    504          #endif
    505          
    506          
    507          
    508          
    509          /*--------------------------------------------------------------------------
    510          
    511             Module Private Functions
    512          
    513          ---------------------------------------------------------------------------*/
    514          
    515          
    516          /*-----------------------------------------------------------------------*/
    517          /* String functions                                                      */
    518          /*-----------------------------------------------------------------------*/
    519          
    520          /* Copy memory to memory */

   \                                 In section .text, align 2, keep-with-next
    521          static
    522          void mem_cpy (void* dst, const void* src, UINT cnt) {
    523          	BYTE *d = (BYTE*)dst;
    524          	const BYTE *s = (const BYTE*)src;
   \                     mem_cpy:
   \   00000000   0xE003             B.N      ??mem_cpy_0
    525          
    526          #if _WORD_ACCESS == 1
    527          	while (cnt >= sizeof(int)) {
    528          		*(int*)d = *(int*)s;
    529          		d += sizeof(int); s += sizeof(int);
    530          		cnt -= sizeof(int);
    531          	}
    532          #endif
    533          	while (cnt--)
    534          		*d++ = *s++;
   \                     ??mem_cpy_1:
   \   00000002   0x780B             LDRB     R3,[R1, #+0]
   \   00000004   0x7003             STRB     R3,[R0, #+0]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \                     ??mem_cpy_0:
   \   0000000A   0x0013             MOVS     R3,R2
   \   0000000C   0x1E5A             SUBS     R2,R3,#+1
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD1F7             BNE.N    ??mem_cpy_1
    535          }
   \   00000012   0x4770             BX       LR               ;; return
    536          
    537          /* Fill memory */

   \                                 In section .text, align 2, keep-with-next
    538          static
    539          void mem_set (void* dst, int val, UINT cnt) {
    540          	BYTE *d = (BYTE*)dst;
   \                     mem_set:
   \   00000000   0xE001             B.N      ??mem_set_0
    541          
    542          	while (cnt--)
    543          		*d++ = (BYTE)val;
   \                     ??mem_set_1:
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??mem_set_0:
   \   00000006   0x0013             MOVS     R3,R2
   \   00000008   0x1E5A             SUBS     R2,R3,#+1
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD1F9             BNE.N    ??mem_set_1
    544          }
   \   0000000E   0x4770             BX       LR               ;; return
    545          
    546          /* Compare memory to memory */

   \                                 In section .text, align 2, keep-with-next
    547          static
    548          int mem_cmp (const void* dst, const void* src, UINT cnt) {
   \                     mem_cmp:
   \   00000000   0xB410             PUSH     {R4}
    549          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    550          	int r = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    551          
    552          	while (cnt-- && (r = *d++ - *s++) == 0) ;
   \                     ??mem_cmp_0:
   \   00000004   0x0014             MOVS     R4,R2
   \   00000006   0x1E62             SUBS     R2,R4,#+1
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD006             BEQ.N    ??mem_cmp_1
   \   0000000C   0x7803             LDRB     R3,[R0, #+0]
   \   0000000E   0x780C             LDRB     R4,[R1, #+0]
   \   00000010   0x1B1B             SUBS     R3,R3,R4
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x2B00             CMP      R3,#+0
   \   00000018   0xD0F4             BEQ.N    ??mem_cmp_0
    553          	return r;
   \                     ??mem_cmp_1:
   \   0000001A   0x0018             MOVS     R0,R3
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    554          }
    555          
    556          /* Check if chr is contained in the string */

   \                                 In section .text, align 2, keep-with-next
    557          static
    558          int chk_chr (const char* str, int chr) {
   \                     chk_chr:
   \   00000000   0xE000             B.N      ??chk_chr_0
    559          	while (*str && *str != chr) str++;
   \                     ??chk_chr_1:
   \   00000002   0x1C40             ADDS     R0,R0,#+1
   \                     ??chk_chr_0:
   \   00000004   0x7802             LDRB     R2,[R0, #+0]
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD002             BEQ.N    ??chk_chr_2
   \   0000000A   0x7802             LDRB     R2,[R0, #+0]
   \   0000000C   0x428A             CMP      R2,R1
   \   0000000E   0xD1F8             BNE.N    ??chk_chr_1
    560          	return *str;
   \                     ??chk_chr_2:
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x4770             BX       LR               ;; return
    561          }
    562          
    563          
    564          
    565          /*-----------------------------------------------------------------------*/
    566          /* Request/Release grant to access the volume                            */
    567          /*-----------------------------------------------------------------------*/
    568          #if _FS_REENTRANT
    569          
    570          static
    571          int lock_fs (
    572          	FATFS *fs		/* File system object */
    573          )
    574          {
    575          	return ff_req_grant(fs->sobj);
    576          }
    577          
    578          
    579          static
    580          void unlock_fs (
    581          	FATFS *fs,		/* File system object */
    582          	FRESULT res		/* Result code to be returned */
    583          )
    584          {
    585          	if (res != FR_NOT_ENABLED &&
    586          		res != FR_INVALID_DRIVE &&
    587          		res != FR_INVALID_OBJECT &&
    588          		res != FR_TIMEOUT) {
    589          		ff_rel_grant(fs->sobj);
    590          	}
    591          }
    592          #endif
    593          
    594          
    595          
    596          /*-----------------------------------------------------------------------*/
    597          /* File shareing control functions                                       */
    598          /*-----------------------------------------------------------------------*/
    599          #if _FS_SHARE
    600          
    601          static
    602          FRESULT chk_lock (	/* Check if the file can be accessed */
    603          	DIR* dj,		/* Directory object pointing the file to be checked */
    604          	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    605          )
    606          {
    607          	UINT i, be;
    608          
    609          	/* Search file semaphore table */
    610          	for (i = be = 0; i < _FS_SHARE; i++) {
    611          		if (Files[i].fs) {	/* Existing entry */
    612          			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
    613          				Files[i].clu == dj->sclust &&
    614          				Files[i].idx == dj->index) break;
    615          		} else {			/* Blank entry */
    616          			be++;
    617          		}
    618          	}
    619          	if (i == _FS_SHARE)	/* The file is not opened */
    620          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
    621          
    622          	/* The file has been opened. Reject any open against writing file and all write mode open */
    623          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
    624          }
    625          
    626          
    627          static
    628          int enq_lock (	/* Check if an entry is available for a new file */
    629          	FATFS* fs	/* File system object */
    630          )
    631          {
    632          	UINT i;
    633          
    634          	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
    635          	return (i == _FS_SHARE) ? 0 : 1;
    636          }
    637          
    638          
    639          static
    640          UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
    641          	DIR* dj,	/* Directory object pointing the file to register or increment */
    642          	int acc		/* Desired access mode (0:Read, !0:Write) */
    643          )
    644          {
    645          	UINT i;
    646          
    647          
    648          	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
    649          		if (Files[i].fs == dj->fs &&
    650          			Files[i].clu == dj->sclust &&
    651          			Files[i].idx == dj->index) break;
    652          	}
    653          
    654          	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
    655          		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
    656          		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
    657          		Files[i].fs = dj->fs;
    658          		Files[i].clu = dj->sclust;
    659          		Files[i].idx = dj->index;
    660          		Files[i].ctr = 0;
    661          	}
    662          
    663          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
    664          
    665          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
    666          
    667          	return i + 1;
    668          }
    669          
    670          
    671          static
    672          FRESULT dec_lock (	/* Decrement file open counter */
    673          	UINT i			/* Semaphore index */
    674          )
    675          {
    676          	WORD n;
    677          	FRESULT res;
    678          
    679          
    680          	if (--i < _FS_SHARE) {
    681          		n = Files[i].ctr;
    682          		if (n == 0x100) n = 0;
    683          		if (n) n--;
    684          		Files[i].ctr = n;
    685          		if (!n) Files[i].fs = 0;
    686          		res = FR_OK;
    687          	} else {
    688          		res = FR_INT_ERR;
    689          	}
    690          	return res;
    691          }
    692          
    693          
    694          static
    695          void clear_lock (	/* Clear lock entries of the volume */
    696          	FATFS *fs
    697          )
    698          {
    699          	UINT i;
    700          
    701          	for (i = 0; i < _FS_SHARE; i++) {
    702          		if (Files[i].fs == fs) Files[i].fs = 0;
    703          	}
    704          }
    705          #endif
    706          
    707          
    708          
    709          /*-----------------------------------------------------------------------*/
    710          /* Change window offset                                                  */
    711          /*-----------------------------------------------------------------------*/
    712          

   \                                 In section .text, align 2, keep-with-next
    713          static
    714          FRESULT move_window (
    715          	FATFS *fs,		/* File system object */
    716          	DWORD sector	/* Sector number to make appearance in the fs->win[] */
    717          )					/* Move to zero only writes back dirty window */
    718          {
   \                     move_window:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    719          	DWORD wsect;
    720          
    721          
    722          	wsect = fs->winsect;
   \   00000006   0x6B26             LDR      R6,[R4, #+48]
    723          	if (wsect != sector) {	/* Changed current window */
   \   00000008   0x42AE             CMP      R6,R5
   \   0000000A   0xD031             BEQ.N    ??move_window_0
    724          #if !_FS_READONLY
    725          		if (fs->wflag) {	/* Write back dirty window if needed */
   \   0000000C   0x7920             LDRB     R0,[R4, #+4]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD020             BEQ.N    ??move_window_1
    726          			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
   \   00000012   0x2301             MOVS     R3,#+1
   \   00000014   0x0032             MOVS     R2,R6
   \   00000016   0xF114 0x0134      ADDS     R1,R4,#+52
   \   0000001A   0x7860             LDRB     R0,[R4, #+1]
   \   0000001C   0x.... 0x....      BL       disk_write
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ.N    ??move_window_2
    727          				return FR_DISK_ERR;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE024             B.N      ??move_window_3
    728          			fs->wflag = 0;
   \                     ??move_window_2:
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7120             STRB     R0,[R4, #+4]
    729          			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
   \   0000002C   0x6A60             LDR      R0,[R4, #+36]
   \   0000002E   0x6A21             LDR      R1,[R4, #+32]
   \   00000030   0x1808             ADDS     R0,R1,R0
   \   00000032   0x4286             CMP      R6,R0
   \   00000034   0xD20E             BCS.N    ??move_window_1
    730          				BYTE nf;
    731          				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   \   00000036   0x78E7             LDRB     R7,[R4, #+3]
   \   00000038   0xE009             B.N      ??move_window_4
    732          					wsect += fs->fsize;
   \                     ??move_window_5:
   \   0000003A   0x6A20             LDR      R0,[R4, #+32]
   \   0000003C   0x1986             ADDS     R6,R0,R6
    733          					disk_write(fs->drv, fs->win, wsect, 1);
   \   0000003E   0x2301             MOVS     R3,#+1
   \   00000040   0x0032             MOVS     R2,R6
   \   00000042   0xF114 0x0134      ADDS     R1,R4,#+52
   \   00000046   0x7860             LDRB     R0,[R4, #+1]
   \   00000048   0x.... 0x....      BL       disk_write
    734          				}
   \   0000004C   0x1E7F             SUBS     R7,R7,#+1
   \                     ??move_window_4:
   \   0000004E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000050   0x2F02             CMP      R7,#+2
   \   00000052   0xD2F2             BCS.N    ??move_window_5
    735          			}
    736          		}
    737          #endif
    738          		if (sector) {
   \                     ??move_window_1:
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD00B             BEQ.N    ??move_window_0
    739          			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
   \   00000058   0x2301             MOVS     R3,#+1
   \   0000005A   0x002A             MOVS     R2,R5
   \   0000005C   0xF114 0x0134      ADDS     R1,R4,#+52
   \   00000060   0x7860             LDRB     R0,[R4, #+1]
   \   00000062   0x.... 0x....      BL       disk_read
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD001             BEQ.N    ??move_window_6
    740          				return FR_DISK_ERR;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xE001             B.N      ??move_window_3
    741          			fs->winsect = sector;
   \                     ??move_window_6:
   \   0000006E   0x6325             STR      R5,[R4, #+48]
    742          		}
    743          	}
    744          
    745          	return FR_OK;
   \                     ??move_window_0:
   \   00000070   0x2000             MOVS     R0,#+0
   \                     ??move_window_3:
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    746          }
    747          
    748          
    749          
    750          
    751          /*-----------------------------------------------------------------------*/
    752          /* Clean-up cached data                                                  */
    753          /*-----------------------------------------------------------------------*/
    754          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    755          static
    756          FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
    757          	FATFS *fs	/* File system object */
    758          )
    759          {
   \                     sync:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    760          	FRESULT res;
    761          
    762          
    763          	res = move_window(fs, 0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       move_window
   \   0000000C   0x0005             MOVS     R5,R0
    764          	if (res == FR_OK) {
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD15D             BNE.N    ??sync_0
    765          		/* Update FSInfo sector if needed */
    766          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2803             CMP      R0,#+3
   \   00000018   0xD152             BNE.N    ??sync_1
   \   0000001A   0x7960             LDRB     R0,[R4, #+5]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD04F             BEQ.N    ??sync_1
    767          			fs->winsect = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6320             STR      R0,[R4, #+48]
    768          			/* Create FSInfo structure */
    769          			mem_set(fs->win, 0, 512);
   \   00000024   0xF44F 0x7200      MOV      R2,#+512
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF114 0x0034      ADDS     R0,R4,#+52
   \   0000002E   0x.... 0x....      BL       mem_set
    770          			ST_WORD(fs->win+BS_55AA, 0xAA55);
   \   00000032   0x2055             MOVS     R0,#+85
   \   00000034   0xF884 0x0232      STRB     R0,[R4, #+562]
   \   00000038   0x20AA             MOVS     R0,#+170
   \   0000003A   0xF884 0x0233      STRB     R0,[R4, #+563]
    771          			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   \   0000003E   0x2052             MOVS     R0,#+82
   \   00000040   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000044   0x2052             MOVS     R0,#+82
   \   00000046   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000004A   0x2061             MOVS     R0,#+97
   \   0000004C   0xF884 0x0036      STRB     R0,[R4, #+54]
   \   00000050   0x2041             MOVS     R0,#+65
   \   00000052   0xF884 0x0037      STRB     R0,[R4, #+55]
    772          			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   \   00000056   0x2072             MOVS     R0,#+114
   \   00000058   0xF884 0x0218      STRB     R0,[R4, #+536]
   \   0000005C   0x2072             MOVS     R0,#+114
   \   0000005E   0xF884 0x0219      STRB     R0,[R4, #+537]
   \   00000062   0x2041             MOVS     R0,#+65
   \   00000064   0xF884 0x021A      STRB     R0,[R4, #+538]
   \   00000068   0x2061             MOVS     R0,#+97
   \   0000006A   0xF884 0x021B      STRB     R0,[R4, #+539]
    773          			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0xF884 0x021C      STRB     R0,[R4, #+540]
   \   00000074   0x6920             LDR      R0,[R4, #+16]
   \   00000076   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000078   0x0A00             LSRS     R0,R0,#+8
   \   0000007A   0xF884 0x021D      STRB     R0,[R4, #+541]
   \   0000007E   0x6920             LDR      R0,[R4, #+16]
   \   00000080   0x0C00             LSRS     R0,R0,#+16
   \   00000082   0xF884 0x021E      STRB     R0,[R4, #+542]
   \   00000086   0x6920             LDR      R0,[R4, #+16]
   \   00000088   0x0E00             LSRS     R0,R0,#+24
   \   0000008A   0xF884 0x021F      STRB     R0,[R4, #+543]
    774          			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   \   0000008E   0x68E0             LDR      R0,[R4, #+12]
   \   00000090   0xF884 0x0220      STRB     R0,[R4, #+544]
   \   00000094   0x68E0             LDR      R0,[R4, #+12]
   \   00000096   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000098   0x0A00             LSRS     R0,R0,#+8
   \   0000009A   0xF884 0x0221      STRB     R0,[R4, #+545]
   \   0000009E   0x68E0             LDR      R0,[R4, #+12]
   \   000000A0   0x0C00             LSRS     R0,R0,#+16
   \   000000A2   0xF884 0x0222      STRB     R0,[R4, #+546]
   \   000000A6   0x68E0             LDR      R0,[R4, #+12]
   \   000000A8   0x0E00             LSRS     R0,R0,#+24
   \   000000AA   0xF884 0x0223      STRB     R0,[R4, #+547]
    775          			/* Write it into the FSInfo sector */
    776          			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
   \   000000AE   0x2301             MOVS     R3,#+1
   \   000000B0   0x6962             LDR      R2,[R4, #+20]
   \   000000B2   0xF114 0x0134      ADDS     R1,R4,#+52
   \   000000B6   0x7860             LDRB     R0,[R4, #+1]
   \   000000B8   0x.... 0x....      BL       disk_write
    777          			fs->fsi_flag = 0;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7160             STRB     R0,[R4, #+5]
    778          		}
    779          		/* Make sure that no pending write process in the physical drive */
    780          		if (disk_ioctl(fs->drv, CTRL_SYNC, (void*)0) != RES_OK)
   \                     ??sync_1:
   \   000000C0   0x2200             MOVS     R2,#+0
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x7860             LDRB     R0,[R4, #+1]
   \   000000C6   0x.... 0x....      BL       disk_ioctl
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD000             BEQ.N    ??sync_0
    781          			res = FR_DISK_ERR;
   \   000000CE   0x2501             MOVS     R5,#+1
    782          	}
    783          
    784          	return res;
   \                     ??sync_0:
   \   000000D0   0x0028             MOVS     R0,R5
   \   000000D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    785          }
    786          #endif
    787          
    788          
    789          
    790          
    791          /*-----------------------------------------------------------------------*/
    792          /* Get sector# from cluster#                                             */
    793          /*-----------------------------------------------------------------------*/
    794          
    795          

   \                                 In section .text, align 2, keep-with-next
    796          DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
    797          	FATFS *fs,		/* File system object */
    798          	DWORD clst		/* Cluster# to be converted */
    799          )
    800          {
    801          	clst -= 2;
   \                     clust2sect:
   \   00000000   0x1E89             SUBS     R1,R1,#+2
    802          	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   \   00000002   0x69C2             LDR      R2,[R0, #+28]
   \   00000004   0x1E92             SUBS     R2,R2,#+2
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD301             BCC.N    ??clust2sect_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE003             B.N      ??clust2sect_1
    803          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0:
   \   0000000E   0x7882             LDRB     R2,[R0, #+2]
   \   00000010   0x6AC0             LDR      R0,[R0, #+44]
   \   00000012   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \                     ??clust2sect_1:
   \   00000016   0x4770             BX       LR               ;; return
    804          }
    805          
    806          
    807          
    808          
    809          /*-----------------------------------------------------------------------*/
    810          /* FAT access - Read value of a FAT entry                                */
    811          /*-----------------------------------------------------------------------*/
    812          
    813          

   \                                 In section .text, align 2, keep-with-next
    814          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
    815          	FATFS *fs,	/* File system object */
    816          	DWORD clst	/* Cluster# to get the link information */
    817          )
    818          {
   \                     get_fat:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    819          	UINT wc, bc;
    820          	BYTE *p;
    821          
    822          
    823          	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
   \   00000006   0x2D02             CMP      R5,#+2
   \   00000008   0xD302             BCC.N    ??get_fat_0
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD301             BCC.N    ??get_fat_1
    824          		return 1;
   \                     ??get_fat_0:
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE014             B.N      ??get_fat_2
    825          
    826          	switch (fs->fs_type) {
   \                     ??get_fat_1:
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD004             BEQ.N    ??get_fat_3
   \   0000001A   0xD30E             BCC.N    ??get_fat_4
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD04B             BEQ.N    ??get_fat_5
   \   00000020   0xD332             BCC.N    ??get_fat_6
   \   00000022   0xE00A             B.N      ??get_fat_4
    827          	case FS_FAT12 :
    828          		bc = (UINT)clst; bc += bc / 2;
   \                     ??get_fat_3:
   \   00000024   0x002E             MOVS     R6,R5
   \   00000026   0xEB16 0x0656      ADDS     R6,R6,R6, LSR #+1
    829          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   0000002A   0x6A60             LDR      R0,[R4, #+36]
   \   0000002C   0xEB10 0x2156      ADDS     R1,R0,R6, LSR #+9
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       move_window
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??get_fat_7
    830          		wc = fs->win[bc % SS(fs)]; bc++;
    831          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    832          		wc |= fs->win[bc % SS(fs)] << 8;
    833          		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    834          
    835          	case FS_FAT16 :
    836          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    837          		p = &fs->win[clst * 2 % SS(fs)];
    838          		return LD_WORD(p);
    839          
    840          	case FS_FAT32 :
    841          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    842          		p = &fs->win[clst * 4 % SS(fs)];
    843          		return LD_DWORD(p) & 0x0FFFFFFF;
    844          	}
    845          
    846          	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
   \                     ??get_fat_4:
   \   0000003A   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??get_fat_2:
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??get_fat_7:
   \   00000040   0xF44F 0x7000      MOV      R0,#+512
   \   00000044   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   00000048   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   0000004C   0x1908             ADDS     R0,R1,R4
   \   0000004E   0xF890 0x7034      LDRB     R7,[R0, #+52]
   \   00000052   0x1C76             ADDS     R6,R6,#+1
   \   00000054   0x6A60             LDR      R0,[R4, #+36]
   \   00000056   0xEB10 0x2156      ADDS     R1,R0,R6, LSR #+9
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       move_window
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD1EA             BNE.N    ??get_fat_4
   \                     ??get_fat_8:
   \   00000064   0xF44F 0x7000      MOV      R0,#+512
   \   00000068   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000006C   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000070   0x1908             ADDS     R0,R1,R4
   \   00000072   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   00000076   0xEA57 0x2700      ORRS     R7,R7,R0, LSL #+8
   \   0000007A   0x07E8             LSLS     R0,R5,#+31
   \   0000007C   0xD501             BPL.N    ??get_fat_9
   \   0000007E   0x0938             LSRS     R0,R7,#+4
   \   00000080   0xE001             B.N      ??get_fat_10
   \                     ??get_fat_9:
   \   00000082   0x0538             LSLS     R0,R7,#+20       ;; ZeroExtS R0,R7,#+20,#+20
   \   00000084   0x0D00             LSRS     R0,R0,#+20
   \                     ??get_fat_10:
   \   00000086   0xE7DA             B.N      ??get_fat_2
   \                     ??get_fat_6:
   \   00000088   0x6A60             LDR      R0,[R4, #+36]
   \   0000008A   0xEB10 0x2115      ADDS     R1,R0,R5, LSR #+8
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       move_window
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD1D0             BNE.N    ??get_fat_4
   \                     ??get_fat_11:
   \   00000098   0x0068             LSLS     R0,R5,#+1
   \   0000009A   0xF44F 0x7100      MOV      R1,#+512
   \   0000009E   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000A2   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000A6   0x1910             ADDS     R0,R2,R4
   \   000000A8   0xF200 0x0034      ADDW     R0,R0,#+52
   \   000000AC   0x7841             LDRB     R1,[R0, #+1]
   \   000000AE   0x7800             LDRB     R0,[R0, #+0]
   \   000000B0   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000B4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B6   0xE7C2             B.N      ??get_fat_2
   \                     ??get_fat_5:
   \   000000B8   0x6A60             LDR      R0,[R4, #+36]
   \   000000BA   0xEB10 0x11D5      ADDS     R1,R0,R5, LSR #+7
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       move_window
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD1B8             BNE.N    ??get_fat_4
   \                     ??get_fat_12:
   \   000000C8   0x00A8             LSLS     R0,R5,#+2
   \   000000CA   0xF44F 0x7100      MOV      R1,#+512
   \   000000CE   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000D2   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000D6   0x1910             ADDS     R0,R2,R4
   \   000000D8   0xF200 0x0034      ADDW     R0,R0,#+52
   \   000000DC   0x78C1             LDRB     R1,[R0, #+3]
   \   000000DE   0x7882             LDRB     R2,[R0, #+2]
   \   000000E0   0x0412             LSLS     R2,R2,#+16
   \   000000E2   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   000000E6   0x7842             LDRB     R2,[R0, #+1]
   \   000000E8   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000000EC   0x7800             LDRB     R0,[R0, #+0]
   \   000000EE   0x4308             ORRS     R0,R0,R1
   \   000000F0   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   000000F2   0x0900             LSRS     R0,R0,#+4
   \   000000F4   0xE7A3             B.N      ??get_fat_2
    847          }
    848          
    849          
    850          
    851          
    852          /*-----------------------------------------------------------------------*/
    853          /* FAT access - Change value of a FAT entry                              */
    854          /*-----------------------------------------------------------------------*/
    855          #if !_FS_READONLY
    856          

   \                                 In section .text, align 2, keep-with-next
    857          FRESULT put_fat (
    858          	FATFS *fs,	/* File system object */
    859          	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
    860          	DWORD val	/* New value to mark the cluster */
    861          )
    862          {
   \                     put_fat:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    863          	UINT bc;
    864          	BYTE *p;
    865          	FRESULT res;
    866          
    867          
    868          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000008   0x2D02             CMP      R5,#+2
   \   0000000A   0xD302             BCC.N    ??put_fat_0
   \   0000000C   0x69E0             LDR      R0,[R4, #+28]
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD301             BCC.N    ??put_fat_1
    869          		res = FR_INT_ERR;
   \                     ??put_fat_0:
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE087             B.N      ??put_fat_2
    870          
    871          	} else {
    872          		switch (fs->fs_type) {
   \                     ??put_fat_1:
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD005             BEQ.N    ??put_fat_3
   \   0000001C   0xF0C0 0x8080      BCC.W    ??put_fat_4
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD05B             BEQ.N    ??put_fat_5
   \   00000024   0xD342             BCC.N    ??put_fat_6
   \   00000026   0xE07B             B.N      ??put_fat_4
    873          		case FS_FAT12 :
    874          			bc = clst; bc += bc / 2;
   \                     ??put_fat_3:
   \   00000028   0x002F             MOVS     R7,R5
   \   0000002A   0xEB17 0x0757      ADDS     R7,R7,R7, LSR #+1
    875          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000002E   0x6A60             LDR      R0,[R4, #+36]
   \   00000030   0xEB10 0x2157      ADDS     R1,R0,R7, LSR #+9
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       move_window
    876          			if (res != FR_OK) break;
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD170             BNE.N    ??put_fat_7
    877          			p = &fs->win[bc % SS(fs)];
   \                     ??put_fat_8:
   \   00000040   0xF44F 0x7000      MOV      R0,#+512
   \   00000044   0xFBB7 0xF1F0      UDIV     R1,R7,R0
   \   00000048   0xFB01 0x7110      MLS      R1,R1,R0,R7
   \   0000004C   0x1908             ADDS     R0,R1,R4
   \   0000004E   0xF200 0x0134      ADDW     R1,R0,#+52
    878          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0x07C0             LSLS     R0,R0,#+31
   \   00000056   0xD505             BPL.N    ??put_fat_9
   \   00000058   0x7808             LDRB     R0,[R1, #+0]
   \   0000005A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000005E   0xEA50 0x1006      ORRS     R0,R0,R6, LSL #+4
   \   00000062   0xE000             B.N      ??put_fat_10
   \                     ??put_fat_9:
   \   00000064   0x0030             MOVS     R0,R6
   \                     ??put_fat_10:
   \   00000066   0x7008             STRB     R0,[R1, #+0]
    879          			bc++;
   \   00000068   0x1C7F             ADDS     R7,R7,#+1
    880          			fs->wflag = 1;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x7120             STRB     R0,[R4, #+4]
    881          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000006E   0x6A60             LDR      R0,[R4, #+36]
   \   00000070   0xEB10 0x2157      ADDS     R1,R0,R7, LSR #+9
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       move_window
    882          			if (res != FR_OK) break;
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD150             BNE.N    ??put_fat_7
    883          			p = &fs->win[bc % SS(fs)];
   \                     ??put_fat_11:
   \   00000080   0xF44F 0x7100      MOV      R1,#+512
   \   00000084   0xFBB7 0xF2F1      UDIV     R2,R7,R1
   \   00000088   0xFB02 0x7211      MLS      R2,R2,R1,R7
   \   0000008C   0x1911             ADDS     R1,R2,R4
   \   0000008E   0xF201 0x0134      ADDW     R1,R1,#+52
    884          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   00000092   0x07EA             LSLS     R2,R5,#+31
   \   00000094   0xD501             BPL.N    ??put_fat_12
   \   00000096   0x0932             LSRS     R2,R6,#+4
   \   00000098   0xE006             B.N      ??put_fat_13
   \                     ??put_fat_12:
   \   0000009A   0x780A             LDRB     R2,[R1, #+0]
   \   0000009C   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   000000A0   0x0A33             LSRS     R3,R6,#+8
   \   000000A2   0xF013 0x030F      ANDS     R3,R3,#0xF
   \   000000A6   0x431A             ORRS     R2,R3,R2
   \                     ??put_fat_13:
   \   000000A8   0x700A             STRB     R2,[R1, #+0]
    885          			break;
   \   000000AA   0xE03A             B.N      ??put_fat_7
    886          
    887          		case FS_FAT16 :
    888          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_6:
   \   000000AC   0x6A60             LDR      R0,[R4, #+36]
   \   000000AE   0xEB10 0x2115      ADDS     R1,R0,R5, LSR #+8
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       move_window
    889          			if (res != FR_OK) break;
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD131             BNE.N    ??put_fat_7
    890          			p = &fs->win[clst * 2 % SS(fs)];
   \                     ??put_fat_14:
   \   000000BE   0x0069             LSLS     R1,R5,#+1
   \   000000C0   0xF44F 0x7200      MOV      R2,#+512
   \   000000C4   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   000000C8   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   000000CC   0x1919             ADDS     R1,R3,R4
   \   000000CE   0xF201 0x0134      ADDW     R1,R1,#+52
    891          			ST_WORD(p, (WORD)val);
   \   000000D2   0x700E             STRB     R6,[R1, #+0]
   \   000000D4   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000D6   0x0A32             LSRS     R2,R6,#+8
   \   000000D8   0x704A             STRB     R2,[R1, #+1]
    892          			break;
   \   000000DA   0xE022             B.N      ??put_fat_7
    893          
    894          		case FS_FAT32 :
    895          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_5:
   \   000000DC   0x6A60             LDR      R0,[R4, #+36]
   \   000000DE   0xEB10 0x11D5      ADDS     R1,R0,R5, LSR #+7
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0x.... 0x....      BL       move_window
    896          			if (res != FR_OK) break;
   \   000000E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD119             BNE.N    ??put_fat_7
    897          			p = &fs->win[clst * 4 % SS(fs)];
   \                     ??put_fat_15:
   \   000000EE   0x00A9             LSLS     R1,R5,#+2
   \   000000F0   0xF44F 0x7200      MOV      R2,#+512
   \   000000F4   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   000000F8   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   000000FC   0x1919             ADDS     R1,R3,R4
   \   000000FE   0xF201 0x0134      ADDW     R1,R1,#+52
    898          			val |= LD_DWORD(p) & 0xF0000000;
   \   00000102   0x78CA             LDRB     R2,[R1, #+3]
   \   00000104   0x0612             LSLS     R2,R2,#+24
   \   00000106   0xF012 0x4270      ANDS     R2,R2,#0xF0000000
   \   0000010A   0x4316             ORRS     R6,R2,R6
    899          			ST_DWORD(p, val);
   \   0000010C   0x700E             STRB     R6,[R1, #+0]
   \   0000010E   0x0032             MOVS     R2,R6
   \   00000110   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000112   0x0A12             LSRS     R2,R2,#+8
   \   00000114   0x704A             STRB     R2,[R1, #+1]
   \   00000116   0x0C32             LSRS     R2,R6,#+16
   \   00000118   0x708A             STRB     R2,[R1, #+2]
   \   0000011A   0x0E32             LSRS     R2,R6,#+24
   \   0000011C   0x70CA             STRB     R2,[R1, #+3]
    900          			break;
   \   0000011E   0xE000             B.N      ??put_fat_7
    901          
    902          		default :
    903          			res = FR_INT_ERR;
   \                     ??put_fat_4:
   \   00000120   0x2002             MOVS     R0,#+2
    904          		}
    905          		fs->wflag = 1;
   \                     ??put_fat_7:
   \   00000122   0x2101             MOVS     R1,#+1
   \   00000124   0x7121             STRB     R1,[R4, #+4]
    906          	}
    907          
    908          	return res;
   \                     ??put_fat_2:
   \   00000126   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000128   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    909          }
    910          #endif /* !_FS_READONLY */
    911          
    912          
    913          
    914          
    915          /*-----------------------------------------------------------------------*/
    916          /* FAT handling - Remove a cluster chain                                 */
    917          /*-----------------------------------------------------------------------*/
    918          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    919          static
    920          FRESULT remove_chain (
    921          	FATFS *fs,			/* File system object */
    922          	DWORD clst			/* Cluster# to remove a chain from */
    923          )
    924          {
   \                     remove_chain:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    925          	FRESULT res;
    926          	DWORD nxt;
    927          #if _USE_ERASE
    928          	DWORD scl = clst, ecl = clst, resion[2];
    929          #endif
    930          
    931          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000006   0x2E02             CMP      R6,#+2
   \   00000008   0xD302             BCC.N    ??remove_chain_0
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x4286             CMP      R6,R0
   \   0000000E   0xD301             BCC.N    ??remove_chain_1
    932          		res = FR_INT_ERR;
   \                     ??remove_chain_0:
   \   00000010   0x2502             MOVS     R5,#+2
   \   00000012   0xE027             B.N      ??remove_chain_2
    933          
    934          	} else {
    935          		res = FR_OK;
   \                     ??remove_chain_1:
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0xE009             B.N      ??remove_chain_3
    936          		while (clst < fs->n_fatent) {			/* Not a last link? */
    937          			nxt = get_fat(fs, clst);			/* Get cluster status */
    938          			if (nxt == 0) break;				/* Empty cluster? */
    939          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    940          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    941          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    942          			if (res != FR_OK) break;
    943          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
   \                     ??remove_chain_4:
   \   00000018   0x6920             LDR      R0,[R4, #+16]
   \   0000001A   0xF110 0x0F01      CMN      R0,#+1
   \   0000001E   0xD004             BEQ.N    ??remove_chain_5
    944          				fs->free_clust++;
   \   00000020   0x6920             LDR      R0,[R4, #+16]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x6120             STR      R0,[R4, #+16]
    945          				fs->fsi_flag = 1;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7160             STRB     R0,[R4, #+5]
    946          			}
    947          #if _USE_ERASE
    948          			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
    949          				ecl = nxt;
    950          			} else {				/* End of contiguous clusters */ 
    951          				resion[0] = clust2sect(fs, scl);					/* Start sector */
    952          				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
    953          				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
    954          				scl = ecl = nxt;
    955          			}
    956          #endif
    957          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_5:
   \   0000002A   0x003E             MOVS     R6,R7
   \                     ??remove_chain_3:
   \   0000002C   0x69E0             LDR      R0,[R4, #+28]
   \   0000002E   0x4286             CMP      R6,R0
   \   00000030   0xD218             BCS.N    ??remove_chain_2
   \   00000032   0x0031             MOVS     R1,R6
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       get_fat
   \   0000003A   0x0007             MOVS     R7,R0
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD011             BEQ.N    ??remove_chain_2
   \                     ??remove_chain_6:
   \   00000040   0x2F01             CMP      R7,#+1
   \   00000042   0xD101             BNE.N    ??remove_chain_7
   \   00000044   0x2502             MOVS     R5,#+2
   \   00000046   0xE00D             B.N      ??remove_chain_2
   \                     ??remove_chain_7:
   \   00000048   0xF117 0x0F01      CMN      R7,#+1
   \   0000004C   0xD101             BNE.N    ??remove_chain_8
   \   0000004E   0x2501             MOVS     R5,#+1
   \   00000050   0xE008             B.N      ??remove_chain_2
   \                     ??remove_chain_8:
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0031             MOVS     R1,R6
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       put_fat
   \   0000005C   0x0005             MOVS     R5,R0
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x2D00             CMP      R5,#+0
   \   00000062   0xD0D9             BEQ.N    ??remove_chain_4
    958          		}
    959          	}
    960          
    961          	return res;
   \                     ??remove_chain_2:
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    962          }
    963          #endif
    964          
    965          
    966          
    967          
    968          /*-----------------------------------------------------------------------*/
    969          /* FAT handling - Stretch or Create a cluster chain                      */
    970          /*-----------------------------------------------------------------------*/
    971          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    972          static
    973          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
    974          	FATFS *fs,			/* File system object */
    975          	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
    976          )
    977          {
   \                     create_chain:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    978          	DWORD cs, ncl, scl;
    979          	FRESULT res;
    980          
    981          
    982          	if (clst == 0) {		/* Create a new chain */
   \   00000006   0x2E00             CMP      R6,#+0
   \   00000008   0xD107             BNE.N    ??create_chain_0
    983          		scl = fs->last_clust;			/* Get suggested start point */
   \   0000000A   0x68E7             LDR      R7,[R4, #+12]
    984          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   0000000C   0x2F00             CMP      R7,#+0
   \   0000000E   0xD002             BEQ.N    ??create_chain_1
   \   00000010   0x69E0             LDR      R0,[R4, #+28]
   \   00000012   0x4287             CMP      R7,R0
   \   00000014   0xD30D             BCC.N    ??create_chain_2
   \                     ??create_chain_1:
   \   00000016   0x2701             MOVS     R7,#+1
   \   00000018   0xE00B             B.N      ??create_chain_2
    985          	}
    986          	else {					/* Stretch the current chain */
    987          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_0:
   \   0000001A   0x0031             MOVS     R1,R6
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       get_fat
    988          		if (cs < 2) return 1;			/* It is an invalid cluster */
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD201             BCS.N    ??create_chain_3
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE043             B.N      ??create_chain_4
    989          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   \                     ??create_chain_3:
   \   0000002A   0x69E1             LDR      R1,[R4, #+28]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD340             BCC.N    ??create_chain_4
    990          		scl = clst;
   \                     ??create_chain_5:
   \   00000030   0x0037             MOVS     R7,R6
    991          	}
    992          
    993          	ncl = scl;				/* Start cluster */
   \                     ??create_chain_2:
   \   00000032   0x003D             MOVS     R5,R7
    994          	for (;;) {
    995          		ncl++;							/* Next cluster */
   \                     ??create_chain_6:
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
    996          		if (ncl >= fs->n_fatent) {		/* Wrap around */
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD304             BCC.N    ??create_chain_7
    997          			ncl = 2;
   \   0000003C   0x2502             MOVS     R5,#+2
    998          			if (ncl > scl) return 0;	/* No free cluster */
   \   0000003E   0x42AF             CMP      R7,R5
   \   00000040   0xD201             BCS.N    ??create_chain_7
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE035             B.N      ??create_chain_4
    999          		}
   1000          		cs = get_fat(fs, ncl);			/* Get the cluster status */
   \                     ??create_chain_7:
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       get_fat
   1001          		if (cs == 0) break;				/* Found a free cluster */
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD11D             BNE.N    ??create_chain_8
   1002          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1003          			return cs;
   1004          		if (ncl == scl) return 0;		/* No free cluster */
   1005          	}
   1006          
   1007          	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   \   00000052   0xF07F 0x4270      MVNS     R2,#-268435456
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       put_fat
   1008          	if (res == FR_OK && clst != 0) {
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD106             BNE.N    ??create_chain_9
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD004             BEQ.N    ??create_chain_9
   1009          		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   \   00000068   0x002A             MOVS     R2,R5
   \   0000006A   0x0031             MOVS     R1,R6
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       put_fat
   1010          	}
   1011          	if (res == FR_OK) {
   \                     ??create_chain_9:
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD114             BNE.N    ??create_chain_10
   1012          		fs->last_clust = ncl;			/* Update FSINFO */
   \   00000078   0x60E5             STR      R5,[R4, #+12]
   1013          		if (fs->free_clust != 0xFFFFFFFF) {
   \   0000007A   0x6920             LDR      R0,[R4, #+16]
   \   0000007C   0xF110 0x0F01      CMN      R0,#+1
   \   00000080   0xD016             BEQ.N    ??create_chain_11
   1014          			fs->free_clust--;
   \   00000082   0x6920             LDR      R0,[R4, #+16]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0x6120             STR      R0,[R4, #+16]
   1015          			fs->fsi_flag = 1;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x7160             STRB     R0,[R4, #+5]
   \   0000008C   0xE010             B.N      ??create_chain_11
   1016          		}
   1017          	} else {
   \                     ??create_chain_8:
   \   0000008E   0xF110 0x0F01      CMN      R0,#+1
   \   00000092   0xD001             BEQ.N    ??create_chain_12
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD100             BNE.N    ??create_chain_13
   \                     ??create_chain_12:
   \   00000098   0xE00B             B.N      ??create_chain_4
   \                     ??create_chain_13:
   \   0000009A   0x42BD             CMP      R5,R7
   \   0000009C   0xD1CA             BNE.N    ??create_chain_6
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xE007             B.N      ??create_chain_4
   1018          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_10:
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0x2801             CMP      R0,#+1
   \   000000A6   0xD102             BNE.N    ??create_chain_14
   \   000000A8   0xF05F 0x35FF      MOVS     R5,#-1
   \   000000AC   0xE000             B.N      ??create_chain_11
   \                     ??create_chain_14:
   \   000000AE   0x2501             MOVS     R5,#+1
   1019          	}
   1020          
   1021          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_11:
   \   000000B0   0x0028             MOVS     R0,R5
   \                     ??create_chain_4:
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1022          }
   1023          #endif /* !_FS_READONLY */
   1024          
   1025          
   1026          
   1027          /*-----------------------------------------------------------------------*/
   1028          /* FAT handling - Convert offset into cluster with link map table        */
   1029          /*-----------------------------------------------------------------------*/
   1030          
   1031          #if _USE_FASTSEEK

   \                                 In section .text, align 2, keep-with-next
   1032          static
   1033          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   1034          	FIL* fp,		/* Pointer to the file object */
   1035          	DWORD ofs		/* File offset to be converted to cluster# */
   1036          )
   1037          {
   1038          	DWORD cl, ncl, *tbl;
   1039          
   1040          
   1041          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   \                     clmt_clust:
   \   00000000   0x6A42             LDR      R2,[R0, #+36]
   \   00000002   0x1D12             ADDS     R2,R2,#+4
   1042          	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
   \   00000004   0x0A49             LSRS     R1,R1,#+9
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x7880             LDRB     R0,[R0, #+2]
   \   0000000A   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   0000000E   0xE001             B.N      ??clmt_clust_0
   1043          	for (;;) {
   1044          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1045          		if (!ncl) return 0;		/* End of table? (error) */
   1046          		if (cl < ncl) break;	/* In this fragment? */
   1047          		cl -= ncl; tbl++;		/* Next fragment */
   \                     ??clmt_clust_1:
   \   00000010   0x1A40             SUBS     R0,R0,R1
   \   00000012   0x1D12             ADDS     R2,R2,#+4
   \                     ??clmt_clust_0:
   \   00000014   0x6811             LDR      R1,[R2, #+0]
   \   00000016   0x1D12             ADDS     R2,R2,#+4
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD101             BNE.N    ??clmt_clust_2
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE003             B.N      ??clmt_clust_3
   \                     ??clmt_clust_2:
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD2F5             BCS.N    ??clmt_clust_1
   1048          	}
   1049          	return cl + *tbl;	/* Return the cluster number */
   \   00000024   0x6811             LDR      R1,[R2, #+0]
   \   00000026   0x1808             ADDS     R0,R1,R0
   \                     ??clmt_clust_3:
   \   00000028   0x4770             BX       LR               ;; return
   1050          }
   1051          #endif	/* _USE_FASTSEEK */
   1052          
   1053          
   1054          
   1055          /*-----------------------------------------------------------------------*/
   1056          /* Directory handling - Set directory index                              */
   1057          /*-----------------------------------------------------------------------*/
   1058          

   \                                 In section .text, align 2, keep-with-next
   1059          static
   1060          FRESULT dir_sdi (
   1061          	DIR *dj,		/* Pointer to directory object */
   1062          	WORD idx		/* Directory index number */
   1063          )
   1064          {
   \                     dir_sdi:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1065          	DWORD clst;
   1066          	WORD ic;
   1067          
   1068          
   1069          	dj->index = idx;
   \   00000006   0x80E5             STRH     R5,[R4, #+6]
   1070          	clst = dj->sclust;
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   1071          	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD003             BEQ.N    ??dir_sdi_0
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x69C9             LDR      R1,[R1, #+28]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD301             BCC.N    ??dir_sdi_1
   1072          		return FR_INT_ERR;
   \                     ??dir_sdi_0:
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE049             B.N      ??dir_sdi_2
   1073          	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \                     ??dir_sdi_1:
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD105             BNE.N    ??dir_sdi_3
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x2903             CMP      R1,#+3
   \   00000024   0xD101             BNE.N    ??dir_sdi_3
   1074          		clst = dj->fs->dirbase;
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6A80             LDR      R0,[R0, #+40]
   1075          
   1076          	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
   \                     ??dir_sdi_3:
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD10E             BNE.N    ??dir_sdi_4
   1077          		dj->clust = clst;
   \   0000002E   0x60E0             STR      R0,[R4, #+12]
   1078          		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x8900             LDRH     R0,[R0, #+8]
   \   00000034   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xD301             BCC.N    ??dir_sdi_5
   1079          			return FR_INT_ERR;
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xE037             B.N      ??dir_sdi_2
   1080          		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \                     ??dir_sdi_5:
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6A80             LDR      R0,[R0, #+40]
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0xEB10 0x1015      ADDS     R0,R0,R5, LSR #+4
   \   00000048   0x6120             STR      R0,[R4, #+16]
   \   0000004A   0xE023             B.N      ??dir_sdi_6
   1081          	}
   1082          	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
   1083          		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
   \                     ??dir_sdi_4:
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x7889             LDRB     R1,[R1, #+2]
   \   00000050   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000052   0x010E             LSLS     R6,R1,#+4
   \   00000054   0xE000             B.N      ??dir_sdi_7
   1084          		while (idx >= ic) {	/* Follow cluster chain */
   1085          			clst = get_fat(dj->fs, clst);				/* Get next cluster */
   1086          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1087          			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
   1088          				return FR_INT_ERR;
   1089          			idx -= ic;
   \                     ??dir_sdi_8:
   \   00000056   0x1BAD             SUBS     R5,R5,R6
   \                     ??dir_sdi_7:
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000005C   0x42B5             CMP      R5,R6
   \   0000005E   0xD310             BCC.N    ??dir_sdi_9
   \   00000060   0x0001             MOVS     R1,R0
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x.... 0x....      BL       get_fat
   \   00000068   0xF110 0x0F01      CMN      R0,#+1
   \   0000006C   0xD101             BNE.N    ??dir_sdi_10
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xE01D             B.N      ??dir_sdi_2
   \                     ??dir_sdi_10:
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD303             BCC.N    ??dir_sdi_11
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x69C9             LDR      R1,[R1, #+28]
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD3EB             BCC.N    ??dir_sdi_8
   \                     ??dir_sdi_11:
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0xE015             B.N      ??dir_sdi_2
   1090          		}
   1091          		dj->clust = clst;
   \                     ??dir_sdi_9:
   \   00000082   0x60E0             STR      R0,[R4, #+12]
   1092          		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x.... 0x....      BL       clust2sect
   \   0000008C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000008E   0xEB10 0x1015      ADDS     R0,R0,R5, LSR #+4
   \   00000092   0x6120             STR      R0,[R4, #+16]
   1093          	}
   1094          
   1095          	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   \                     ??dir_sdi_6:
   \   00000094   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000096   0x2010             MOVS     R0,#+16
   \   00000098   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \   0000009C   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   000000A6   0xF200 0x0034      ADDW     R0,R0,#+52
   \   000000AA   0x6160             STR      R0,[R4, #+20]
   1096          
   1097          	return FR_OK;	/* Seek succeeded */
   \   000000AC   0x2000             MOVS     R0,#+0
   \                     ??dir_sdi_2:
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
   1098          }
   1099          
   1100          
   1101          
   1102          
   1103          /*-----------------------------------------------------------------------*/
   1104          /* Directory handling - Move directory index next                        */
   1105          /*-----------------------------------------------------------------------*/
   1106          

   \                                 In section .text, align 2, keep-with-next
   1107          static
   1108          FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
   1109          	DIR *dj,		/* Pointer to directory object */
   1110          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1111          )
   1112          {
   \                     dir_next:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1113          	DWORD clst;
   1114          	WORD i;
   1115          
   1116          
   1117          	i = dj->index + 1;
   \   00000006   0x88E0             LDRH     R0,[R4, #+6]
   \   00000008   0x1C46             ADDS     R6,R0,#+1
   1118          	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   \   0000000A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD002             BEQ.N    ??dir_next_0
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??dir_next_1
   1119          		return FR_NO_FILE;
   \                     ??dir_next_0:
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0xE08A             B.N      ??dir_next_2
   1120          
   1121          	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
   \                     ??dir_next_1:
   \   0000001A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001C   0x2010             MOVS     R0,#+16
   \   0000001E   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   00000022   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD174             BNE.N    ??dir_next_3
   1122          		dj->sect++;					/* Next sector */
   \   0000002A   0x6920             LDR      R0,[R4, #+16]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x6120             STR      R0,[R4, #+16]
   1123          
   1124          		if (dj->clust == 0) {	/* Static table */
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD106             BNE.N    ??dir_next_4
   1125          			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x8900             LDRH     R0,[R0, #+8]
   \   0000003A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000003C   0x4286             CMP      R6,R0
   \   0000003E   0xD369             BCC.N    ??dir_next_3
   1126          				return FR_NO_FILE;
   \   00000040   0x2004             MOVS     R0,#+4
   \   00000042   0xE075             B.N      ??dir_next_2
   1127          		}
   1128          		else {					/* Dynamic table */
   1129          			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_4:
   \   00000044   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000046   0x0930             LSRS     R0,R6,#+4
   \   00000048   0x6821             LDR      R1,[R4, #+0]
   \   0000004A   0x7889             LDRB     R1,[R1, #+2]
   \   0000004C   0x1E49             SUBS     R1,R1,#+1
   \   0000004E   0x4208             TST      R0,R1
   \   00000050   0xD160             BNE.N    ??dir_next_3
   1130          				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   \   00000052   0x68E1             LDR      R1,[R4, #+12]
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       get_fat
   \   0000005A   0x0007             MOVS     R7,R0
   1131          				if (clst <= 1) return FR_INT_ERR;
   \   0000005C   0x2F02             CMP      R7,#+2
   \   0000005E   0xD201             BCS.N    ??dir_next_5
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0xE065             B.N      ??dir_next_2
   1132          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_5:
   \   00000064   0xF117 0x0F01      CMN      R7,#+1
   \   00000068   0xD101             BNE.N    ??dir_next_6
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xE060             B.N      ??dir_next_2
   1133          				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
   \                     ??dir_next_6:
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x69C0             LDR      R0,[R0, #+28]
   \   00000072   0x4287             CMP      R7,R0
   \   00000074   0xD348             BCC.N    ??dir_next_7
   1134          #if !_FS_READONLY
   1135          					BYTE c;
   1136          					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD101             BNE.N    ??dir_next_8
   \   0000007A   0x2004             MOVS     R0,#+4
   \   0000007C   0xE058             B.N      ??dir_next_2
   1137          					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
   \                     ??dir_next_8:
   \   0000007E   0x68E1             LDR      R1,[R4, #+12]
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       create_chain
   \   00000086   0x0007             MOVS     R7,R0
   1138          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \   00000088   0x2F00             CMP      R7,#+0
   \   0000008A   0xD101             BNE.N    ??dir_next_9
   \   0000008C   0x2007             MOVS     R0,#+7
   \   0000008E   0xE04F             B.N      ??dir_next_2
   1139          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_9:
   \   00000090   0x2F01             CMP      R7,#+1
   \   00000092   0xD101             BNE.N    ??dir_next_10
   \   00000094   0x2002             MOVS     R0,#+2
   \   00000096   0xE04B             B.N      ??dir_next_2
   1140          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_10:
   \   00000098   0xF117 0x0F01      CMN      R7,#+1
   \   0000009C   0xD101             BNE.N    ??dir_next_11
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xE046             B.N      ??dir_next_2
   1141          					/* Clean-up stretched table */
   1142          					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
   \                     ??dir_next_11:
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x.... 0x....      BL       move_window
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD001             BEQ.N    ??dir_next_12
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xE03E             B.N      ??dir_next_2
   1143          					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   \                     ??dir_next_12:
   \   000000B2   0xF44F 0x7200      MOV      R2,#+512
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x3034             ADDS     R0,R0,#+52
   \   000000BC   0x.... 0x....      BL       mem_set
   1144          					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   \   000000C0   0x0039             MOVS     R1,R7
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x.... 0x....      BL       clust2sect
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x6308             STR      R0,[R1, #+48]
   1145          					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   000000CC   0x2500             MOVS     R5,#+0
   \   000000CE   0xE005             B.N      ??dir_next_13
   1146          						dj->fs->wflag = 1;
   1147          						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   1148          						dj->fs->winsect++;
   \                     ??dir_next_14:
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6B00             LDR      R0,[R0, #+48]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x6821             LDR      R1,[R4, #+0]
   \   000000D8   0x6308             STR      R0,[R1, #+48]
   \   000000DA   0x1C6D             ADDS     R5,R5,#+1
   \                     ??dir_next_13:
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x7880             LDRB     R0,[R0, #+2]
   \   000000E0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E2   0x4285             CMP      R5,R0
   \   000000E4   0xD20A             BCS.N    ??dir_next_15
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x2101             MOVS     R1,#+1
   \   000000EA   0x7101             STRB     R1,[R0, #+4]
   \   000000EC   0x2100             MOVS     R1,#+0
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x.... 0x....      BL       move_window
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD0EB             BEQ.N    ??dir_next_14
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0xE019             B.N      ??dir_next_2
   1149          					}
   1150          					dj->fs->winsect -= c;						/* Rewind window address */
   \                     ??dir_next_15:
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6B00             LDR      R0,[R0, #+48]
   \   00000100   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000102   0x1B40             SUBS     R0,R0,R5
   \   00000104   0x6821             LDR      R1,[R4, #+0]
   \   00000106   0x6308             STR      R0,[R1, #+48]
   1151          #else
   1152          					return FR_NO_FILE;			/* Report EOT */
   1153          #endif
   1154          				}
   1155          				dj->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_7:
   \   00000108   0x60E7             STR      R7,[R4, #+12]
   1156          				dj->sect = clust2sect(dj->fs, clst);
   \   0000010A   0x0039             MOVS     R1,R7
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x.... 0x....      BL       clust2sect
   \   00000112   0x6120             STR      R0,[R4, #+16]
   1157          			}
   1158          		}
   1159          	}
   1160          
   1161          	dj->index = i;
   \                     ??dir_next_3:
   \   00000114   0x80E6             STRH     R6,[R4, #+6]
   1162          	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   \   00000116   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000118   0x2010             MOVS     R0,#+16
   \   0000011A   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000011E   0xFB01 0x6110      MLS      R1,R1,R0,R6
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0xEB10 0x1041      ADDS     R0,R0,R1, LSL #+5
   \   00000128   0xF200 0x0034      ADDW     R0,R0,#+52
   \   0000012C   0x6160             STR      R0,[R4, #+20]
   1163          
   1164          	return FR_OK;
   \   0000012E   0x2000             MOVS     R0,#+0
   \                     ??dir_next_2:
   \   00000130   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1165          }
   1166          
   1167          
   1168          
   1169          
   1170          /*-----------------------------------------------------------------------*/
   1171          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1172          /*-----------------------------------------------------------------------*/
   1173          #if _USE_LFN
   1174          static

   \                                 In section .rodata, align 4
   1175          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
   \                     LfnOfs:
   \   00000000   0x01 0x03          DC8 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30, 0, 0, 0
   \              0x05 0x07    
   \              0x09 0x0E    
   \              0x10 0x12    
   \              0x14 0x16    
   \              0x18 0x1C    
   \              0x1E 0x00    
   \              0x00 0x00    
   1176          
   1177          

   \                                 In section .text, align 2, keep-with-next
   1178          static
   1179          int cmp_lfn (			/* 1:Matched, 0:Not matched */
   1180          	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
   1181          	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
   1182          )
   1183          {
   \                     cmp_lfn:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1184          	UINT i, s;
   1185          	WCHAR wc, uc;
   1186          
   1187          
   1188          	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x210D             MOVS     R1,#+13
   \   00000012   0xFB01 0xF600      MUL      R6,R1,R0
   1189          	s = 0; wc = 1;
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0xF05F 0x0801      MOVS     R8,#+1
   1190          	do {
   1191          		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
   \                     ??cmp_lfn_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000020   0x5C38             LDRB     R0,[R7, R0]
   \   00000022   0x1940             ADDS     R0,R0,R5
   \   00000024   0x7840             LDRB     R0,[R0, #+1]
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000002A   0x5C79             LDRB     R1,[R7, R1]
   \   0000002C   0x5D49             LDRB     R1,[R1, R5]
   \   0000002E   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   1192          		if (wc) {	/* Last char has not been processed */
   \   00000032   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000036   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000003A   0xD011             BEQ.N    ??cmp_lfn_1
   1193          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x.... 0x....      BL       ff_wtoupper
   \   00000042   0x4680             MOV      R8,R0
   1194          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   \   00000044   0x2EFF             CMP      R6,#+255
   \   00000046   0xD209             BCS.N    ??cmp_lfn_2
   \   00000048   0xF834 0x0016      LDRH     R0,[R4, R6, LSL #+1]
   \   0000004C   0x.... 0x....      BL       ff_wtoupper
   \   00000050   0x1C76             ADDS     R6,R6,#+1
   \   00000052   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000056   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000058   0x4580             CMP      R8,R0
   \   0000005A   0xD008             BEQ.N    ??cmp_lfn_3
   1195          				return 0;				/* Not matched */
   \                     ??cmp_lfn_2:
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE018             B.N      ??cmp_lfn_4
   1196          		} else {
   1197          			if (uc != 0xFFFF) return 0;	/* Check filler */
   \                     ??cmp_lfn_1:
   \   00000060   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD001             BEQ.N    ??cmp_lfn_3
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE011             B.N      ??cmp_lfn_4
   1198          		}
   1199          	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
   \                     ??cmp_lfn_3:
   \   0000006E   0x1C7F             ADDS     R7,R7,#+1
   \   00000070   0x2F0D             CMP      R7,#+13
   \   00000072   0xD3D3             BCC.N    ??cmp_lfn_0
   1200          
   1201          	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   \   00000074   0x7828             LDRB     R0,[R5, #+0]
   \   00000076   0x0640             LSLS     R0,R0,#+25
   \   00000078   0xD50A             BPL.N    ??cmp_lfn_5
   \   0000007A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000007E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000082   0xD005             BEQ.N    ??cmp_lfn_5
   \   00000084   0xF834 0x0016      LDRH     R0,[R4, R6, LSL #+1]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD001             BEQ.N    ??cmp_lfn_5
   1202          		return 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE000             B.N      ??cmp_lfn_4
   1203          
   1204          	return 1;						/* The part of LFN matched */
   \                     ??cmp_lfn_5:
   \   00000090   0x2001             MOVS     R0,#+1
   \                     ??cmp_lfn_4:
   \   00000092   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1205          }
   1206          
   1207          
   1208          

   \                                 In section .text, align 2, keep-with-next
   1209          static
   1210          int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
   1211          	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
   1212          	BYTE *dir			/* Pointer to the directory entry */
   1213          )
   1214          {
   \                     pick_lfn:
   \   00000000   0xB470             PUSH     {R4-R6}
   1215          	UINT i, s;
   1216          	WCHAR wc, uc;
   1217          
   1218          
   1219          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \   00000008   0x1E52             SUBS     R2,R2,#+1
   \   0000000A   0x230D             MOVS     R3,#+13
   \   0000000C   0x435A             MULS     R2,R3,R2
   1220          
   1221          	s = 0; wc = 1;
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x2401             MOVS     R4,#+1
   1222          	do {
   1223          		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
   \                     ??pick_lfn_0:
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable4
   \   00000016   0x5D5D             LDRB     R5,[R3, R5]
   \   00000018   0x186D             ADDS     R5,R5,R1
   \   0000001A   0x786D             LDRB     R5,[R5, #+1]
   \   0000001C   0x.... 0x....      LDR.W    R6,??DataTable4
   \   00000020   0x5D9E             LDRB     R6,[R3, R6]
   \   00000022   0x5C76             LDRB     R6,[R6, R1]
   \   00000024   0xEA56 0x2505      ORRS     R5,R6,R5, LSL #+8
   1224          		if (wc) {	/* Last char has not been processed */
   \   00000028   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD011             BEQ.N    ??pick_lfn_1
   1225          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   \   0000002E   0x2AFF             CMP      R2,#+255
   \   00000030   0xD301             BCC.N    ??pick_lfn_2
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE018             B.N      ??pick_lfn_3
   1226          			lfnbuf[i++] = wc = uc;			/* Store it */
   \                     ??pick_lfn_2:
   \   00000036   0x002C             MOVS     R4,R5
   \   00000038   0xF820 0x4012      STRH     R4,[R0, R2, LSL #+1]
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
   1227          		} else {
   1228          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1229          		}
   1230          	} while (++s < 13);						/* Read all character in the entry */
   \                     ??pick_lfn_4:
   \   0000003E   0x1C5B             ADDS     R3,R3,#+1
   \   00000040   0x2B0D             CMP      R3,#+13
   \   00000042   0xD3E6             BCC.N    ??pick_lfn_0
   1231          
   1232          	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
   \   00000044   0x7809             LDRB     R1,[R1, #+0]
   \   00000046   0x0649             LSLS     R1,R1,#+25
   \   00000048   0xD50D             BPL.N    ??pick_lfn_5
   1233          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   \   0000004A   0x2AFF             CMP      R2,#+255
   \   0000004C   0xD308             BCC.N    ??pick_lfn_6
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE00A             B.N      ??pick_lfn_3
   \                     ??pick_lfn_1:
   \   00000052   0xF64F 0x76FF      MOVW     R6,#+65535
   \   00000056   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000058   0x42B5             CMP      R5,R6
   \   0000005A   0xD0F0             BEQ.N    ??pick_lfn_4
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE003             B.N      ??pick_lfn_3
   1234          		lfnbuf[i] = 0;
   \                     ??pick_lfn_6:
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0xF820 0x1012      STRH     R1,[R0, R2, LSL #+1]
   1235          	}
   1236          
   1237          	return 1;
   \                     ??pick_lfn_5:
   \   00000066   0x2001             MOVS     R0,#+1
   \                     ??pick_lfn_3:
   \   00000068   0xBC70             POP      {R4-R6}
   \   0000006A   0x4770             BX       LR               ;; return
   1238          }
   1239          
   1240          
   1241          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1242          static
   1243          void fit_lfn (
   1244          	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
   1245          	BYTE *dir,				/* Pointer to the directory entry */
   1246          	BYTE ord,				/* LFN order (1-20) */
   1247          	BYTE sum				/* SFN sum */
   1248          )
   1249          {
   \                     fit_lfn:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1250          	UINT i, s;
   1251          	WCHAR wc;
   1252          
   1253          
   1254          	dir[LDIR_Chksum] = sum;			/* Set check sum */
   \   00000002   0x734B             STRB     R3,[R1, #+13]
   1255          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   \   00000004   0x230F             MOVS     R3,#+15
   \   00000006   0x72CB             STRB     R3,[R1, #+11]
   1256          	dir[LDIR_Type] = 0;
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x730B             STRB     R3,[R1, #+12]
   1257          	ST_WORD(dir+LDIR_FstClusLO, 0);
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x768B             STRB     R3,[R1, #+26]
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x76CB             STRB     R3,[R1, #+27]
   1258          
   1259          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x1E53             SUBS     R3,R2,#+1
   \   00000018   0x240D             MOVS     R4,#+13
   \   0000001A   0x4363             MULS     R3,R4,R3
   1260          	s = wc = 0;
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0x0025             MOVS     R5,R4
   \   00000020   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   1261          	do {
   1262          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
   \                     ??fit_lfn_0:
   \   00000022   0xF64F 0x76FF      MOVW     R6,#+65535
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x42B5             CMP      R5,R6
   \   0000002A   0xD002             BEQ.N    ??fit_lfn_1
   \   0000002C   0xF830 0x5013      LDRH     R5,[R0, R3, LSL #+1]
   \   00000030   0x1C5B             ADDS     R3,R3,#+1
   1263          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   \                     ??fit_lfn_1:
   \   00000032   0x.... 0x....      LDR.W    R6,??DataTable4
   \   00000036   0x5DA6             LDRB     R6,[R4, R6]
   \   00000038   0x5475             STRB     R5,[R6, R1]
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable4
   \   0000003E   0x5DA6             LDRB     R6,[R4, R6]
   \   00000040   0x1876             ADDS     R6,R6,R1
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0x0A2F             LSRS     R7,R5,#+8
   \   00000046   0x7077             STRB     R7,[R6, #+1]
   1264          		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD101             BNE.N    ??fit_lfn_2
   \   0000004E   0xF64F 0x75FF      MOVW     R5,#+65535
   1265          	} while (++s < 13);
   \                     ??fit_lfn_2:
   \   00000052   0x1C64             ADDS     R4,R4,#+1
   \   00000054   0x2C0D             CMP      R4,#+13
   \   00000056   0xD3E4             BCC.N    ??fit_lfn_0
   1266          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
   \   00000058   0xF64F 0x74FF      MOVW     R4,#+65535
   \   0000005C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005E   0x42A5             CMP      R5,R4
   \   00000060   0xD003             BEQ.N    ??fit_lfn_3
   \   00000062   0xF830 0x0013      LDRH     R0,[R0, R3, LSL #+1]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD101             BNE.N    ??fit_lfn_4
   \                     ??fit_lfn_3:
   \   0000006A   0xF052 0x0240      ORRS     R2,R2,#0x40
   1267          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   \                     ??fit_lfn_4:
   \   0000006E   0x700A             STRB     R2,[R1, #+0]
   1268          }
   \   00000070   0xBCF0             POP      {R4-R7}
   \   00000072   0x4770             BX       LR               ;; return
   1269          
   1270          #endif
   1271          #endif
   1272          
   1273          
   1274          
   1275          /*-----------------------------------------------------------------------*/
   1276          /* Create numbered name                                                  */
   1277          /*-----------------------------------------------------------------------*/
   1278          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   1279          void gen_numname (
   1280          	BYTE *dst,			/* Pointer to generated SFN */
   1281          	const BYTE *src,	/* Pointer to source SFN to be modified */
   1282          	const WCHAR *lfn,	/* Pointer to LFN */
   1283          	WORD seq			/* Sequence number */
   1284          )
   1285          {
   \                     gen_numname:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x001D             MOVS     R5,R3
   1286          	BYTE ns[8], c;
   1287          	UINT i, j;
   1288          
   1289          
   1290          	mem_cpy(dst, src, 11);
   \   00000008   0x220B             MOVS     R2,#+11
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       mem_cpy
   1291          
   1292          	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   \   00000010   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000012   0x2D06             CMP      R5,#+6
   \   00000014   0xD309             BCC.N    ??gen_numname_0
   1293          		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
   \                     ??gen_numname_1:
   \   00000016   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000018   0x03E8             LSLS     R0,R5,#+15
   \   0000001A   0xEB10 0x0055      ADDS     R0,R0,R5, LSR #+1
   \   0000001E   0x8831             LDRH     R1,[R6, #+0]
   \   00000020   0x180D             ADDS     R5,R1,R0
   \   00000022   0x1CB6             ADDS     R6,R6,#+2
   \   00000024   0x8830             LDRH     R0,[R6, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD1F5             BNE.N    ??gen_numname_1
   1294          	}
   1295          
   1296          	/* itoa (hexdecimal) */
   1297          	i = 7;
   \                     ??gen_numname_0:
   \   0000002A   0x2007             MOVS     R0,#+7
   1298          	do {
   1299          		c = (seq % 16) + '0';
   \                     ??gen_numname_2:
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x2110             MOVS     R1,#+16
   \   00000030   0xFB95 0xF2F1      SDIV     R2,R5,R1
   \   00000034   0xFB02 0x5211      MLS      R2,R2,R1,R5
   \   00000038   0xF112 0x0130      ADDS     R1,R2,#+48
   1300          		if (c > '9') c += 7;
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x293A             CMP      R1,#+58
   \   00000040   0xD300             BCC.N    ??gen_numname_3
   \   00000042   0x1DC9             ADDS     R1,R1,#+7
   1301          		ns[i--] = c;
   \                     ??gen_numname_3:
   \   00000044   0xAA00             ADD      R2,SP,#+0
   \   00000046   0x5481             STRB     R1,[R0, R2]
   \   00000048   0x1E40             SUBS     R0,R0,#+1
   1302          		seq /= 16;
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0x2110             MOVS     R1,#+16
   \   0000004E   0xFB95 0xF5F1      SDIV     R5,R5,R1
   1303          	} while (seq);
   \   00000052   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD1E9             BNE.N    ??gen_numname_2
   1304          	ns[i] = '~';
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0x227E             MOVS     R2,#+126
   \   0000005C   0x5442             STRB     R2,[R0, R1]
   1305          
   1306          	/* Append the number */
   1307          	for (j = 0; j < i && dst[j] != ' '; j++) {
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0xE000             B.N      ??gen_numname_4
   1308          		if (IsDBCS1(dst[j])) {
   \                     ??gen_numname_5:
   \   00000062   0x1C49             ADDS     R1,R1,#+1
   \                     ??gen_numname_4:
   \   00000064   0x4281             CMP      R1,R0
   \   00000066   0xD202             BCS.N    ??gen_numname_6
   \   00000068   0x5D0A             LDRB     R2,[R1, R4]
   \   0000006A   0x2A20             CMP      R2,#+32
   \   0000006C   0xD1F9             BNE.N    ??gen_numname_5
   1309          			if (j == i - 1) break;
   1310          			j++;
   1311          		}
   1312          	}
   1313          	do {
   1314          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   \                     ??gen_numname_6:
   \   0000006E   0x000A             MOVS     R2,R1
   \   00000070   0x1C51             ADDS     R1,R2,#+1
   \   00000072   0x2808             CMP      R0,#+8
   \   00000074   0xD203             BCS.N    ??gen_numname_7
   \   00000076   0xAB00             ADD      R3,SP,#+0
   \   00000078   0x5CC3             LDRB     R3,[R0, R3]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0xE000             B.N      ??gen_numname_8
   \                     ??gen_numname_7:
   \   0000007E   0x2320             MOVS     R3,#+32
   \                     ??gen_numname_8:
   \   00000080   0x5513             STRB     R3,[R2, R4]
   1315          	} while (j < 8);
   \   00000082   0x2908             CMP      R1,#+8
   \   00000084   0xD3F3             BCC.N    ??gen_numname_6
   1316          }
   \   00000086   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1317          #endif
   1318          
   1319          
   1320          
   1321          
   1322          /*-----------------------------------------------------------------------*/
   1323          /* Calculate sum of an SFN                                               */
   1324          /*-----------------------------------------------------------------------*/
   1325          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   1326          static
   1327          BYTE sum_sfn (
   1328          	const BYTE *dir		/* Ptr to directory entry */
   1329          )
   1330          {
   1331          	BYTE sum = 0;
   \                     sum_sfn:
   \   00000000   0x2100             MOVS     R1,#+0
   1332          	UINT n = 11;
   \   00000002   0x220B             MOVS     R2,#+11
   1333          
   1334          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   \                     ??sum_sfn_0:
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x01CB             LSLS     R3,R1,#+7
   \   00000008   0xEB13 0x0151      ADDS     R1,R3,R1, LSR #+1
   \   0000000C   0x7803             LDRB     R3,[R0, #+0]
   \   0000000E   0x1859             ADDS     R1,R3,R1
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x1E52             SUBS     R2,R2,#+1
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD1F5             BNE.N    ??sum_sfn_0
   1335          	return sum;
   \   00000018   0x0008             MOVS     R0,R1
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x4770             BX       LR               ;; return
   1336          }
   1337          #endif
   1338          
   1339          
   1340          
   1341          
   1342          /*-----------------------------------------------------------------------*/
   1343          /* Directory handling - Find an object in the directory                  */
   1344          /*-----------------------------------------------------------------------*/
   1345          

   \                                 In section .text, align 2, keep-with-next
   1346          static
   1347          FRESULT dir_find (
   1348          	DIR *dj			/* Pointer to the directory object linked to the file name */
   1349          )
   1350          {
   \                     dir_find:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   1351          	FRESULT res;
   1352          	BYTE c, *dir;
   1353          #if _USE_LFN
   1354          	BYTE a, ord, sum;
   1355          #endif
   1356          
   1357          	res = dir_sdi(dj, 0);			/* Rewind directory object */
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       dir_sdi
   \   0000000E   0x0004             MOVS     R4,R0
   1358          	if (res != FR_OK) return res;
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD002             BEQ.N    ??dir_find_0
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xE026             B.N      ??dir_find_1
   1359          
   1360          #if _USE_LFN
   1361          	ord = sum = 0xFF;
   \                     ??dir_find_0:
   \   0000001C   0x27FF             MOVS     R7,#+255
   \   0000001E   0x46B8             MOV      R8,R7
   1362          #endif
   1363          	do {
   1364          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_find_2:
   \   00000020   0x6929             LDR      R1,[R5, #+16]
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x.... 0x....      BL       move_window
   \   00000028   0x0004             MOVS     R4,R0
   1365          		if (res != FR_OK) break;
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD11A             BNE.N    ??dir_find_3
   1366          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \                     ??dir_find_4:
   \   00000030   0x696E             LDR      R6,[R5, #+20]
   1367          		c = dir[DIR_Name];
   \   00000032   0x7830             LDRB     R0,[R6, #+0]
   1368          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD101             BNE.N    ??dir_find_5
   \   0000003A   0x2404             MOVS     R4,#+4
   \   0000003C   0xE013             B.N      ??dir_find_3
   1369          #if _USE_LFN	/* LFN configuration */
   1370          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_find_5:
   \   0000003E   0x7AF1             LDRB     R1,[R6, #+11]
   \   00000040   0xF011 0x013F      ANDS     R1,R1,#0x3F
   1371          		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x28E5             CMP      R0,#+229
   \   00000048   0xD004             BEQ.N    ??dir_find_6
   \   0000004A   0x070A             LSLS     R2,R1,#+28
   \   0000004C   0xD50F             BPL.N    ??dir_find_7
   \   0000004E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000050   0x290F             CMP      R1,#+15
   \   00000052   0xD00C             BEQ.N    ??dir_find_7
   1372          			ord = 0xFF;
   \                     ??dir_find_6:
   \   00000054   0x27FF             MOVS     R7,#+255
   1373          		} else {
   1374          			if (a == AM_LFN) {			/* An LFN entry is found */
   1375          				if (dj->lfn) {
   1376          					if (c & LLE) {		/* Is it start of LFN sequence? */
   1377          						sum = dir[LDIR_Chksum];
   1378          						c &= ~LLE; ord = c;	/* LFN start order */
   1379          						dj->lfn_idx = dj->index;
   1380          					}
   1381          					/* Check validity of the LFN entry and compare it with given name */
   1382          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1383          				}
   1384          			} else {					/* An SFN entry is found */
   1385          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   1386          				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1387          				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   1388          			}
   1389          		}
   1390          #else		/* Non LFN configuration */
   1391          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
   1392          			break;
   1393          #endif
   1394          		res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_find_8:
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0x.... 0x....      BL       dir_next
   \   0000005E   0x0004             MOVS     R4,R0
   1395          	} while (res == FR_OK);
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x2C00             CMP      R4,#+0
   \   00000064   0xD0DC             BEQ.N    ??dir_find_2
   1396          
   1397          	return res;
   \                     ??dir_find_3:
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??dir_find_1:
   \   0000006A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??dir_find_7:
   \   0000006E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000070   0x290F             CMP      R1,#+15
   \   00000072   0xD11E             BNE.N    ??dir_find_9
   \   00000074   0x69E9             LDR      R1,[R5, #+28]
   \   00000076   0x2900             CMP      R1,#+0
   \   00000078   0xD0ED             BEQ.N    ??dir_find_8
   \   0000007A   0x0641             LSLS     R1,R0,#+25
   \   0000007C   0xD506             BPL.N    ??dir_find_10
   \   0000007E   0xF896 0x800D      LDRB     R8,[R6, #+13]
   \   00000082   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000086   0x0007             MOVS     R7,R0
   \   00000088   0x88E9             LDRH     R1,[R5, #+6]
   \   0000008A   0x8429             STRH     R1,[R5, #+32]
   \                     ??dir_find_10:
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000090   0x42B8             CMP      R0,R7
   \   00000092   0xD10C             BNE.N    ??dir_find_11
   \   00000094   0x7B70             LDRB     R0,[R6, #+13]
   \   00000096   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009A   0x4580             CMP      R8,R0
   \   0000009C   0xD107             BNE.N    ??dir_find_11
   \   0000009E   0x0031             MOVS     R1,R6
   \   000000A0   0x69E8             LDR      R0,[R5, #+28]
   \   000000A2   0x.... 0x....      BL       cmp_lfn
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD001             BEQ.N    ??dir_find_11
   \   000000AA   0x1E7F             SUBS     R7,R7,#+1
   \   000000AC   0xE000             B.N      ??dir_find_12
   \                     ??dir_find_11:
   \   000000AE   0x27FF             MOVS     R7,#+255
   \                     ??dir_find_12:
   \   000000B0   0xE7D1             B.N      ??dir_find_8
   \                     ??dir_find_9:
   \   000000B2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B4   0x2F00             CMP      R7,#+0
   \   000000B6   0xD106             BNE.N    ??dir_find_13
   \   000000B8   0x0030             MOVS     R0,R6
   \   000000BA   0x.... 0x....      BL       sum_sfn
   \   000000BE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C2   0x4580             CMP      R8,R0
   \   000000C4   0xD0CF             BEQ.N    ??dir_find_3
   \                     ??dir_find_13:
   \   000000C6   0x27FF             MOVS     R7,#+255
   \   000000C8   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000CC   0x8428             STRH     R0,[R5, #+32]
   \   000000CE   0x69A8             LDR      R0,[R5, #+24]
   \   000000D0   0x7AC0             LDRB     R0,[R0, #+11]
   \   000000D2   0x07C0             LSLS     R0,R0,#+31
   \   000000D4   0xD4BF             BMI.N    ??dir_find_8
   \   000000D6   0x220B             MOVS     R2,#+11
   \   000000D8   0x69A9             LDR      R1,[R5, #+24]
   \   000000DA   0x0030             MOVS     R0,R6
   \   000000DC   0x.... 0x....      BL       mem_cmp
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD1B8             BNE.N    ??dir_find_8
   \   000000E4   0xE7BF             B.N      ??dir_find_3
   1398          }
   1399          
   1400          
   1401          
   1402          
   1403          /*-----------------------------------------------------------------------*/
   1404          /* Read an object from the directory                                     */
   1405          /*-----------------------------------------------------------------------*/
   1406          #if _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
   1407          static
   1408          FRESULT dir_read (
   1409          	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
   1410          )
   1411          {
   \                     dir_read:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1412          	FRESULT res;
   1413          	BYTE c, *dir;
   1414          #if _USE_LFN
   1415          	BYTE a, ord = 0xFF, sum = 0xFF;
   \   00000004   0x26FF             MOVS     R6,#+255
   \   00000006   0x27FF             MOVS     R7,#+255
   1416          #endif
   1417          
   1418          	res = FR_NO_FILE;
   \   00000008   0x2504             MOVS     R5,#+4
   1419          	while (dj->sect) {
   \                     ??dir_read_0:
   \   0000000A   0x6920             LDR      R0,[R4, #+16]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD022             BEQ.N    ??dir_read_1
   1420          		res = move_window(dj->fs, dj->sect);
   \   00000010   0x6921             LDR      R1,[R4, #+16]
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       move_window
   \   00000018   0x0005             MOVS     R5,R0
   1421          		if (res != FR_OK) break;
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD11A             BNE.N    ??dir_read_1
   1422          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \                     ??dir_read_2:
   \   00000020   0x6960             LDR      R0,[R4, #+20]
   1423          		c = dir[DIR_Name];
   \   00000022   0x7801             LDRB     R1,[R0, #+0]
   1424          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD101             BNE.N    ??dir_read_3
   \   0000002A   0x2504             MOVS     R5,#+4
   \   0000002C   0xE013             B.N      ??dir_read_1
   1425          #if _USE_LFN	/* LFN configuration */
   1426          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_read_3:
   \   0000002E   0x7AC2             LDRB     R2,[R0, #+11]
   \   00000030   0xF012 0x023F      ANDS     R2,R2,#0x3F
   1427          		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x29E5             CMP      R1,#+229
   \   00000038   0xD004             BEQ.N    ??dir_read_4
   \   0000003A   0x0713             LSLS     R3,R2,#+28
   \   0000003C   0xD513             BPL.N    ??dir_read_5
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0x2A0F             CMP      R2,#+15
   \   00000042   0xD010             BEQ.N    ??dir_read_5
   1428          			ord = 0xFF;
   \                     ??dir_read_4:
   \   00000044   0x26FF             MOVS     R6,#+255
   1429          		} else {
   1430          			if (a == AM_LFN) {			/* An LFN entry is found */
   1431          				if (c & LLE) {			/* Is it start of LFN sequence? */
   1432          					sum = dir[LDIR_Chksum];
   1433          					c &= ~LLE; ord = c;
   1434          					dj->lfn_idx = dj->index;
   1435          				}
   1436          				/* Check LFN validity and capture it */
   1437          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1438          			} else {					/* An SFN entry is found */
   1439          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   1440          					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
   1441          				break;
   1442          			}
   1443          		}
   1444          #else		/* Non LFN configuration */
   1445          		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
   1446          			break;
   1447          #endif
   1448          		res = dir_next(dj, 0);				/* Next entry */
   \                     ??dir_read_6:
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       dir_next
   \   0000004E   0x0005             MOVS     R5,R0
   1449          		if (res != FR_OK) break;
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD0D9             BEQ.N    ??dir_read_0
   1450          	}
   1451          
   1452          	if (res != FR_OK) dj->sect = 0;
   \                     ??dir_read_1:
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0xD001             BEQ.N    ??dir_read_7
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6120             STR      R0,[R4, #+16]
   1453          
   1454          	return res;
   \                     ??dir_read_7:
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??dir_read_5:
   \   00000066   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000068   0x2A0F             CMP      R2,#+15
   \   0000006A   0xD119             BNE.N    ??dir_read_8
   \   0000006C   0x064A             LSLS     R2,R1,#+25
   \   0000006E   0xD505             BPL.N    ??dir_read_9
   \   00000070   0x7B47             LDRB     R7,[R0, #+13]
   \   00000072   0xF011 0x01BF      ANDS     R1,R1,#0xBF
   \   00000076   0x000E             MOVS     R6,R1
   \   00000078   0x88E2             LDRH     R2,[R4, #+6]
   \   0000007A   0x8422             STRH     R2,[R4, #+32]
   \                     ??dir_read_9:
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x42B1             CMP      R1,R6
   \   00000082   0xD10B             BNE.N    ??dir_read_10
   \   00000084   0x7B41             LDRB     R1,[R0, #+13]
   \   00000086   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000088   0x428F             CMP      R7,R1
   \   0000008A   0xD107             BNE.N    ??dir_read_10
   \   0000008C   0x0001             MOVS     R1,R0
   \   0000008E   0x69E0             LDR      R0,[R4, #+28]
   \   00000090   0x.... 0x....      BL       pick_lfn
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD001             BEQ.N    ??dir_read_10
   \   00000098   0x1E76             SUBS     R6,R6,#+1
   \   0000009A   0xE000             B.N      ??dir_read_11
   \                     ??dir_read_10:
   \   0000009C   0x26FF             MOVS     R6,#+255
   \                     ??dir_read_11:
   \   0000009E   0xE7D2             B.N      ??dir_read_6
   \                     ??dir_read_8:
   \   000000A0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A2   0x2E00             CMP      R6,#+0
   \   000000A4   0xD104             BNE.N    ??dir_read_12
   \   000000A6   0x.... 0x....      BL       sum_sfn
   \   000000AA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AC   0x4287             CMP      R7,R0
   \   000000AE   0xD002             BEQ.N    ??dir_read_13
   \                     ??dir_read_12:
   \   000000B0   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000B4   0x8420             STRH     R0,[R4, #+32]
   \                     ??dir_read_13:
   \   000000B6   0xE7CE             B.N      ??dir_read_1
   1455          }
   1456          #endif
   1457          
   1458          
   1459          
   1460          /*-----------------------------------------------------------------------*/
   1461          /* Register an object to the directory                                   */
   1462          /*-----------------------------------------------------------------------*/
   1463          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1464          static
   1465          FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
   1466          	DIR *dj				/* Target directory with object name to be created */
   1467          )
   1468          {
   \                     dir_register:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   1469          	FRESULT res;
   1470          	BYTE c, *dir;
   1471          #if _USE_LFN	/* LFN configuration */
   1472          	WORD n, ne, is;
   1473          	BYTE sn[12], *fn, sum;
   1474          	WCHAR *lfn;
   1475          
   1476          
   1477          	fn = dj->fn; lfn = dj->lfn;
   \   00000008   0x69A7             LDR      R7,[R4, #+24]
   \   0000000A   0x69E6             LDR      R6,[R4, #+28]
   1478          	mem_cpy(sn, fn, 12);
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x0039             MOVS     R1,R7
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       mem_cpy
   1479          
   1480          	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
   \   00000016   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   0000001A   0x0680             LSLS     R0,R0,#+26
   \   0000001C   0xD501             BPL.N    ??dir_register_0
   1481          		return FR_INVALID_NAME;
   \   0000001E   0x2006             MOVS     R0,#+6
   \   00000020   0xE0CE             B.N      ??dir_register_1
   1482          
   1483          	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   \                     ??dir_register_0:
   \   00000022   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD52C             BPL.N    ??dir_register_2
   1484          		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x72F8             STRB     R0,[R7, #+11]
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x61E0             STR      R0,[R4, #+28]
   1485          		for (n = 1; n < 100; n++) {
   \   00000032   0xF05F 0x0801      MOVS     R8,#+1
   \   00000036   0xE001             B.N      ??dir_register_3
   \                     ??dir_register_4:
   \   00000038   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??dir_register_3:
   \   0000003C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000040   0xF1B8 0x0F64      CMP      R8,#+100
   \   00000044   0xD20D             BCS.N    ??dir_register_5
   1486          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   \   00000046   0x4643             MOV      R3,R8
   \   00000048   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004A   0x0032             MOVS     R2,R6
   \   0000004C   0xA900             ADD      R1,SP,#+0
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0x.... 0x....      BL       gen_numname
   1487          			res = dir_find(dj);				/* Check if the name collides with existing SFN */
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       dir_find
   \   0000005A   0x0005             MOVS     R5,R0
   1488          			if (res != FR_OK) break;
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD0EA             BEQ.N    ??dir_register_4
   1489          		}
   1490          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   \                     ??dir_register_5:
   \   00000062   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000066   0xF1B8 0x0F64      CMP      R8,#+100
   \   0000006A   0xD101             BNE.N    ??dir_register_6
   \   0000006C   0x2007             MOVS     R0,#+7
   \   0000006E   0xE0A7             B.N      ??dir_register_1
   1491          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   \                     ??dir_register_6:
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0x2D04             CMP      R5,#+4
   \   00000074   0xD002             BEQ.N    ??dir_register_7
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0xE0A1             B.N      ??dir_register_1
   1492          		fn[NS] = sn[NS]; dj->lfn = lfn;
   \                     ??dir_register_7:
   \   0000007C   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000080   0x72F8             STRB     R0,[R7, #+11]
   \   00000082   0x61E6             STR      R6,[R4, #+28]
   1493          	}
   1494          
   1495          	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
   \                     ??dir_register_2:
   \   00000084   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000088   0x0780             LSLS     R0,R0,#+30
   \   0000008A   0xD50E             BPL.N    ??dir_register_8
   1496          		for (ne = 0; lfn[ne]; ne++) ;
   \   0000008C   0x2700             MOVS     R7,#+0
   \   0000008E   0xE000             B.N      ??dir_register_9
   \                     ??dir_register_10:
   \   00000090   0x1C7F             ADDS     R7,R7,#+1
   \                     ??dir_register_9:
   \   00000092   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000094   0xF836 0x0017      LDRH     R0,[R6, R7, LSL #+1]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD1F9             BNE.N    ??dir_register_10
   1497          		ne = (ne + 25) / 13;
   \   0000009C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000009E   0xF117 0x0019      ADDS     R0,R7,#+25
   \   000000A2   0x210D             MOVS     R1,#+13
   \   000000A4   0xFB90 0xF7F1      SDIV     R7,R0,R1
   \   000000A8   0xE000             B.N      ??dir_register_11
   1498          	} else {						/* Otherwise reserve only an SFN entry. */
   1499          		ne = 1;
   \                     ??dir_register_8:
   \   000000AA   0x2701             MOVS     R7,#+1
   1500          	}
   1501          
   1502          	/* Reserve contiguous entries */
   1503          	res = dir_sdi(dj, 0);
   \                     ??dir_register_11:
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       dir_sdi
   \   000000B4   0x0005             MOVS     R5,R0
   1504          	if (res != FR_OK) return res;
   \   000000B6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B8   0x2D00             CMP      R5,#+0
   \   000000BA   0xD002             BEQ.N    ??dir_register_12
   \   000000BC   0x0028             MOVS     R0,R5
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0xE07E             B.N      ??dir_register_1
   1505          	n = is = 0;
   \                     ??dir_register_12:
   \   000000C2   0xF05F 0x0800      MOVS     R8,#+0
   \   000000C6   0x4646             MOV      R6,R8
   1506          	do {
   1507          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_13:
   \   000000C8   0x6921             LDR      R1,[R4, #+16]
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x.... 0x....      BL       move_window
   \   000000D0   0x0005             MOVS     R5,R0
   1508          		if (res != FR_OK) break;
   \   000000D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D4   0x2D00             CMP      R5,#+0
   \   000000D6   0xD11F             BNE.N    ??dir_register_14
   1509          		c = *dj->dir;				/* Check the entry status */
   \                     ??dir_register_15:
   \   000000D8   0x6960             LDR      R0,[R4, #+20]
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   1510          		if (c == DDE || c == 0) {	/* Is it a blank entry? */
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x28E5             CMP      R0,#+229
   \   000000E0   0xD002             BEQ.N    ??dir_register_16
   \   000000E2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD10D             BNE.N    ??dir_register_17
   1511          			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
   \                     ??dir_register_16:
   \   000000E8   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000EC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000F0   0xD100             BNE.N    ??dir_register_18
   \   000000F2   0x88E6             LDRH     R6,[R4, #+6]
   1512          			if (++n == ne) break;	/* A contiguous entry that required count is found */
   \                     ??dir_register_18:
   \   000000F4   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000F8   0x4640             MOV      R0,R8
   \   000000FA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000FC   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000FE   0x42B8             CMP      R0,R7
   \   00000100   0xD102             BNE.N    ??dir_register_19
   \   00000102   0xE009             B.N      ??dir_register_14
   1513          		} else {
   1514          			n = 0;					/* Not a blank entry. Restart to search */
   \                     ??dir_register_17:
   \   00000104   0xF05F 0x0800      MOVS     R8,#+0
   1515          		}
   1516          		res = dir_next(dj, 1);		/* Next entry with table stretch */
   \                     ??dir_register_19:
   \   00000108   0x2101             MOVS     R1,#+1
   \   0000010A   0x0020             MOVS     R0,R4
   \   0000010C   0x.... 0x....      BL       dir_next
   \   00000110   0x0005             MOVS     R5,R0
   1517          	} while (res == FR_OK);
   \   00000112   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000114   0x2D00             CMP      R5,#+0
   \   00000116   0xD0D7             BEQ.N    ??dir_register_13
   1518          
   1519          	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
   \                     ??dir_register_14:
   \   00000118   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011A   0x2D00             CMP      R5,#+0
   \   0000011C   0xD130             BNE.N    ??dir_register_20
   \   0000011E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000120   0x2F02             CMP      R7,#+2
   \   00000122   0xD32D             BCC.N    ??dir_register_20
   1520          		res = dir_sdi(dj, is);
   \   00000124   0x0031             MOVS     R1,R6
   \   00000126   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000128   0x0020             MOVS     R0,R4
   \   0000012A   0x.... 0x....      BL       dir_sdi
   \   0000012E   0x0005             MOVS     R5,R0
   1521          		if (res == FR_OK) {
   \   00000130   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000132   0x2D00             CMP      R5,#+0
   \   00000134   0xD124             BNE.N    ??dir_register_20
   1522          			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
   \   00000136   0x69A0             LDR      R0,[R4, #+24]
   \   00000138   0x.... 0x....      BL       sum_sfn
   \   0000013C   0x0006             MOVS     R6,R0
   1523          			ne--;
   \   0000013E   0x1E7F             SUBS     R7,R7,#+1
   1524          			do {					/* Store LFN entries in bottom first */
   1525          				res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_21:
   \   00000140   0x6921             LDR      R1,[R4, #+16]
   \   00000142   0x6820             LDR      R0,[R4, #+0]
   \   00000144   0x.... 0x....      BL       move_window
   \   00000148   0x0005             MOVS     R5,R0
   1526          				if (res != FR_OK) break;
   \   0000014A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000014C   0x2D00             CMP      R5,#+0
   \   0000014E   0xD117             BNE.N    ??dir_register_20
   1527          				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   \                     ??dir_register_22:
   \   00000150   0x0033             MOVS     R3,R6
   \   00000152   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000154   0x003A             MOVS     R2,R7
   \   00000156   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000158   0x6961             LDR      R1,[R4, #+20]
   \   0000015A   0x69E0             LDR      R0,[R4, #+28]
   \   0000015C   0x.... 0x....      BL       fit_lfn
   1528          				dj->fs->wflag = 1;
   \   00000160   0x6820             LDR      R0,[R4, #+0]
   \   00000162   0x2101             MOVS     R1,#+1
   \   00000164   0x7101             STRB     R1,[R0, #+4]
   1529          				res = dir_next(dj, 0);	/* Next entry */
   \   00000166   0x2100             MOVS     R1,#+0
   \   00000168   0x0020             MOVS     R0,R4
   \   0000016A   0x.... 0x....      BL       dir_next
   \   0000016E   0x0005             MOVS     R5,R0
   1530          			} while (res == FR_OK && --ne);
   \   00000170   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000172   0x2D00             CMP      R5,#+0
   \   00000174   0xD104             BNE.N    ??dir_register_20
   \   00000176   0x1E7F             SUBS     R7,R7,#+1
   \   00000178   0x0038             MOVS     R0,R7
   \   0000017A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xD1DF             BNE.N    ??dir_register_21
   1531          		}
   1532          	}
   1533          
   1534          #else	/* Non LFN configuration */
   1535          	res = dir_sdi(dj, 0);
   1536          	if (res == FR_OK) {
   1537          		do {	/* Find a blank entry for the SFN */
   1538          			res = move_window(dj->fs, dj->sect);
   1539          			if (res != FR_OK) break;
   1540          			c = *dj->dir;
   1541          			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
   1542          			res = dir_next(dj, 1);			/* Next entry with table stretch */
   1543          		} while (res == FR_OK);
   1544          	}
   1545          #endif
   1546          
   1547          	if (res == FR_OK) {		/* Initialize the SFN entry */
   \                     ??dir_register_20:
   \   00000180   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000182   0x2D00             CMP      R5,#+0
   \   00000184   0xD11A             BNE.N    ??dir_register_23
   1548          		res = move_window(dj->fs, dj->sect);
   \   00000186   0x6921             LDR      R1,[R4, #+16]
   \   00000188   0x6820             LDR      R0,[R4, #+0]
   \   0000018A   0x.... 0x....      BL       move_window
   \   0000018E   0x0005             MOVS     R5,R0
   1549          		if (res == FR_OK) {
   \   00000190   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000192   0x2D00             CMP      R5,#+0
   \   00000194   0xD112             BNE.N    ??dir_register_23
   1550          			dir = dj->dir;
   \   00000196   0x6966             LDR      R6,[R4, #+20]
   1551          			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
   \   00000198   0x2220             MOVS     R2,#+32
   \   0000019A   0x2100             MOVS     R1,#+0
   \   0000019C   0x0030             MOVS     R0,R6
   \   0000019E   0x.... 0x....      BL       mem_set
   1552          			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
   \   000001A2   0x220B             MOVS     R2,#+11
   \   000001A4   0x69A1             LDR      R1,[R4, #+24]
   \   000001A6   0x0030             MOVS     R0,R6
   \   000001A8   0x.... 0x....      BL       mem_cpy
   1553          #if _USE_LFN
   1554          			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
   \   000001AC   0x69A0             LDR      R0,[R4, #+24]
   \   000001AE   0x7AC0             LDRB     R0,[R0, #+11]
   \   000001B0   0xF010 0x0018      ANDS     R0,R0,#0x18
   \   000001B4   0x7330             STRB     R0,[R6, #+12]
   1555          #endif
   1556          			dj->fs->wflag = 1;
   \   000001B6   0x6820             LDR      R0,[R4, #+0]
   \   000001B8   0x2101             MOVS     R1,#+1
   \   000001BA   0x7101             STRB     R1,[R0, #+4]
   1557          		}
   1558          	}
   1559          
   1560          	return res;
   \                     ??dir_register_23:
   \   000001BC   0x0028             MOVS     R0,R5
   \   000001BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??dir_register_1:
   \   000001C0   0xB004             ADD      SP,SP,#+16
   \   000001C2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1561          }
   1562          #endif /* !_FS_READONLY */
   1563          
   1564          
   1565          
   1566          
   1567          /*-----------------------------------------------------------------------*/
   1568          /* Remove an object from the directory                                   */
   1569          /*-----------------------------------------------------------------------*/
   1570          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In section .text, align 2, keep-with-next
   1571          static
   1572          FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
   1573          	DIR *dj				/* Directory object pointing the entry to be removed */
   1574          )
   1575          {
   \                     dir_remove:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1576          	FRESULT res;
   1577          #if _USE_LFN	/* LFN configuration */
   1578          	WORD i;
   1579          
   1580          	i = dj->index;	/* SFN index */
   \   00000004   0x88E5             LDRH     R5,[R4, #+6]
   1581          	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
   \   00000006   0x8C20             LDRH     R0,[R4, #+32]
   \   00000008   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD101             BNE.N    ??dir_remove_0
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0xE000             B.N      ??dir_remove_1
   \                     ??dir_remove_0:
   \   00000014   0x8C21             LDRH     R1,[R4, #+32]
   \                     ??dir_remove_1:
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       dir_sdi
   1582          	if (res == FR_OK) {
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD11B             BNE.N    ??dir_remove_2
   1583          		do {
   1584          			res = move_window(dj->fs, dj->sect);
   \                     ??dir_remove_3:
   \   00000024   0x6921             LDR      R1,[R4, #+16]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       move_window
   1585          			if (res != FR_OK) break;
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD110             BNE.N    ??dir_remove_4
   1586          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   \                     ??dir_remove_5:
   \   00000032   0x6961             LDR      R1,[R4, #+20]
   \   00000034   0x22E5             MOVS     R2,#+229
   \   00000036   0x700A             STRB     R2,[R1, #+0]
   1587          			dj->fs->wflag = 1;
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x710A             STRB     R2,[R1, #+4]
   1588          			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   \   0000003E   0x88E1             LDRH     R1,[R4, #+6]
   \   00000040   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000042   0x42A9             CMP      R1,R5
   \   00000044   0xD206             BCS.N    ??dir_remove_4
   1589          			res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_remove_6:
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       dir_next
   1590          		} while (res == FR_OK);
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD0E7             BEQ.N    ??dir_remove_3
   1591          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   \                     ??dir_remove_4:
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x2804             CMP      R0,#+4
   \   00000058   0xD100             BNE.N    ??dir_remove_2
   \   0000005A   0x2002             MOVS     R0,#+2
   1592          	}
   1593          
   1594          #else			/* Non LFN configuration */
   1595          	res = dir_sdi(dj, dj->index);
   1596          	if (res == FR_OK) {
   1597          		res = move_window(dj->fs, dj->sect);
   1598          		if (res == FR_OK) {
   1599          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   1600          			dj->fs->wflag = 1;
   1601          		}
   1602          	}
   1603          #endif
   1604          
   1605          	return res;
   \                     ??dir_remove_2:
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1606          }
   1607          #endif /* !_FS_READONLY */
   1608          
   1609          
   1610          
   1611          
   1612          /*-----------------------------------------------------------------------*/
   1613          /* Pick a segment and create the object name in directory form           */
   1614          /*-----------------------------------------------------------------------*/
   1615          

   \                                 In section .text, align 2, keep-with-next
   1616          static
   1617          FRESULT create_name (
   1618          	DIR *dj,			/* Pointer to the directory object */
   1619          	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
   1620          )
   1621          {
   \                     create_name:
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0x4688             MOV      R8,R1
   1622          #ifdef _EXCVT
   1623          	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
   1624          #endif
   1625          
   1626          #if _USE_LFN	/* LFN configuration */
   1627          	BYTE b, cf;
   1628          	WCHAR w, *lfn;
   1629          	UINT i, ni, si, di;
   1630          	const TCHAR *p;
   1631          
   1632          	/* Create LFN in Unicode */
   1633          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   \   00000006   0xF8D8 0x9000      LDR      R9,[R8, #+0]
   \   0000000A   0xE001             B.N      ??create_name_0
   \                     ??create_name_1:
   \   0000000C   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??create_name_0:
   \   00000010   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000014   0x282F             CMP      R0,#+47
   \   00000016   0xD0F9             BEQ.N    ??create_name_1
   \   00000018   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000001C   0x285C             CMP      R0,#+92
   \   0000001E   0xD0F5             BEQ.N    ??create_name_1
   1634          	lfn = dj->lfn;
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x69C6             LDR      R6,[R0, #+28]
   1635          	si = di = 0;
   \   00000024   0x2400             MOVS     R4,#+0
   \   00000026   0x0025             MOVS     R5,R4
   \   00000028   0xE002             B.N      ??create_name_2
   1636          	for (;;) {
   1637          		w = p[si++];					/* Get a character */
   1638          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   1639          		if (di >= _MAX_LFN)				/* Reject too long name */
   1640          			return FR_INVALID_NAME;
   1641          #if !_LFN_UNICODE
   1642          		w &= 0xFF;
   1643          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1644          			b = (BYTE)p[si++];			/* Get 2nd byte */
   1645          			if (!IsDBCS2(b))
   1646          				return FR_INVALID_NAME;	/* Reject invalid sequence */
   1647          			w = (w << 8) + b;			/* Create a DBC */
   1648          		}
   1649          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   1650          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   1651          #endif
   1652          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   1653          			return FR_INVALID_NAME;
   1654          		lfn[di++] = w;					/* Store the Unicode char */
   \                     ??create_name_3:
   \   0000002A   0xF826 0x7015      STRH     R7,[R6, R5, LSL #+1]
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??create_name_2:
   \   00000030   0xF814 0x7009      LDRB     R7,[R4, R9]
   \   00000034   0x1C64             ADDS     R4,R4,#+1
   \   00000036   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000038   0x2F20             CMP      R7,#+32
   \   0000003A   0xD305             BCC.N    ??create_name_4
   \   0000003C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003E   0x2F2F             CMP      R7,#+47
   \   00000040   0xD002             BEQ.N    ??create_name_4
   \   00000042   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000044   0x2F5C             CMP      R7,#+92
   \   00000046   0xD109             BNE.N    ??create_name_5
   1655          	}
   1656          	*path = &p[si];						/* Return pointer to the next segment */
   \                     ??create_name_4:
   \   00000048   0xEB14 0x0009      ADDS     R0,R4,R9
   \   0000004C   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1657          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   00000050   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000052   0x2F20             CMP      R7,#+32
   \   00000054   0xD21F             BCS.N    ??create_name_6
   \   00000056   0xF05F 0x0804      MOVS     R8,#+4
   \   0000005A   0xE01E             B.N      ??create_name_7
   \                     ??create_name_5:
   \   0000005C   0x2DFF             CMP      R5,#+255
   \   0000005E   0xD301             BCC.N    ??create_name_8
   \   00000060   0x2006             MOVS     R0,#+6
   \   00000062   0xE0C1             B.N      ??create_name_9
   \                     ??create_name_8:
   \   00000064   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x0038             MOVS     R0,R7
   \   0000006A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006C   0x.... 0x....      BL       ff_convert
   \   00000070   0x0007             MOVS     R7,R0
   \   00000072   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000074   0x2F00             CMP      R7,#+0
   \   00000076   0xD101             BNE.N    ??create_name_10
   \   00000078   0x2006             MOVS     R0,#+6
   \   0000007A   0xE0B5             B.N      ??create_name_9
   \                     ??create_name_10:
   \   0000007C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000007E   0x2F80             CMP      R7,#+128
   \   00000080   0xD2D3             BCS.N    ??create_name_3
   \   00000082   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000084   0x0039             MOVS     R1,R7
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable7
   \   0000008A   0x.... 0x....      BL       chk_chr
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD0CB             BEQ.N    ??create_name_3
   \   00000092   0x2006             MOVS     R0,#+6
   \   00000094   0xE0A8             B.N      ??create_name_9
   \                     ??create_name_6:
   \   00000096   0xF05F 0x0800      MOVS     R8,#+0
   1658          #if _FS_RPATH
   1659          	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
   1660          		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
   \                     ??create_name_7:
   \   0000009A   0x2D01             CMP      R5,#+1
   \   0000009C   0xD105             BNE.N    ??create_name_11
   \   0000009E   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   000000A2   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   000000A6   0x282E             CMP      R0,#+46
   \   000000A8   0xD00D             BEQ.N    ??create_name_12
   \                     ??create_name_11:
   \   000000AA   0x2D02             CMP      R5,#+2
   \   000000AC   0xD128             BNE.N    ??create_name_13
   \   000000AE   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   000000B2   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   000000B6   0x282E             CMP      R0,#+46
   \   000000B8   0xD122             BNE.N    ??create_name_13
   \   000000BA   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   000000BE   0xF830 0x0C04      LDRH     R0,[R0, #-4]
   \   000000C2   0x282E             CMP      R0,#+46
   \   000000C4   0xD11C             BNE.N    ??create_name_13
   1661          		lfn[di] = 0;
   \                     ??create_name_12:
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF826 0x0015      STRH     R0,[R6, R5, LSL #+1]
   1662          		for (i = 0; i < 11; i++)
   \   000000CC   0xF05F 0x0900      MOVS     R9,#+0
   \   000000D0   0xE006             B.N      ??create_name_14
   1663          			dj->fn[i] = (i < di) ? '.' : ' ';
   \                     ??create_name_15:
   \   000000D2   0x2020             MOVS     R0,#+32
   \                     ??create_name_16:
   \   000000D4   0x9900             LDR      R1,[SP, #+0]
   \   000000D6   0x6989             LDR      R1,[R1, #+24]
   \   000000D8   0xF809 0x0001      STRB     R0,[R9, R1]
   \   000000DC   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??create_name_14:
   \   000000E0   0xF1B9 0x0F0B      CMP      R9,#+11
   \   000000E4   0xD203             BCS.N    ??create_name_17
   \   000000E6   0x45A9             CMP      R9,R5
   \   000000E8   0xD2F3             BCS.N    ??create_name_15
   \   000000EA   0x202E             MOVS     R0,#+46
   \   000000EC   0xE7F2             B.N      ??create_name_16
   1664          		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   \                     ??create_name_17:
   \   000000EE   0x9800             LDR      R0,[SP, #+0]
   \   000000F0   0x6980             LDR      R0,[R0, #+24]
   \   000000F2   0xF058 0x0120      ORRS     R1,R8,#0x20
   \   000000F6   0xF809 0x1000      STRB     R1,[R9, R0]
   1665          		return FR_OK;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xE074             B.N      ??create_name_9
   1666          	}
   1667          #endif
   1668          	while (di) {						/* Strip trailing spaces and dots */
   1669          		w = lfn[di-1];
   1670          		if (w != ' ' && w != '.') break;
   1671          		di--;
   \                     ??create_name_18:
   \   000000FE   0x1E6D             SUBS     R5,R5,#+1
   \                     ??create_name_13:
   \   00000100   0x2D00             CMP      R5,#+0
   \   00000102   0xD009             BEQ.N    ??create_name_19
   \   00000104   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   00000108   0xF830 0x7C02      LDRH     R7,[R0, #-2]
   \   0000010C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000010E   0x2F20             CMP      R7,#+32
   \   00000110   0xD0F5             BEQ.N    ??create_name_18
   \   00000112   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000114   0x2F2E             CMP      R7,#+46
   \   00000116   0xD0F2             BEQ.N    ??create_name_18
   1672          	}
   1673          	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   \                     ??create_name_19:
   \   00000118   0x2D00             CMP      R5,#+0
   \   0000011A   0xD101             BNE.N    ??create_name_20
   \   0000011C   0x2006             MOVS     R0,#+6
   \   0000011E   0xE063             B.N      ??create_name_9
   1674          
   1675          	lfn[di] = 0;						/* LFN is created */
   \                     ??create_name_20:
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0xF826 0x0015      STRH     R0,[R6, R5, LSL #+1]
   1676          
   1677          	/* Create SFN in directory form */
   1678          	mem_set(dj->fn, ' ', 11);
   \   00000126   0x220B             MOVS     R2,#+11
   \   00000128   0x2120             MOVS     R1,#+32
   \   0000012A   0x9800             LDR      R0,[SP, #+0]
   \   0000012C   0x6980             LDR      R0,[R0, #+24]
   \   0000012E   0x.... 0x....      BL       mem_set
   1679          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   \   00000132   0x2400             MOVS     R4,#+0
   \   00000134   0xE000             B.N      ??create_name_21
   \                     ??create_name_22:
   \   00000136   0x1C64             ADDS     R4,R4,#+1
   \                     ??create_name_21:
   \   00000138   0xF836 0x0014      LDRH     R0,[R6, R4, LSL #+1]
   \   0000013C   0x2820             CMP      R0,#+32
   \   0000013E   0xD0FA             BEQ.N    ??create_name_22
   \   00000140   0xF836 0x0014      LDRH     R0,[R6, R4, LSL #+1]
   \   00000144   0x282E             CMP      R0,#+46
   \   00000146   0xD0F6             BEQ.N    ??create_name_22
   1680          	if (si) cf |= NS_LOSS | NS_LFN;
   \   00000148   0x2C00             CMP      R4,#+0
   \   0000014A   0xD003             BEQ.N    ??create_name_23
   \   0000014C   0xF058 0x0803      ORRS     R8,R8,#0x3
   \   00000150   0xE000             B.N      ??create_name_23
   1681          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   \                     ??create_name_24:
   \   00000152   0x1E6D             SUBS     R5,R5,#+1
   \                     ??create_name_23:
   \   00000154   0x2D00             CMP      R5,#+0
   \   00000156   0xD005             BEQ.N    ??create_name_25
   \   00000158   0xEB16 0x0045      ADDS     R0,R6,R5, LSL #+1
   \   0000015C   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   00000160   0x282E             CMP      R0,#+46
   \   00000162   0xD1F6             BNE.N    ??create_name_24
   1682          
   1683          	b = i = 0; ni = 8;
   \                     ??create_name_25:
   \   00000164   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000168   0x46D1             MOV      R9,R10
   \   0000016A   0xF05F 0x0B08      MOVS     R11,#+8
   \   0000016E   0xE001             B.N      ??create_name_26
   1684          	for (;;) {
   1685          		w = lfn[si++];					/* Get an LFN char */
   1686          		if (!w) break;					/* Break on end of the LFN */
   1687          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   1688          			cf |= NS_LOSS | NS_LFN; continue;
   \                     ??create_name_27:
   \   00000170   0xF058 0x0803      ORRS     R8,R8,#0x3
   1689          		}
   \                     ??create_name_26:
   \   00000174   0xF836 0x7014      LDRH     R7,[R6, R4, LSL #+1]
   \   00000178   0x1C64             ADDS     R4,R4,#+1
   \   0000017A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000017C   0x2F00             CMP      R7,#+0
   \   0000017E   0xD135             BNE.N    ??create_name_28
   1690          
   1691          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   1692          			if (ni == 11) {				/* Long extension */
   1693          				cf |= NS_LOSS | NS_LFN; break;
   1694          			}
   1695          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   1696          			if (si > di) break;			/* No extension */
   1697          			si = di; i = 8; ni = 11;	/* Enter extension section */
   1698          			b <<= 2; continue;
   1699          		}
   1700          
   1701          		if (w >= 0x80) {				/* Non ASCII char */
   1702          #ifdef _EXCVT
   1703          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   1704          			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   1705          #else
   1706          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1707          #endif
   1708          			cf |= NS_LFN;				/* Force create LFN entry */
   1709          		}
   1710          
   1711          		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
   1712          			if (i >= ni - 1) {
   1713          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1714          			}
   1715          			dj->fn[i++] = (BYTE)(w >> 8);
   1716          		} else {						/* Single byte char */
   1717          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
   1718          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   1719          			} else {
   1720          				if (IsUpper(w)) {		/* ASCII large capital */
   1721          					b |= 2;
   1722          				} else {
   1723          					if (IsLower(w)) {	/* ASCII small capital */
   1724          						b |= 1; w -= 0x20;
   1725          					}
   1726          				}
   1727          			}
   1728          		}
   1729          		dj->fn[i++] = (BYTE)w;
   1730          	}
   1731          
   1732          	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
   \                     ??create_name_29:
   \   00000180   0x9800             LDR      R0,[SP, #+0]
   \   00000182   0x6980             LDR      R0,[R0, #+24]
   \   00000184   0x7800             LDRB     R0,[R0, #+0]
   \   00000186   0x28E5             CMP      R0,#+229
   \   00000188   0xD103             BNE.N    ??create_name_30
   \   0000018A   0x9800             LDR      R0,[SP, #+0]
   \   0000018C   0x6980             LDR      R0,[R0, #+24]
   \   0000018E   0x2105             MOVS     R1,#+5
   \   00000190   0x7001             STRB     R1,[R0, #+0]
   1733          
   1734          	if (ni == 8) b <<= 2;
   \                     ??create_name_30:
   \   00000192   0xF1BB 0x0F08      CMP      R11,#+8
   \   00000196   0xD101             BNE.N    ??create_name_31
   \   00000198   0xEA5F 0x0A8A      LSLS     R10,R10,#+2
   1735          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   \                     ??create_name_31:
   \   0000019C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001A0   0xF01A 0x000C      ANDS     R0,R10,#0xC
   \   000001A4   0x280C             CMP      R0,#+12
   \   000001A6   0xD005             BEQ.N    ??create_name_32
   \   000001A8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001AC   0xF01A 0x0003      ANDS     R0,R10,#0x3
   \   000001B0   0x2803             CMP      R0,#+3
   \   000001B2   0xD101             BNE.N    ??create_name_33
   1736          		cf |= NS_LFN;
   \                     ??create_name_32:
   \   000001B4   0xF058 0x0802      ORRS     R8,R8,#0x2
   1737          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   \                     ??create_name_33:
   \   000001B8   0xEA5F 0x7088      LSLS     R0,R8,#+30
   \   000001BC   0xD40F             BMI.N    ??create_name_34
   1738          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   \   000001BE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001C2   0xF01A 0x0003      ANDS     R0,R10,#0x3
   \   000001C6   0x2801             CMP      R0,#+1
   \   000001C8   0xD101             BNE.N    ??create_name_35
   \   000001CA   0xF058 0x0810      ORRS     R8,R8,#0x10
   1739          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   \                     ??create_name_35:
   \   000001CE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001D2   0xF01A 0x000C      ANDS     R0,R10,#0xC
   \   000001D6   0x2804             CMP      R0,#+4
   \   000001D8   0xD101             BNE.N    ??create_name_34
   \   000001DA   0xF058 0x0808      ORRS     R8,R8,#0x8
   1740          	}
   1741          
   1742          	dj->fn[NS] = cf;	/* SFN is created */
   \                     ??create_name_34:
   \   000001DE   0x9800             LDR      R0,[SP, #+0]
   \   000001E0   0x6980             LDR      R0,[R0, #+24]
   \   000001E2   0xF880 0x800B      STRB     R8,[R0, #+11]
   1743          
   1744          	return FR_OK;
   \   000001E6   0x2000             MOVS     R0,#+0
   \                     ??create_name_9:
   \   000001E8   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??create_name_28:
   \   000001EC   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001EE   0x2F20             CMP      R7,#+32
   \   000001F0   0xD0BE             BEQ.N    ??create_name_27
   \   000001F2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000001F4   0x2F2E             CMP      R7,#+46
   \   000001F6   0xD101             BNE.N    ??create_name_36
   \   000001F8   0x42AC             CMP      R4,R5
   \   000001FA   0xD1B9             BNE.N    ??create_name_27
   \                     ??create_name_36:
   \   000001FC   0x45D9             CMP      R9,R11
   \   000001FE   0xD201             BCS.N    ??create_name_37
   \   00000200   0x42AC             CMP      R4,R5
   \   00000202   0xD113             BNE.N    ??create_name_38
   \                     ??create_name_37:
   \   00000204   0xF1BB 0x0F0B      CMP      R11,#+11
   \   00000208   0xD102             BNE.N    ??create_name_39
   \   0000020A   0xF058 0x0803      ORRS     R8,R8,#0x3
   \   0000020E   0xE7B7             B.N      ??create_name_29
   \                     ??create_name_39:
   \   00000210   0x42AC             CMP      R4,R5
   \   00000212   0xD001             BEQ.N    ??create_name_40
   \   00000214   0xF058 0x0803      ORRS     R8,R8,#0x3
   \                     ??create_name_40:
   \   00000218   0x42A5             CMP      R5,R4
   \   0000021A   0xD3B1             BCC.N    ??create_name_29
   \                     ??create_name_41:
   \   0000021C   0x002C             MOVS     R4,R5
   \   0000021E   0xF05F 0x0908      MOVS     R9,#+8
   \   00000222   0xF05F 0x0B0B      MOVS     R11,#+11
   \   00000226   0xEA5F 0x0A8A      LSLS     R10,R10,#+2
   \   0000022A   0xE7A3             B.N      ??create_name_26
   \                     ??create_name_38:
   \   0000022C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000022E   0x2F80             CMP      R7,#+128
   \   00000230   0xD310             BCC.N    ??create_name_42
   \   00000232   0x2100             MOVS     R1,#+0
   \   00000234   0x0038             MOVS     R0,R7
   \   00000236   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000238   0x.... 0x....      BL       ff_convert
   \   0000023C   0x0007             MOVS     R7,R0
   \   0000023E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000240   0x2F00             CMP      R7,#+0
   \   00000242   0xD005             BEQ.N    ??create_name_43
   \   00000244   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000246   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000024A   0x1838             ADDS     R0,R7,R0
   \   0000024C   0xF810 0x7C80      LDRB     R7,[R0, #-128]
   \                     ??create_name_43:
   \   00000250   0xF058 0x0802      ORRS     R8,R8,#0x2
   \                     ??create_name_42:
   \   00000254   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000256   0x2F00             CMP      R7,#+0
   \   00000258   0xD007             BEQ.N    ??create_name_44
   \   0000025A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000025C   0x0039             MOVS     R1,R7
   \   0000025E   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \   00000262   0x.... 0x....      BL       chk_chr
   \   00000266   0x2800             CMP      R0,#+0
   \   00000268   0xD003             BEQ.N    ??create_name_45
   \                     ??create_name_44:
   \   0000026A   0x275F             MOVS     R7,#+95
   \   0000026C   0xF058 0x0803      ORRS     R8,R8,#0x3
   \   00000270   0xE00F             B.N      ??create_name_46
   \                     ??create_name_45:
   \   00000272   0xF1B7 0x0041      SUBS     R0,R7,#+65
   \   00000276   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000278   0x281A             CMP      R0,#+26
   \   0000027A   0xD202             BCS.N    ??create_name_47
   \   0000027C   0xF05A 0x0A02      ORRS     R10,R10,#0x2
   \   00000280   0xE007             B.N      ??create_name_46
   \                     ??create_name_47:
   \   00000282   0xF1B7 0x0061      SUBS     R0,R7,#+97
   \   00000286   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000288   0x281A             CMP      R0,#+26
   \   0000028A   0xD202             BCS.N    ??create_name_46
   \   0000028C   0xF05A 0x0A01      ORRS     R10,R10,#0x1
   \   00000290   0x3F20             SUBS     R7,R7,#+32
   \                     ??create_name_46:
   \   00000292   0x9800             LDR      R0,[SP, #+0]
   \   00000294   0x6980             LDR      R0,[R0, #+24]
   \   00000296   0xF809 0x7000      STRB     R7,[R9, R0]
   \   0000029A   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000029E   0xE769             B.N      ??create_name_26
   1745          
   1746          
   1747          #else	/* Non-LFN configuration */
   1748          	BYTE b, c, d, *sfn;
   1749          	UINT ni, si, i;
   1750          	const char *p;
   1751          
   1752          	/* Create file name in directory form */
   1753          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   1754          	sfn = dj->fn;
   1755          	mem_set(sfn, ' ', 11);
   1756          	si = i = b = 0; ni = 8;
   1757          #if _FS_RPATH
   1758          	if (p[si] == '.') { /* Is this a dot entry? */
   1759          		for (;;) {
   1760          			c = (BYTE)p[si++];
   1761          			if (c != '.' || si >= 3) break;
   1762          			sfn[i++] = c;
   1763          		}
   1764          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   1765          		*path = &p[si];									/* Return pointer to the next segment */
   1766          		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   1767          		return FR_OK;
   1768          	}
   1769          #endif
   1770          	for (;;) {
   1771          		c = (BYTE)p[si++];
   1772          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1773          		if (c == '.' || i >= ni) {
   1774          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   1775          			i = 8; ni = 11;
   1776          			b <<= 2; continue;
   1777          		}
   1778          		if (c >= 0x80) {				/* Extended char? */
   1779          			b |= 3;						/* Eliminate NT flag */
   1780          #ifdef _EXCVT
   1781          			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
   1782          #else
   1783          #if !_DF1S	/* ASCII only cfg */
   1784          			return FR_INVALID_NAME;
   1785          #endif
   1786          #endif
   1787          		}
   1788          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1789          			d = (BYTE)p[si++];			/* Get 2nd byte */
   1790          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   1791          				return FR_INVALID_NAME;
   1792          			sfn[i++] = c;
   1793          			sfn[i++] = d;
   1794          		} else {						/* Single byte code */
   1795          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   1796          				return FR_INVALID_NAME;
   1797          			if (IsUpper(c)) {			/* ASCII large capital? */
   1798          				b |= 2;
   1799          			} else {
   1800          				if (IsLower(c)) {		/* ASCII small capital? */
   1801          					b |= 1; c -= 0x20;
   1802          				}
   1803          			}
   1804          			sfn[i++] = c;
   1805          		}
   1806          	}
   1807          	*path = &p[si];						/* Return pointer to the next segment */
   1808          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   1809          
   1810          	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   1811          	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
   1812          
   1813          	if (ni == 8) b <<= 2;
   1814          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   1815          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   1816          
   1817          	sfn[NS] = c;		/* Store NT flag, File name is created */
   1818          
   1819          	return FR_OK;
   1820          #endif
   1821          }

   \                                 In section .rodata, align 4
   \                     ??excvt:
   \   00000000   0x80 0x9A          DC8 128, 154, 144, 182, 142, 183, 143, 128, 210, 211, 212, 216, 215
   \              0x90 0xB6    
   \              0x8E 0xB7    
   \              0x8F 0x80    
   \              0xD2 0xD3    
   \              0xD4 0xD8    
   \              0xD7         
   \   0000000D   0xDE 0x8E          DC8 222, 142, 143, 144, 146, 146, 226, 153, 227, 234, 235, 89, 153, 154
   \              0x8F 0x90    
   \              0x92 0x92    
   \              0xE2 0x99    
   \              0xE3 0xEA    
   \              0xEB 0x59    
   \              0x99 0x9A    
   \   0000001B   0x9D 0x9C          DC8 157, 156, 157, 158, 159, 181, 214, 224, 233, 165, 165, 166, 167
   \              0x9D 0x9E    
   \              0x9F 0xB5    
   \              0xD6 0xE0    
   \              0xE9 0xA5    
   \              0xA5 0xA6    
   \              0xA7         
   \   00000028   0xA8 0xA9          DC8 168, 169, 170, 171, 172, 33, 174, 175, 176, 177, 178, 179, 180, 181
   \              0xAA 0xAB    
   \              0xAC 0x21    
   \              0xAE 0xAF    
   \              0xB0 0xB1    
   \              0xB2 0xB3    
   \              0xB4 0xB5    
   \   00000036   0xB6 0xB7          DC8 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194
   \              0xB8 0xB9    
   \              0xBA 0xBB    
   \              0xBC 0xBD    
   \              0xBE 0xBF    
   \              0xC0 0xC1    
   \              0xC2         
   \   00000043   0xC3 0xC4          DC8 195, 196, 197, 199, 199, 200, 201, 202, 203, 204, 205, 206, 207
   \              0xC5 0xC7    
   \              0xC7 0xC8    
   \              0xC9 0xCA    
   \              0xCB 0xCC    
   \              0xCD 0xCE    
   \              0xCF         
   \   00000050   0xD0 0xD1          DC8 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220
   \              0xD2 0xD3    
   \              0xD4 0xD5    
   \              0xD6 0xD7    
   \              0xD8 0xD9    
   \              0xDA 0xDB    
   \              0xDC         
   \   0000005D   0xDD 0xDE          DC8 221, 222, 223, 224, 225, 226, 227, 229, 229, 230, 231, 231, 233
   \              0xDF 0xE0    
   \              0xE1 0xE2    
   \              0xE3 0xE5    
   \              0xE5 0xE6    
   \              0xE7 0xE7    
   \              0xE9         
   \   0000006A   0xEA 0xEB          DC8 234, 235, 237, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246
   \              0xED 0xED    
   \              0xEE 0xEF    
   \              0xF0 0xF1    
   \              0xF2 0xF3    
   \              0xF4 0xF5    
   \              0xF6         
   \   00000077   0xF7 0xF8          DC8 247, 248, 249, 250, 251, 252, 253, 254, 255
   \              0xF9 0xFA    
   \              0xFB 0xFC    
   \              0xFD 0xFE    
   \              0xFF         
   1822          
   1823          
   1824          
   1825          
   1826          /*-----------------------------------------------------------------------*/
   1827          /* Get file information from directory entry                             */
   1828          /*-----------------------------------------------------------------------*/
   1829          #if _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
   1830          static
   1831          void get_fileinfo (		/* No return code */
   1832          	DIR *dj,			/* Pointer to the directory object */
   1833          	FILINFO *fno	 	/* Pointer to the file information to be filled */
   1834          )
   1835          {
   \                     get_fileinfo:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1836          	UINT i;
   1837          	BYTE nt, *dir;
   1838          	TCHAR *p, c;
   1839          
   1840          
   1841          	p = fno->fname;
   \   00000004   0xF204 0x0109      ADDW     R1,R4,#+9
   1842          	if (dj->sect) {
   \   00000008   0x6902             LDR      R2,[R0, #+16]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD048             BEQ.N    ??get_fileinfo_0
   1843          		dir = dj->dir;
   \   0000000E   0x6942             LDR      R2,[R0, #+20]
   1844          		nt = dir[DIR_NTres];		/* NT flag */
   \   00000010   0x7B13             LDRB     R3,[R2, #+12]
   1845          		for (i = 0; i < 8; i++) {	/* Copy name body */
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0xE00E             B.N      ??get_fileinfo_1
   1846          			c = dir[i];
   1847          			if (c == ' ') break;
   1848          			if (c == NDDE) c = (TCHAR)DDE;
   \                     ??get_fileinfo_2:
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E05             CMP      R6,#+5
   \   0000001A   0xD100             BNE.N    ??get_fileinfo_3
   \   0000001C   0x26E5             MOVS     R6,#+229
   1849          			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   \                     ??get_fileinfo_3:
   \   0000001E   0x071F             LSLS     R7,R3,#+28
   \   00000020   0xD505             BPL.N    ??get_fileinfo_4
   \   00000022   0xF1B6 0x0741      SUBS     R7,R6,#+65
   \   00000026   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000028   0x2F1A             CMP      R7,#+26
   \   0000002A   0xD200             BCS.N    ??get_fileinfo_4
   \   0000002C   0x3620             ADDS     R6,R6,#+32
   1850          #if _LFN_UNICODE
   1851          			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
   1852          				c = (c << 8) | dir[++i];
   1853          			c = ff_convert(c, 1);
   1854          			if (!c) c = '?';
   1855          #endif
   1856          			*p++ = c;
   \                     ??get_fileinfo_4:
   \   0000002E   0x700E             STRB     R6,[R1, #+0]
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_1:
   \   00000034   0x2D08             CMP      R5,#+8
   \   00000036   0xD203             BCS.N    ??get_fileinfo_5
   \   00000038   0x5CAE             LDRB     R6,[R5, R2]
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E20             CMP      R6,#+32
   \   0000003E   0xD1EA             BNE.N    ??get_fileinfo_2
   1857          		}
   1858          		if (dir[8] != ' ') {		/* Copy name extension */
   \                     ??get_fileinfo_5:
   \   00000040   0x7A15             LDRB     R5,[R2, #+8]
   \   00000042   0x2D20             CMP      R5,#+32
   \   00000044   0xD015             BEQ.N    ??get_fileinfo_6
   1859          			*p++ = '.';
   \   00000046   0x252E             MOVS     R5,#+46
   \   00000048   0x700D             STRB     R5,[R1, #+0]
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   1860          			for (i = 8; i < 11; i++) {
   \   0000004C   0x2508             MOVS     R5,#+8
   \   0000004E   0xE00A             B.N      ??get_fileinfo_7
   1861          				c = dir[i];
   1862          				if (c == ' ') break;
   1863          				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   \                     ??get_fileinfo_8:
   \   00000050   0x06DF             LSLS     R7,R3,#+27
   \   00000052   0xD505             BPL.N    ??get_fileinfo_9
   \   00000054   0xF1B6 0x0741      SUBS     R7,R6,#+65
   \   00000058   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005A   0x2F1A             CMP      R7,#+26
   \   0000005C   0xD200             BCS.N    ??get_fileinfo_9
   \   0000005E   0x3620             ADDS     R6,R6,#+32
   1864          #if _LFN_UNICODE
   1865          				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
   1866          					c = (c << 8) | dir[++i];
   1867          				c = ff_convert(c, 1);
   1868          				if (!c) c = '?';
   1869          #endif
   1870          				*p++ = c;
   \                     ??get_fileinfo_9:
   \   00000060   0x700E             STRB     R6,[R1, #+0]
   \   00000062   0x1C49             ADDS     R1,R1,#+1
   \   00000064   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_7:
   \   00000066   0x2D0B             CMP      R5,#+11
   \   00000068   0xD203             BCS.N    ??get_fileinfo_6
   \   0000006A   0x5CAE             LDRB     R6,[R5, R2]
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0x2E20             CMP      R6,#+32
   \   00000070   0xD1EE             BNE.N    ??get_fileinfo_8
   1871          			}
   1872          		}
   1873          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \                     ??get_fileinfo_6:
   \   00000072   0x7AD3             LDRB     R3,[R2, #+11]
   \   00000074   0x7223             STRB     R3,[R4, #+8]
   1874          		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   \   00000076   0x7FD3             LDRB     R3,[R2, #+31]
   \   00000078   0x7F95             LDRB     R5,[R2, #+30]
   \   0000007A   0x042D             LSLS     R5,R5,#+16
   \   0000007C   0xEA55 0x6303      ORRS     R3,R5,R3, LSL #+24
   \   00000080   0x7F55             LDRB     R5,[R2, #+29]
   \   00000082   0xEA53 0x2305      ORRS     R3,R3,R5, LSL #+8
   \   00000086   0x7F15             LDRB     R5,[R2, #+28]
   \   00000088   0x432B             ORRS     R3,R5,R3
   \   0000008A   0x6023             STR      R3,[R4, #+0]
   1875          		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
   \   0000008C   0x7E53             LDRB     R3,[R2, #+25]
   \   0000008E   0x7E15             LDRB     R5,[R2, #+24]
   \   00000090   0xEA55 0x2303      ORRS     R3,R5,R3, LSL #+8
   \   00000094   0x80A3             STRH     R3,[R4, #+4]
   1876          		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
   \   00000096   0x7DD3             LDRB     R3,[R2, #+23]
   \   00000098   0x7D92             LDRB     R2,[R2, #+22]
   \   0000009A   0xEA52 0x2203      ORRS     R2,R2,R3, LSL #+8
   \   0000009E   0x80E2             STRH     R2,[R4, #+6]
   1877          	}
   1878          	*p = 0;		/* Terminate SFN str by a \0 */
   \                     ??get_fileinfo_0:
   \   000000A0   0x2200             MOVS     R2,#+0
   \   000000A2   0x700A             STRB     R2,[R1, #+0]
   1879          
   1880          #if _USE_LFN
   1881          	if (fno->lfname && fno->lfsize) {
   \   000000A4   0x69A1             LDR      R1,[R4, #+24]
   \   000000A6   0x2900             CMP      R1,#+0
   \   000000A8   0xD026             BEQ.N    ??get_fileinfo_10
   \   000000AA   0x69E1             LDR      R1,[R4, #+28]
   \   000000AC   0x2900             CMP      R1,#+0
   \   000000AE   0xD023             BEQ.N    ??get_fileinfo_10
   1882          		TCHAR *tp = fno->lfname;
   \   000000B0   0x69A6             LDR      R6,[R4, #+24]
   1883          		WCHAR w, *lfn;
   1884          
   1885          		i = 0;
   \   000000B2   0x2500             MOVS     R5,#+0
   1886          		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   \   000000B4   0x6901             LDR      R1,[R0, #+16]
   \   000000B6   0x2900             CMP      R1,#+0
   \   000000B8   0xD01C             BEQ.N    ??get_fileinfo_11
   \   000000BA   0x8C01             LDRH     R1,[R0, #+32]
   \   000000BC   0xF64F 0x72FF      MOVW     R2,#+65535
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0xD017             BEQ.N    ??get_fileinfo_11
   1887          			lfn = dj->lfn;
   \   000000C4   0x69C7             LDR      R7,[R0, #+28]
   \   000000C6   0xE001             B.N      ??get_fileinfo_12
   1888          			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   1889          #if !_LFN_UNICODE
   1890          				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
   1891          				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
   1892          				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   1893          					tp[i++] = (TCHAR)(w >> 8);
   1894          #endif
   1895          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
   1896          				tp[i++] = (TCHAR)w;
   \                     ??get_fileinfo_13:
   \   000000C8   0x55A8             STRB     R0,[R5, R6]
   \   000000CA   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_12:
   \   000000CC   0x8838             LDRH     R0,[R7, #+0]
   \   000000CE   0x1CBF             ADDS     R7,R7,#+2
   \   000000D0   0x0001             MOVS     R1,R0
   \   000000D2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D4   0x2900             CMP      R1,#+0
   \   000000D6   0xD00D             BEQ.N    ??get_fileinfo_11
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DC   0x.... 0x....      BL       ff_convert
   \   000000E0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD101             BNE.N    ??get_fileinfo_14
   \   000000E6   0x2500             MOVS     R5,#+0
   \   000000E8   0xE004             B.N      ??get_fileinfo_11
   \                     ??get_fileinfo_14:
   \   000000EA   0x69E1             LDR      R1,[R4, #+28]
   \   000000EC   0x1E49             SUBS     R1,R1,#+1
   \   000000EE   0x428D             CMP      R5,R1
   \   000000F0   0xD3EA             BCC.N    ??get_fileinfo_13
   \   000000F2   0x2500             MOVS     R5,#+0
   1897          			}
   1898          		}
   1899          		tp[i] = 0;	/* Terminate the LFN str by a \0 */
   \                     ??get_fileinfo_11:
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x55A8             STRB     R0,[R5, R6]
   1900          	}
   1901          #endif
   1902          }
   \                     ??get_fileinfo_10:
   \   000000F8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1903          #endif /* _FS_MINIMIZE <= 1 */
   1904          
   1905          
   1906          
   1907          
   1908          /*-----------------------------------------------------------------------*/
   1909          /* Follow a file path                                                    */
   1910          /*-----------------------------------------------------------------------*/
   1911          

   \                                 In section .text, align 2, keep-with-next
   1912          static
   1913          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   1914          	DIR *dj,			/* Directory object to return last directory and found object */
   1915          	const TCHAR *path	/* Full-path string to find a file or directory */
   1916          )
   1917          {
   \                     follow_path:
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1918          	FRESULT res;
   1919          	BYTE *dir, ns;
   1920          
   1921          
   1922          #if _FS_RPATH
   1923          	if (*path == '/' || *path == '\\') { /* There is a heading separator */
   \   00000004   0x9801             LDR      R0,[SP, #+4]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x282F             CMP      R0,#+47
   \   0000000A   0xD003             BEQ.N    ??follow_path_0
   \   0000000C   0x9801             LDR      R0,[SP, #+4]
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x285C             CMP      R0,#+92
   \   00000012   0xD105             BNE.N    ??follow_path_1
   1924          		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
   \                     ??follow_path_0:
   \   00000014   0x9801             LDR      R0,[SP, #+4]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x9001             STR      R0,[SP, #+4]
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x60A0             STR      R0,[R4, #+8]
   \   0000001E   0xE002             B.N      ??follow_path_2
   1925          	} else {							/* No heading separator */
   1926          		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
   \                     ??follow_path_1:
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0x60A0             STR      R0,[R4, #+8]
   1927          	}
   1928          #else
   1929          	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   1930          		path++;
   1931          	dj->sclust = 0;						/* Start from the root dir */
   1932          #endif
   1933          
   1934          	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
   \                     ??follow_path_2:
   \   00000026   0x9801             LDR      R0,[SP, #+4]
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2820             CMP      R0,#+32
   \   0000002C   0xD20E             BCS.N    ??follow_path_3
   1935          		res = dir_sdi(dj, 0);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       dir_sdi
   1936          		dj->dir = 0;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6161             STR      R1,[R4, #+20]
   1937          
   1938          	} else {							/* Follow path */
   1939          		for (;;) {
   1940          			res = create_name(dj, &path);	/* Get a segment */
   1941          			if (res != FR_OK) break;
   1942          			res = dir_find(dj);				/* Find it */
   1943          			ns = *(dj->fn+NS);
   1944          			if (res != FR_OK) {				/* Failed to find the object */
   1945          				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
   1946          				/* Object not found */
   1947          				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
   1948          					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
   1949          					res = FR_OK;
   1950          					if (!(ns & NS_LAST)) continue;
   1951          				} else {							/* Could not find the object */
   1952          					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   1953          				}
   1954          				break;
   1955          			}
   1956          			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
   1957          			dir = dj->dir;						/* There is next segment. Follow the sub directory */
   1958          			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
   1959          				res = FR_NO_PATH; break;
   1960          			}
   1961          			dj->sclust = LD_CLUST(dir);
   1962          		}
   1963          	}
   1964          
   1965          	return res;
   \                     ??follow_path_4:
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   \                     ??follow_path_5:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x60A0             STR      R0,[R4, #+8]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6160             STR      R0,[R4, #+20]
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x0749             LSLS     R1,R1,#+29
   \   0000004A   0xD416             BMI.N    ??follow_path_6
   \                     ??follow_path_3:
   \   0000004C   0xA901             ADD      R1,SP,#+4
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       create_name
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD1EF             BNE.N    ??follow_path_4
   \                     ??follow_path_7:
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       dir_find
   \   00000060   0x69A1             LDR      R1,[R4, #+24]
   \   00000062   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD008             BEQ.N    ??follow_path_8
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xD1E4             BNE.N    ??follow_path_4
   \                     ??follow_path_9:
   \   00000070   0x068A             LSLS     R2,R1,#+26
   \   00000072   0xD4E4             BMI.N    ??follow_path_5
   \   00000074   0x0749             LSLS     R1,R1,#+29
   \   00000076   0xD400             BMI.N    ??follow_path_6
   \   00000078   0x2005             MOVS     R0,#+5
   \                     ??follow_path_6:
   \   0000007A   0xE7DE             B.N      ??follow_path_4
   \                     ??follow_path_8:
   \   0000007C   0x0749             LSLS     R1,R1,#+29
   \   0000007E   0xD4DC             BMI.N    ??follow_path_4
   \                     ??follow_path_10:
   \   00000080   0x6960             LDR      R0,[R4, #+20]
   \   00000082   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000084   0x06C9             LSLS     R1,R1,#+27
   \   00000086   0xD401             BMI.N    ??follow_path_11
   \   00000088   0x2005             MOVS     R0,#+5
   \   0000008A   0xE7D6             B.N      ??follow_path_4
   \                     ??follow_path_11:
   \   0000008C   0x7D41             LDRB     R1,[R0, #+21]
   \   0000008E   0x7D02             LDRB     R2,[R0, #+20]
   \   00000090   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000094   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000096   0x7EC2             LDRB     R2,[R0, #+27]
   \   00000098   0x7E80             LDRB     R0,[R0, #+26]
   \   0000009A   0xEA50 0x2002      ORRS     R0,R0,R2, LSL #+8
   \   0000009E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A0   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   000000A4   0x60A0             STR      R0,[R4, #+8]
   \   000000A6   0xE7D1             B.N      ??follow_path_3
   1966          }
   1967          
   1968          
   1969          
   1970          
   1971          /*-----------------------------------------------------------------------*/
   1972          /* Load boot record and check if it is an FAT boot record                */
   1973          /*-----------------------------------------------------------------------*/
   1974          

   \                                 In section .text, align 2, keep-with-next
   1975          static
   1976          BYTE check_fs (	/* 0:The FAT BR, 1:Valid BR but not an FAT, 2:Not a BR, 3:Disk error */
   1977          	FATFS *fs,	/* File system object */
   1978          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   1979          )
   1980          {
   \                     check_fs:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1981          	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0xF114 0x0134      ADDS     R1,R4,#+52
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x.... 0x....      BL       disk_read
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??check_fs_0
   1982          		return 3;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0xE02D             B.N      ??check_fs_1
   1983          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0:
   \   0000001A   0xF894 0x0233      LDRB     R0,[R4, #+563]
   \   0000001E   0xF894 0x1232      LDRB     R1,[R4, #+562]
   \   00000022   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000026   0xF64A 0x2155      MOVW     R1,#+43605
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD001             BEQ.N    ??check_fs_2
   1984          		return 2;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xE020             B.N      ??check_fs_1
   1985          
   1986          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \                     ??check_fs_2:
   \   00000034   0xF894 0x006C      LDRB     R0,[R4, #+108]
   \   00000038   0xF894 0x106B      LDRB     R1,[R4, #+107]
   \   0000003C   0x0209             LSLS     R1,R1,#+8
   \   0000003E   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000042   0xF894 0x106A      LDRB     R1,[R4, #+106]
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x544146
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD101             BNE.N    ??check_fs_3
   1987          		return 0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE010             B.N      ??check_fs_1
   1988          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   \                     ??check_fs_3:
   \   00000054   0xF894 0x0088      LDRB     R0,[R4, #+136]
   \   00000058   0xF894 0x1087      LDRB     R1,[R4, #+135]
   \   0000005C   0x0209             LSLS     R1,R1,#+8
   \   0000005E   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000062   0xF894 0x1086      LDRB     R1,[R4, #+134]
   \   00000066   0x4308             ORRS     R0,R1,R0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x544146
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD101             BNE.N    ??check_fs_4
   1989          		return 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE000             B.N      ??check_fs_1
   1990          
   1991          	return 1;
   \                     ??check_fs_4:
   \   00000074   0x2001             MOVS     R0,#+1
   \                     ??check_fs_1:
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
   1992          }
   1993          
   1994          
   1995          
   1996          
   1997          /*-----------------------------------------------------------------------*/
   1998          /* Check if the file system object is valid or not                       */
   1999          /*-----------------------------------------------------------------------*/
   2000          

   \                                 In section .text, align 2, keep-with-next
   2001          static
   2002          FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
   2003          	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
   2004          	FATFS **rfs,		/* Pointer to pointer to the found file system object */
   2005          	BYTE chk_wp			/* !=0: Check media write protection for write access */
   2006          )
   2007          {
   \                     chk_mounted:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0015             MOVS     R5,R2
   2008          	BYTE fmt, b, *tbl;
   2009          	UINT vol;
   2010          	DSTATUS stat;
   2011          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
   2012          	WORD nrsv;
   2013          	const TCHAR *p = *path;
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   2014          	FATFS *fs;
   2015          
   2016          	/* Get logical drive number from the path name */
   2017          	vol = p[0] - '0';					/* Is there a drive number? */
   \   00000006   0x7813             LDRB     R3,[R2, #+0]
   \   00000008   0xF1B3 0x0630      SUBS     R6,R3,#+48
   2018          	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
   \   0000000C   0x2E0A             CMP      R6,#+10
   \   0000000E   0xD205             BCS.N    ??chk_mounted_0
   \   00000010   0x7853             LDRB     R3,[R2, #+1]
   \   00000012   0x2B3A             CMP      R3,#+58
   \   00000014   0xD102             BNE.N    ??chk_mounted_0
   2019          		p += 2; *path = p;				/* Return pointer to the path name */
   \   00000016   0x1C92             ADDS     R2,R2,#+2
   \   00000018   0x6002             STR      R2,[R0, #+0]
   \   0000001A   0xE002             B.N      ??chk_mounted_1
   2020          	} else {							/* No drive number is given */
   2021          #if _FS_RPATH
   2022          		vol = CurrVol;					/* Use current drive */
   \                     ??chk_mounted_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \   00000020   0x7806             LDRB     R6,[R0, #+0]
   2023          #else
   2024          		vol = 0;						/* Use drive 0 */
   2025          #endif
   2026          	}
   2027          
   2028          	/* Check if the logical drive is valid or not */
   2029          	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
   \                     ??chk_mounted_1:
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD001             BEQ.N    ??chk_mounted_2
   2030          		return FR_INVALID_DRIVE;
   \   00000026   0x200B             MOVS     R0,#+11
   \   00000028   0xE197             B.N      ??chk_mounted_3
   2031          	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
   \                     ??chk_mounted_2:
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \   0000002E   0xF850 0x4026      LDR      R4,[R0, R6, LSL #+2]
   \   00000032   0x600C             STR      R4,[R1, #+0]
   2032          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD101             BNE.N    ??chk_mounted_4
   \   00000038   0x200C             MOVS     R0,#+12
   \   0000003A   0xE18E             B.N      ??chk_mounted_3
   2033          
   2034          	ENTER_FF(fs);						/* Lock file system */
   2035          
   2036          	if (fs->fs_type) {					/* If the logical drive has been mounted */
   \                     ??chk_mounted_4:
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD00D             BEQ.N    ??chk_mounted_5
   2037          		stat = disk_status(fs->drv);
   \   00000042   0x7860             LDRB     R0,[R4, #+1]
   \   00000044   0x.... 0x....      BL       disk_status
   2038          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
   \   00000048   0x07C1             LSLS     R1,R0,#+31
   \   0000004A   0xD408             BMI.N    ??chk_mounted_5
   2039          #if !_FS_READONLY
   2040          			if (chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD003             BEQ.N    ??chk_mounted_6
   \   00000052   0x0740             LSLS     R0,R0,#+29
   \   00000054   0xD501             BPL.N    ??chk_mounted_6
   2041          				return FR_WRITE_PROTECTED;
   \   00000056   0x200A             MOVS     R0,#+10
   \   00000058   0xE17F             B.N      ??chk_mounted_3
   2042          #endif
   2043          			return FR_OK;				/* The file system object is valid */
   \                     ??chk_mounted_6:
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xE17D             B.N      ??chk_mounted_3
   2044          		}
   2045          	}
   2046          
   2047          	/* The logical drive must be mounted. */
   2048          	/* Following code attempts to mount a volume. (analyze BPB and initialize the fs object) */
   2049          
   2050          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??chk_mounted_5:
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x7020             STRB     R0,[R4, #+0]
   2051          	fs->drv = (BYTE)LD2PD(vol);			/* Bind the logical drive and a physical drive */
   \   00000062   0x7066             STRB     R6,[R4, #+1]
   2052          	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
   \   00000064   0x7860             LDRB     R0,[R4, #+1]
   \   00000066   0x.... 0x....      BL       disk_initialize
   2053          	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   \   0000006A   0x07C1             LSLS     R1,R0,#+31
   \   0000006C   0xD501             BPL.N    ??chk_mounted_7
   2054          		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0xE173             B.N      ??chk_mounted_3
   2055          #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
   2056          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
   2057          		return FR_DISK_ERR;
   2058          #endif
   2059          #if !_FS_READONLY
   2060          	if (chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??chk_mounted_7:
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD003             BEQ.N    ??chk_mounted_8
   \   00000078   0x0740             LSLS     R0,R0,#+29
   \   0000007A   0xD501             BPL.N    ??chk_mounted_8
   2061          		return FR_WRITE_PROTECTED;
   \   0000007C   0x200A             MOVS     R0,#+10
   \   0000007E   0xE16C             B.N      ??chk_mounted_3
   2062          #endif
   2063          	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
   2064          	fmt = check_fs(fs, bsect = 0);		/* Check sector 0 if it is a VBR */
   \                     ??chk_mounted_8:
   \   00000080   0x2500             MOVS     R5,#+0
   \   00000082   0x0029             MOVS     R1,R5
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       check_fs
   \   0000008A   0x0006             MOVS     R6,R0
   2065          	if (fmt == 1) {						/* Not an FAT-VBR, the disk may be partitioned */
   \   0000008C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008E   0x2E01             CMP      R6,#+1
   \   00000090   0xD114             BNE.N    ??chk_mounted_9
   2066          		/* Check the partition listed in top of the partition table */
   2067          		tbl = &fs->win[MBR_Table + LD2PT(vol) * SZ_PTE];/* Partition table */
   \   00000092   0xF204 0x10F2      ADDW     R0,R4,#+498
   2068          		if (tbl[4]) {									/* Is the partition existing? */
   \   00000096   0x7901             LDRB     R1,[R0, #+4]
   \   00000098   0x2900             CMP      R1,#+0
   \   0000009A   0xD00F             BEQ.N    ??chk_mounted_9
   2069          			bsect = LD_DWORD(&tbl[8]);					/* Partition offset in LBA */
   \   0000009C   0x7AC1             LDRB     R1,[R0, #+11]
   \   0000009E   0x7A82             LDRB     R2,[R0, #+10]
   \   000000A0   0x0412             LSLS     R2,R2,#+16
   \   000000A2   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   000000A6   0x7A42             LDRB     R2,[R0, #+9]
   \   000000A8   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   000000AC   0x7A00             LDRB     R0,[R0, #+8]
   \   000000AE   0xEA50 0x0501      ORRS     R5,R0,R1
   2070          			fmt = check_fs(fs, bsect);					/* Check the partition */
   \   000000B2   0x0029             MOVS     R1,R5
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       check_fs
   \   000000BA   0x0006             MOVS     R6,R0
   2071          		}
   2072          	}
   2073          	if (fmt == 3) return FR_DISK_ERR;
   \                     ??chk_mounted_9:
   \   000000BC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BE   0x2E03             CMP      R6,#+3
   \   000000C0   0xD101             BNE.N    ??chk_mounted_10
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xE149             B.N      ??chk_mounted_3
   2074          	if (fmt) return FR_NO_FILESYSTEM;					/* No FAT volume is found */
   \                     ??chk_mounted_10:
   \   000000C6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C8   0x2E00             CMP      R6,#+0
   \   000000CA   0xD001             BEQ.N    ??chk_mounted_11
   \   000000CC   0x200D             MOVS     R0,#+13
   \   000000CE   0xE144             B.N      ??chk_mounted_3
   2075          
   2076          	/* Following code initializes the file system object */
   2077          
   2078          	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   \                     ??chk_mounted_11:
   \   000000D0   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   000000D4   0xF894 0x103F      LDRB     R1,[R4, #+63]
   \   000000D8   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000DC   0xF44F 0x7100      MOV      R1,#+512
   \   000000E0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E2   0x4288             CMP      R0,R1
   \   000000E4   0xD001             BEQ.N    ??chk_mounted_12
   2079          		return FR_NO_FILESYSTEM;
   \   000000E6   0x200D             MOVS     R0,#+13
   \   000000E8   0xE137             B.N      ??chk_mounted_3
   2080          
   2081          	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   \                     ??chk_mounted_12:
   \   000000EA   0xF894 0x004B      LDRB     R0,[R4, #+75]
   \   000000EE   0xF894 0x104A      LDRB     R1,[R4, #+74]
   \   000000F2   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000F6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   2082          	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD10D             BNE.N    ??chk_mounted_13
   \   000000FC   0xF894 0x005B      LDRB     R0,[R4, #+91]
   \   00000100   0xF894 0x105A      LDRB     R1,[R4, #+90]
   \   00000104   0x0409             LSLS     R1,R1,#+16
   \   00000106   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000010A   0xF894 0x1059      LDRB     R1,[R4, #+89]
   \   0000010E   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000112   0xF894 0x1058      LDRB     R1,[R4, #+88]
   \   00000116   0x4308             ORRS     R0,R1,R0
   2083          	fs->fsize = fasize;
   \                     ??chk_mounted_13:
   \   00000118   0x6220             STR      R0,[R4, #+32]
   2084          
   2085          	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   \   0000011A   0xF894 0x1044      LDRB     R1,[R4, #+68]
   \   0000011E   0x70E1             STRB     R1,[R4, #+3]
   2086          	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   \   00000120   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000122   0x2901             CMP      R1,#+1
   \   00000124   0xD004             BEQ.N    ??chk_mounted_14
   \   00000126   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000128   0x2902             CMP      R1,#+2
   \   0000012A   0xD001             BEQ.N    ??chk_mounted_14
   \   0000012C   0x200D             MOVS     R0,#+13
   \   0000012E   0xE114             B.N      ??chk_mounted_3
   2087          	fasize *= b;										/* Number of sectors for FAT area */
   \                     ??chk_mounted_14:
   \   00000130   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000132   0x4348             MULS     R0,R1,R0
   2088          
   2089          	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
   \   00000134   0xF894 0x1041      LDRB     R1,[R4, #+65]
   \   00000138   0x70A1             STRB     R1,[R4, #+2]
   2090          	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   \   0000013A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000013C   0x2900             CMP      R1,#+0
   \   0000013E   0xD003             BEQ.N    ??chk_mounted_15
   \   00000140   0x1E4A             SUBS     R2,R1,#+1
   \   00000142   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000144   0x4211             TST      R1,R2
   \   00000146   0xD001             BEQ.N    ??chk_mounted_16
   \                     ??chk_mounted_15:
   \   00000148   0x200D             MOVS     R0,#+13
   \   0000014A   0xE106             B.N      ??chk_mounted_3
   2091          
   2092          	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   \                     ??chk_mounted_16:
   \   0000014C   0xF894 0x1046      LDRB     R1,[R4, #+70]
   \   00000150   0xF894 0x2045      LDRB     R2,[R4, #+69]
   \   00000154   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000158   0x8121             STRH     R1,[R4, #+8]
   2093          	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   \   0000015A   0x8921             LDRH     R1,[R4, #+8]
   \   0000015C   0x2210             MOVS     R2,#+16
   \   0000015E   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   00000162   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   00000166   0x2B00             CMP      R3,#+0
   \   00000168   0xD001             BEQ.N    ??chk_mounted_17
   \   0000016A   0x200D             MOVS     R0,#+13
   \   0000016C   0xE0F5             B.N      ??chk_mounted_3
   2094          
   2095          	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   \                     ??chk_mounted_17:
   \   0000016E   0xF894 0x1048      LDRB     R1,[R4, #+72]
   \   00000172   0xF894 0x2047      LDRB     R2,[R4, #+71]
   \   00000176   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \   0000017A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   2096          	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   \   0000017C   0x2A00             CMP      R2,#+0
   \   0000017E   0xD10D             BNE.N    ??chk_mounted_18
   \   00000180   0xF894 0x1057      LDRB     R1,[R4, #+87]
   \   00000184   0xF894 0x2056      LDRB     R2,[R4, #+86]
   \   00000188   0x0412             LSLS     R2,R2,#+16
   \   0000018A   0xEA52 0x6101      ORRS     R1,R2,R1, LSL #+24
   \   0000018E   0xF894 0x2055      LDRB     R2,[R4, #+85]
   \   00000192   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   \   00000196   0xF894 0x2054      LDRB     R2,[R4, #+84]
   \   0000019A   0x430A             ORRS     R2,R2,R1
   2097          
   2098          	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   \                     ??chk_mounted_18:
   \   0000019C   0xF894 0x1043      LDRB     R1,[R4, #+67]
   \   000001A0   0xF894 0x3042      LDRB     R3,[R4, #+66]
   \   000001A4   0xEA53 0x2101      ORRS     R1,R3,R1, LSL #+8
   2099          	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   \   000001A8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001AA   0x2900             CMP      R1,#+0
   \   000001AC   0xD101             BNE.N    ??chk_mounted_19
   \   000001AE   0x200D             MOVS     R0,#+13
   \   000001B0   0xE0D3             B.N      ??chk_mounted_3
   2100          
   2101          	/* Determine the FAT sub type */
   2102          	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
   \                     ??chk_mounted_19:
   \   000001B2   0xFA10 0xF381      UXTAH    R3,R0,R1
   \   000001B6   0x8926             LDRH     R6,[R4, #+8]
   \   000001B8   0xEB13 0x1316      ADDS     R3,R3,R6, LSR #+4
   2103          	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   \   000001BC   0x429A             CMP      R2,R3
   \   000001BE   0xD201             BCS.N    ??chk_mounted_20
   \   000001C0   0x200D             MOVS     R0,#+13
   \   000001C2   0xE0CA             B.N      ??chk_mounted_3
   2104          	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   \                     ??chk_mounted_20:
   \   000001C4   0x1AD2             SUBS     R2,R2,R3
   \   000001C6   0x78A6             LDRB     R6,[R4, #+2]
   \   000001C8   0xFBB2 0xF2F6      UDIV     R2,R2,R6
   2105          	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   \   000001CC   0x2A00             CMP      R2,#+0
   \   000001CE   0xD101             BNE.N    ??chk_mounted_21
   \   000001D0   0x200D             MOVS     R0,#+13
   \   000001D2   0xE0C2             B.N      ??chk_mounted_3
   2106          	fmt = FS_FAT12;
   \                     ??chk_mounted_21:
   \   000001D4   0x2601             MOVS     R6,#+1
   2107          	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   000001D6   0xF640 0x77F6      MOVW     R7,#+4086
   \   000001DA   0x42BA             CMP      R2,R7
   \   000001DC   0xD300             BCC.N    ??chk_mounted_22
   \   000001DE   0x2602             MOVS     R6,#+2
   2108          	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??chk_mounted_22:
   \   000001E0   0xF64F 0x77F6      MOVW     R7,#+65526
   \   000001E4   0x42BA             CMP      R2,R7
   \   000001E6   0xD300             BCC.N    ??chk_mounted_23
   \   000001E8   0x2603             MOVS     R6,#+3
   2109          
   2110          	/* Boundaries and Limits */
   2111          	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   \                     ??chk_mounted_23:
   \   000001EA   0x1C92             ADDS     R2,R2,#+2
   \   000001EC   0x61E2             STR      R2,[R4, #+28]
   2112          	fs->database = bsect + sysect;						/* Data start sector */
   \   000001EE   0x195A             ADDS     R2,R3,R5
   \   000001F0   0x62E2             STR      R2,[R4, #+44]
   2113          	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   \   000001F2   0xFA15 0xF181      UXTAH    R1,R5,R1
   \   000001F6   0x6261             STR      R1,[R4, #+36]
   2114          	if (fmt == FS_FAT32) {
   \   000001F8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001FA   0x2E03             CMP      R6,#+3
   \   000001FC   0xD116             BNE.N    ??chk_mounted_24
   2115          		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   \   000001FE   0x8920             LDRH     R0,[R4, #+8]
   \   00000200   0x2800             CMP      R0,#+0
   \   00000202   0xD001             BEQ.N    ??chk_mounted_25
   \   00000204   0x200D             MOVS     R0,#+13
   \   00000206   0xE0A8             B.N      ??chk_mounted_3
   2116          		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   \                     ??chk_mounted_25:
   \   00000208   0xF894 0x0063      LDRB     R0,[R4, #+99]
   \   0000020C   0xF894 0x1062      LDRB     R1,[R4, #+98]
   \   00000210   0x0409             LSLS     R1,R1,#+16
   \   00000212   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000216   0xF894 0x1061      LDRB     R1,[R4, #+97]
   \   0000021A   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000021E   0xF894 0x1060      LDRB     R1,[R4, #+96]
   \   00000222   0x4308             ORRS     R0,R1,R0
   \   00000224   0x62A0             STR      R0,[R4, #+40]
   2117          		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
   \   00000226   0x69E0             LDR      R0,[R4, #+28]
   \   00000228   0x0080             LSLS     R0,R0,#+2
   \   0000022A   0xE015             B.N      ??chk_mounted_26
   2118          	} else {
   2119          		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   \                     ??chk_mounted_24:
   \   0000022C   0x8921             LDRH     R1,[R4, #+8]
   \   0000022E   0x2900             CMP      R1,#+0
   \   00000230   0xD101             BNE.N    ??chk_mounted_27
   \   00000232   0x200D             MOVS     R0,#+13
   \   00000234   0xE091             B.N      ??chk_mounted_3
   2120          		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   \                     ??chk_mounted_27:
   \   00000236   0x6A61             LDR      R1,[R4, #+36]
   \   00000238   0x1840             ADDS     R0,R0,R1
   \   0000023A   0x62A0             STR      R0,[R4, #+40]
   2121          		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
   2122          			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   0000023C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000023E   0x2E02             CMP      R6,#+2
   \   00000240   0xD102             BNE.N    ??chk_mounted_28
   \   00000242   0x69E0             LDR      R0,[R4, #+28]
   \   00000244   0x0040             LSLS     R0,R0,#+1
   \   00000246   0xE007             B.N      ??chk_mounted_26
   \                     ??chk_mounted_28:
   \   00000248   0x69E0             LDR      R0,[R4, #+28]
   \   0000024A   0x2103             MOVS     R1,#+3
   \   0000024C   0x4348             MULS     R0,R1,R0
   \   0000024E   0x7F21             LDRB     R1,[R4, #+28]
   \   00000250   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   00000254   0xEB11 0x0050      ADDS     R0,R1,R0, LSR #+1
   2123          	}
   2124          	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   \                     ??chk_mounted_26:
   \   00000258   0x6A21             LDR      R1,[R4, #+32]
   \   0000025A   0xF200 0x10FF      ADDW     R0,R0,#+511
   \   0000025E   0xEBB1 0x2F50      CMP      R1,R0, LSR #+9
   \   00000262   0xD201             BCS.N    ??chk_mounted_29
   2125          		return FR_NO_FILESYSTEM;
   \   00000264   0x200D             MOVS     R0,#+13
   \   00000266   0xE078             B.N      ??chk_mounted_3
   2126          
   2127          #if !_FS_READONLY
   2128          	/* Initialize cluster allocation information */
   2129          	fs->free_clust = 0xFFFFFFFF;
   \                     ??chk_mounted_29:
   \   00000268   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000026C   0x6120             STR      R0,[R4, #+16]
   2130          	fs->last_clust = 0;
   \   0000026E   0x2000             MOVS     R0,#+0
   \   00000270   0x60E0             STR      R0,[R4, #+12]
   2131          
   2132          	/* Get fsinfo if available */
   2133          	if (fmt == FS_FAT32) {
   \   00000272   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000274   0x2E03             CMP      R6,#+3
   \   00000276   0xD160             BNE.N    ??chk_mounted_30
   2134          	 	fs->fsi_flag = 0;
   \   00000278   0x2000             MOVS     R0,#+0
   \   0000027A   0x7160             STRB     R0,[R4, #+5]
   2135          		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   \   0000027C   0xF894 0x0065      LDRB     R0,[R4, #+101]
   \   00000280   0xF894 0x1064      LDRB     R1,[R4, #+100]
   \   00000284   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000288   0xFA15 0xF080      UXTAH    R0,R5,R0
   \   0000028C   0x6160             STR      R0,[R4, #+20]
   2136          		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   2137          			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   2138          			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   2139          			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   \   0000028E   0x2301             MOVS     R3,#+1
   \   00000290   0x6962             LDR      R2,[R4, #+20]
   \   00000292   0xF114 0x0134      ADDS     R1,R4,#+52
   \   00000296   0x7860             LDRB     R0,[R4, #+1]
   \   00000298   0x.... 0x....      BL       disk_read
   \   0000029C   0x2800             CMP      R0,#+0
   \   0000029E   0xD14C             BNE.N    ??chk_mounted_30
   \   000002A0   0xF894 0x0233      LDRB     R0,[R4, #+563]
   \   000002A4   0xF894 0x1232      LDRB     R1,[R4, #+562]
   \   000002A8   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000002AC   0xF64A 0x2155      MOVW     R1,#+43605
   \   000002B0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000002B2   0x4288             CMP      R0,R1
   \   000002B4   0xD141             BNE.N    ??chk_mounted_30
   \   000002B6   0xF894 0x0037      LDRB     R0,[R4, #+55]
   \   000002BA   0xF894 0x1036      LDRB     R1,[R4, #+54]
   \   000002BE   0x0409             LSLS     R1,R1,#+16
   \   000002C0   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000002C4   0xF894 0x1035      LDRB     R1,[R4, #+53]
   \   000002C8   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000002CC   0xF894 0x1034      LDRB     R1,[R4, #+52]
   \   000002D0   0x4308             ORRS     R0,R1,R0
   \   000002D2   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x41615252
   \   000002D6   0x4288             CMP      R0,R1
   \   000002D8   0xD12F             BNE.N    ??chk_mounted_30
   \   000002DA   0xF894 0x021B      LDRB     R0,[R4, #+539]
   \   000002DE   0xF894 0x121A      LDRB     R1,[R4, #+538]
   \   000002E2   0x0409             LSLS     R1,R1,#+16
   \   000002E4   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   000002E8   0xF894 0x1219      LDRB     R1,[R4, #+537]
   \   000002EC   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000002F0   0xF894 0x1218      LDRB     R1,[R4, #+536]
   \   000002F4   0x4308             ORRS     R0,R1,R0
   \   000002F6   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x61417272
   \   000002FA   0x4288             CMP      R0,R1
   \   000002FC   0xD11D             BNE.N    ??chk_mounted_30
   2140          				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   \   000002FE   0xF894 0x0223      LDRB     R0,[R4, #+547]
   \   00000302   0xF894 0x1222      LDRB     R1,[R4, #+546]
   \   00000306   0x0409             LSLS     R1,R1,#+16
   \   00000308   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000030C   0xF894 0x1221      LDRB     R1,[R4, #+545]
   \   00000310   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000314   0xF894 0x1220      LDRB     R1,[R4, #+544]
   \   00000318   0x4308             ORRS     R0,R1,R0
   \   0000031A   0x60E0             STR      R0,[R4, #+12]
   2141          				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   \   0000031C   0xF894 0x021F      LDRB     R0,[R4, #+543]
   \   00000320   0xF894 0x121E      LDRB     R1,[R4, #+542]
   \   00000324   0x0409             LSLS     R1,R1,#+16
   \   00000326   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   0000032A   0xF894 0x121D      LDRB     R1,[R4, #+541]
   \   0000032E   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000332   0xF894 0x121C      LDRB     R1,[R4, #+540]
   \   00000336   0x4308             ORRS     R0,R1,R0
   \   00000338   0x6120             STR      R0,[R4, #+16]
   2142          		}
   2143          	}
   2144          #endif
   2145          	fs->fs_type = fmt;		/* FAT sub-type */
   \                     ??chk_mounted_30:
   \   0000033A   0x7026             STRB     R6,[R4, #+0]
   2146          	fs->id = ++Fsid;		/* File system mount ID */
   \   0000033C   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000340   0x8800             LDRH     R0,[R0, #+0]
   \   00000342   0x1C40             ADDS     R0,R0,#+1
   \   00000344   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000348   0x8008             STRH     R0,[R1, #+0]
   \   0000034A   0x80E0             STRH     R0,[R4, #+6]
   2147          	fs->winsect = 0;		/* Invalidate sector cache */
   \   0000034C   0x2000             MOVS     R0,#+0
   \   0000034E   0x6320             STR      R0,[R4, #+48]
   2148          	fs->wflag = 0;
   \   00000350   0x2000             MOVS     R0,#+0
   \   00000352   0x7120             STRB     R0,[R4, #+4]
   2149          #if _FS_RPATH
   2150          	fs->cdir = 0;			/* Current directory (root dir) */
   \   00000354   0x2000             MOVS     R0,#+0
   \   00000356   0x61A0             STR      R0,[R4, #+24]
   2151          #endif
   2152          #if _FS_SHARE				/* Clear file lock semaphores */
   2153          	clear_lock(fs);
   2154          #endif
   2155          
   2156          	return FR_OK;
   \   00000358   0x2000             MOVS     R0,#+0
   \                     ??chk_mounted_3:
   \   0000035A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2157          }
   2158          
   2159          
   2160          
   2161          
   2162          /*-----------------------------------------------------------------------*/
   2163          /* Check if the file/dir object is valid or not                          */
   2164          /*-----------------------------------------------------------------------*/
   2165          

   \                                 In section .text, align 2, keep-with-next
   2166          static
   2167          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   2168          	FATFS *fs,		/* Pointer to the file system object */
   2169          	WORD id			/* Member id of the target object to be checked */
   2170          )
   2171          {
   \                     validate:
   \   00000000   0xB580             PUSH     {R7,LR}
   2172          	if (!fs || !fs->fs_type || fs->id != id)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD006             BEQ.N    ??validate_0
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD003             BEQ.N    ??validate_0
   \   0000000C   0x88C2             LDRH     R2,[R0, #+6]
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0x428A             CMP      R2,R1
   \   00000012   0xD001             BEQ.N    ??validate_1
   2173          		return FR_INVALID_OBJECT;
   \                     ??validate_0:
   \   00000014   0x2009             MOVS     R0,#+9
   \   00000016   0xE007             B.N      ??validate_2
   2174          
   2175          	ENTER_FF(fs);		/* Lock file system */
   2176          
   2177          	if (disk_status(fs->drv) & STA_NOINIT)
   \                     ??validate_1:
   \   00000018   0x7840             LDRB     R0,[R0, #+1]
   \   0000001A   0x.... 0x....      BL       disk_status
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD501             BPL.N    ??validate_3
   2178          		return FR_NOT_READY;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE000             B.N      ??validate_2
   2179          
   2180          	return FR_OK;
   \                     ??validate_3:
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??validate_2:
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
   2181          }
   2182          
   2183          
   2184          
   2185          
   2186          /*--------------------------------------------------------------------------
   2187          
   2188             Public Functions
   2189          
   2190          --------------------------------------------------------------------------*/
   2191          
   2192          
   2193          
   2194          /*-----------------------------------------------------------------------*/
   2195          /* Mount/Unmount a Logical Drive                                         */
   2196          /*-----------------------------------------------------------------------*/
   2197          

   \                                 In section .text, align 2, keep-with-next
   2198          FRESULT f_mount (
   2199          	BYTE vol,		/* Logical drive number to be mounted/unmounted */
   2200          	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
   2201          )
   2202          {
   2203          	FATFS *rfs;
   2204          
   2205          
   2206          	if (vol >= _VOLUMES)			/* Check if the drive number is valid */
   \                     f_mount:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD301             BCC.N    ??f_mount_0
   2207          		return FR_INVALID_DRIVE;
   \   00000006   0x200B             MOVS     R0,#+11
   \   00000008   0xE012             B.N      ??f_mount_1
   2208          	rfs = FatFs[vol];				/* Get current fs object */
   \                     ??f_mount_0:
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable9_4
   \   00000010   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   2209          
   2210          	if (rfs) {
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD001             BEQ.N    ??f_mount_2
   2211          #if _FS_SHARE
   2212          		clear_lock(rfs);
   2213          #endif
   2214          #if _FS_REENTRANT					/* Discard sync object of the current volume */
   2215          		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
   2216          #endif
   2217          		rfs->fs_type = 0;			/* Clear old fs object */
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x7013             STRB     R3,[R2, #+0]
   2218          	}
   2219          
   2220          	if (fs) {
   \                     ??f_mount_2:
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD001             BEQ.N    ??f_mount_3
   2221          		fs->fs_type = 0;			/* Clear new fs object */
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x700A             STRB     R2,[R1, #+0]
   2222          #if _FS_REENTRANT					/* Create sync object for the new volume */
   2223          		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
   2224          #endif
   2225          	}
   2226          	FatFs[vol] = fs;				/* Register new fs object */
   \                     ??f_mount_3:
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable9_4
   \   0000002A   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   2227          
   2228          	return FR_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??f_mount_1:
   \   00000030   0x4770             BX       LR               ;; return
   2229          }
   2230          
   2231          
   2232          
   2233          
   2234          /*-----------------------------------------------------------------------*/
   2235          /* Open or Create a File                                                 */
   2236          /*-----------------------------------------------------------------------*/
   2237          

   \                                 In section .text, align 2, keep-with-next
   2238          FRESULT f_open (
   2239          	FIL *fp,			/* Pointer to the blank file object */
   2240          	const TCHAR *path,	/* Pointer to the file name */
   2241          	BYTE mode			/* Access mode and file open mode flags */
   2242          )
   2243          {
   \                     f_open:
   \   00000000   0xE92D 0x43F2      PUSH     {R1,R4-R9,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x0015             MOVS     R5,R2
   2244          	FRESULT res;
   2245          	DIR dj;
   2246          	BYTE *dir;
   2247          	DEF_NAMEBUF;
   2248          
   2249          
   2250          	fp->fs = 0;			/* Clear file object */
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x6020             STR      R0,[R4, #+0]
   2251          
   2252          #if !_FS_READONLY
   2253          	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   0000000E   0xF015 0x051F      ANDS     R5,R5,#0x1F
   2254          	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   \   00000012   0xF015 0x02FE      ANDS     R2,R5,#0xFE
   \   00000016   0xA900             ADD      R1,SP,#+0
   \   00000018   0xA80C             ADD      R0,SP,#+48
   \   0000001A   0x.... 0x....      BL       chk_mounted
   \   0000001E   0x0006             MOVS     R6,R0
   2255          #else
   2256          	mode &= FA_READ;
   2257          	res = chk_mounted(&path, &dj.fs, 0);
   2258          #endif
   2259          	INIT_BUF(dj);
   \   00000020   0xA809             ADD      R0,SP,#+36
   \   00000022   0x9006             STR      R0,[SP, #+24]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \   00000028   0x9007             STR      R0,[SP, #+28]
   2260          	if (res == FR_OK)
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E00             CMP      R6,#+0
   \   0000002E   0xD104             BNE.N    ??f_open_0
   2261          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000030   0x990C             LDR      R1,[SP, #+48]
   \   00000032   0xA800             ADD      R0,SP,#+0
   \   00000034   0x.... 0x....      BL       follow_path
   \   00000038   0x0006             MOVS     R6,R0
   2262          	dir = dj.dir;
   \                     ??f_open_0:
   \   0000003A   0x9F05             LDR      R7,[SP, #+20]
   2263          
   2264          #if !_FS_READONLY	/* R/W configuration */
   2265          	if (res == FR_OK) {
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x2E00             CMP      R6,#+0
   \   00000040   0xD102             BNE.N    ??f_open_1
   2266          		if (!dir)	/* Current dir itself */
   \   00000042   0x2F00             CMP      R7,#+0
   \   00000044   0xD100             BNE.N    ??f_open_1
   2267          			res = FR_INVALID_NAME;
   \   00000046   0x2606             MOVS     R6,#+6
   2268          #if _FS_SHARE
   2269          		else
   2270          			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2271          #endif
   2272          	}
   2273          	/* Create or Open a file */
   2274          	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \                     ??f_open_1:
   \   00000048   0x201C             MOVS     R0,#+28
   \   0000004A   0x4205             TST      R5,R0
   \   0000004C   0xD063             BEQ.N    ??f_open_2
   2275          		DWORD dw, cl;
   2276          
   2277          		if (res != FR_OK) {					/* No file, create new */
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD00A             BEQ.N    ??f_open_3
   2278          			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   \   00000054   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000056   0x2E04             CMP      R6,#+4
   \   00000058   0xD103             BNE.N    ??f_open_4
   2279          #if _FS_SHARE
   2280          				res = enq_lock(dj.fs) ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   2281          #else
   2282          				res = dir_register(&dj);
   \   0000005A   0xA800             ADD      R0,SP,#+0
   \   0000005C   0x.... 0x....      BL       dir_register
   \   00000060   0x0006             MOVS     R6,R0
   2283          #endif
   2284          			mode |= FA_CREATE_ALWAYS;		/* File is created */
   \                     ??f_open_4:
   \   00000062   0xF055 0x0508      ORRS     R5,R5,#0x8
   2285          			dir = dj.dir;					/* New entry */
   \   00000066   0x9F05             LDR      R7,[SP, #+20]
   \   00000068   0xE008             B.N      ??f_open_5
   2286          		}
   2287          		else {								/* Any object is already existing */
   2288          			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   \                     ??f_open_3:
   \   0000006A   0x7AF8             LDRB     R0,[R7, #+11]
   \   0000006C   0x2111             MOVS     R1,#+17
   \   0000006E   0x4208             TST      R0,R1
   \   00000070   0xD001             BEQ.N    ??f_open_6
   2289          				res = FR_DENIED;
   \   00000072   0x2607             MOVS     R6,#+7
   \   00000074   0xE002             B.N      ??f_open_5
   2290          			} else {
   2291          				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   \                     ??f_open_6:
   \   00000076   0x0768             LSLS     R0,R5,#+29
   \   00000078   0xD500             BPL.N    ??f_open_5
   2292          					res = FR_EXIST;
   \   0000007A   0x2608             MOVS     R6,#+8
   2293          			}
   2294          		}
   2295          		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   \                     ??f_open_5:
   \   0000007C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007E   0x2E00             CMP      R6,#+0
   \   00000080   0xD157             BNE.N    ??f_open_7
   \   00000082   0x0728             LSLS     R0,R5,#+28
   \   00000084   0xD555             BPL.N    ??f_open_7
   2296          			dw = get_fattime();					/* Created time */
   \   00000086   0x.... 0x....      BL       get_fattime
   \   0000008A   0x4680             MOV      R8,R0
   2297          			ST_DWORD(dir+DIR_CrtTime, dw);
   \   0000008C   0xF887 0x800E      STRB     R8,[R7, #+14]
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000094   0x0A00             LSRS     R0,R0,#+8
   \   00000096   0x73F8             STRB     R0,[R7, #+15]
   \   00000098   0xEA5F 0x4018      LSRS     R0,R8,#+16
   \   0000009C   0x7438             STRB     R0,[R7, #+16]
   \   0000009E   0xEA5F 0x6018      LSRS     R0,R8,#+24
   \   000000A2   0x7478             STRB     R0,[R7, #+17]
   2298          			dir[DIR_Attr] = 0;					/* Reset attribute */
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x72F8             STRB     R0,[R7, #+11]
   2299          			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x7738             STRB     R0,[R7, #+28]
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x7778             STRB     R0,[R7, #+29]
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x77B8             STRB     R0,[R7, #+30]
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x77F8             STRB     R0,[R7, #+31]
   2300          			cl = LD_CLUST(dir);					/* Get start cluster */
   \   000000B8   0x7D78             LDRB     R0,[R7, #+21]
   \   000000BA   0x7D39             LDRB     R1,[R7, #+20]
   \   000000BC   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000C0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C2   0x7EF9             LDRB     R1,[R7, #+27]
   \   000000C4   0x7EBA             LDRB     R2,[R7, #+26]
   \   000000C6   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   000000CA   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000CC   0xEA51 0x4900      ORRS     R9,R1,R0, LSL #+16
   2301          			ST_CLUST(dir, 0);					/* cluster = 0 */
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x76B8             STRB     R0,[R7, #+26]
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x76F8             STRB     R0,[R7, #+27]
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x7538             STRB     R0,[R7, #+20]
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x7578             STRB     R0,[R7, #+21]
   2302          			dj.fs->wflag = 1;
   \   000000E0   0x9800             LDR      R0,[SP, #+0]
   \   000000E2   0x2101             MOVS     R1,#+1
   \   000000E4   0x7101             STRB     R1,[R0, #+4]
   2303          			if (cl) {							/* Remove the cluster chain if exist */
   \   000000E6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000EA   0xD022             BEQ.N    ??f_open_7
   2304          				dw = dj.fs->winsect;
   \   000000EC   0x9800             LDR      R0,[SP, #+0]
   \   000000EE   0xF8D0 0x8030      LDR      R8,[R0, #+48]
   2305          				res = remove_chain(dj.fs, cl);
   \   000000F2   0x4649             MOV      R1,R9
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       remove_chain
   \   000000FA   0x0006             MOVS     R6,R0
   2306          				if (res == FR_OK) {
   \   000000FC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000FE   0x2E00             CMP      R6,#+0
   \   00000100   0xD117             BNE.N    ??f_open_7
   2307          					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   00000102   0x9800             LDR      R0,[SP, #+0]
   \   00000104   0xF1B9 0x0101      SUBS     R1,R9,#+1
   \   00000108   0x60C1             STR      R1,[R0, #+12]
   2308          					res = move_window(dj.fs, dw);
   \   0000010A   0x4641             MOV      R1,R8
   \   0000010C   0x9800             LDR      R0,[SP, #+0]
   \   0000010E   0x.... 0x....      BL       move_window
   \   00000112   0x0006             MOVS     R6,R0
   \   00000114   0xE00D             B.N      ??f_open_7
   2309          				}
   2310          			}
   2311          		}
   2312          	}
   2313          	else {	/* Open an existing file */
   2314          		if (res == FR_OK) {						/* Follow succeeded */
   \                     ??f_open_2:
   \   00000116   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000118   0x2E00             CMP      R6,#+0
   \   0000011A   0xD10A             BNE.N    ??f_open_7
   2315          			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
   \   0000011C   0x7AF8             LDRB     R0,[R7, #+11]
   \   0000011E   0x06C0             LSLS     R0,R0,#+27
   \   00000120   0xD501             BPL.N    ??f_open_8
   2316          				res = FR_NO_FILE;
   \   00000122   0x2604             MOVS     R6,#+4
   \   00000124   0xE005             B.N      ??f_open_7
   2317          			} else {
   2318          				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   \                     ??f_open_8:
   \   00000126   0x07A8             LSLS     R0,R5,#+30
   \   00000128   0xD503             BPL.N    ??f_open_7
   \   0000012A   0x7AF8             LDRB     R0,[R7, #+11]
   \   0000012C   0x07C0             LSLS     R0,R0,#+31
   \   0000012E   0xD500             BPL.N    ??f_open_7
   2319          					res = FR_DENIED;
   \   00000130   0x2607             MOVS     R6,#+7
   2320          			}
   2321          		}
   2322          	}
   2323          	if (res == FR_OK) {
   \                     ??f_open_7:
   \   00000132   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000134   0x2E00             CMP      R6,#+0
   \   00000136   0xD107             BNE.N    ??f_open_9
   2324          		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
   \   00000138   0x0728             LSLS     R0,R5,#+28
   \   0000013A   0xD501             BPL.N    ??f_open_10
   2325          			mode |= FA__WRITTEN;
   \   0000013C   0xF055 0x0520      ORRS     R5,R5,#0x20
   2326          		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
   \                     ??f_open_10:
   \   00000140   0x9800             LDR      R0,[SP, #+0]
   \   00000142   0x6B00             LDR      R0,[R0, #+48]
   \   00000144   0x61E0             STR      R0,[R4, #+28]
   2327          		fp->dir_ptr = dir;
   \   00000146   0x6227             STR      R7,[R4, #+32]
   2328          #if _FS_SHARE
   2329          		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2330          		if (!fp->lockid) res = FR_INT_ERR;
   2331          #endif
   2332          	}
   2333          
   2334          #else				/* R/O configuration */
   2335          	if (res == FR_OK) {					/* Follow succeeded */
   2336          		if (!dir) {						/* Current dir itself */
   2337          			res = FR_INVALID_NAME;
   2338          		} else {
   2339          			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
   2340          				res = FR_NO_FILE;
   2341          		}
   2342          	}
   2343          #endif
   2344          	FREE_BUF();
   2345          
   2346          	if (res == FR_OK) {
   \                     ??f_open_9:
   \   00000148   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000014A   0x2E00             CMP      R6,#+0
   \   0000014C   0xD123             BNE.N    ??f_open_11
   2347          		fp->flag = mode;					/* File access mode */
   \   0000014E   0x71A5             STRB     R5,[R4, #+6]
   2348          		fp->sclust = LD_CLUST(dir);			/* File start cluster */
   \   00000150   0x7D78             LDRB     R0,[R7, #+21]
   \   00000152   0x7D39             LDRB     R1,[R7, #+20]
   \   00000154   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000158   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000015A   0x7EF9             LDRB     R1,[R7, #+27]
   \   0000015C   0x7EBA             LDRB     R2,[R7, #+26]
   \   0000015E   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000162   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000164   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000168   0x6120             STR      R0,[R4, #+16]
   2349          		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   \   0000016A   0x7FF8             LDRB     R0,[R7, #+31]
   \   0000016C   0x7FB9             LDRB     R1,[R7, #+30]
   \   0000016E   0x0409             LSLS     R1,R1,#+16
   \   00000170   0xEA51 0x6000      ORRS     R0,R1,R0, LSL #+24
   \   00000174   0x7F79             LDRB     R1,[R7, #+29]
   \   00000176   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000017A   0x7F39             LDRB     R1,[R7, #+28]
   \   0000017C   0x4308             ORRS     R0,R1,R0
   \   0000017E   0x60E0             STR      R0,[R4, #+12]
   2350          		fp->fptr = 0;						/* File pointer */
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x60A0             STR      R0,[R4, #+8]
   2351          		fp->dsect = 0;
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0x61A0             STR      R0,[R4, #+24]
   2352          #if _USE_FASTSEEK
   2353          		fp->cltbl = 0;						/* Normal seek mode */
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0x6260             STR      R0,[R4, #+36]
   2354          #endif
   2355          		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
   \   0000018C   0x9800             LDR      R0,[SP, #+0]
   \   0000018E   0x6020             STR      R0,[R4, #+0]
   \   00000190   0x9800             LDR      R0,[SP, #+0]
   \   00000192   0x88C0             LDRH     R0,[R0, #+6]
   \   00000194   0x80A0             STRH     R0,[R4, #+4]
   2356          	}
   2357          
   2358          	LEAVE_FF(dj.fs, res);
   \                     ??f_open_11:
   \   00000196   0x0030             MOVS     R0,R6
   \   00000198   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000019A   0xB00D             ADD      SP,SP,#+52
   \   0000019C   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2359          }
   2360          
   2361          
   2362          
   2363          
   2364          /*-----------------------------------------------------------------------*/
   2365          /* Read File                                                             */
   2366          /*-----------------------------------------------------------------------*/
   2367          

   \                                 In section .text, align 2, keep-with-next
   2368          FRESULT f_read (
   2369          	FIL *fp, 		/* Pointer to the file object */
   2370          	void *buff,		/* Pointer to data buffer */
   2371          	UINT btr,		/* Number of bytes to read */
   2372          	UINT *br		/* Pointer to number of bytes read */
   2373          )
   2374          {
   \                     f_read:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   2375          	FRESULT res;
   2376          	DWORD clst, sect, remain;
   2377          	UINT rcnt, cc;
   2378          	BYTE csect, *rbuff = buff;
   \   0000000A   0x000C             MOVS     R4,R1
   2379          
   2380          
   2381          	*br = 0;	/* Initialize byte counter */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6038             STR      R0,[R7, #+0]
   2382          
   2383          	res = validate(fp->fs, fp->id);				/* Check validity */
   \   00000010   0x88A9             LDRH     R1,[R5, #+4]
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x.... 0x....      BL       validate
   2384          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??f_read_0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xE0ED             B.N      ??f_read_1
   2385          	if (fp->flag & FA__ERROR)					/* Aborted file? */
   \                     ??f_read_0:
   \   00000022   0x79A8             LDRB     R0,[R5, #+6]
   \   00000024   0x0600             LSLS     R0,R0,#+24
   \   00000026   0xD501             BPL.N    ??f_read_2
   2386          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE0E8             B.N      ??f_read_1
   2387          	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   \                     ??f_read_2:
   \   0000002C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000002E   0x07C0             LSLS     R0,R0,#+31
   \   00000030   0xD401             BMI.N    ??f_read_3
   2388          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00000032   0x2007             MOVS     R0,#+7
   \   00000034   0xE0E3             B.N      ??f_read_1
   2389          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_3:
   \   00000036   0x68E8             LDR      R0,[R5, #+12]
   \   00000038   0x68A9             LDR      R1,[R5, #+8]
   \   0000003A   0x1A40             SUBS     R0,R0,R1
   2390          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   \   0000003C   0x42B0             CMP      R0,R6
   \   0000003E   0xD22B             BCS.N    ??f_read_4
   \   00000040   0x0006             MOVS     R6,R0
   \   00000042   0xE029             B.N      ??f_read_4
   2391          
   2392          	for ( ;  btr;								/* Repeat until all data read */
   2393          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   2394          		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   2395          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2396          			if (!csect) {						/* On the cluster boundary? */
   2397          				if (fp->fptr == 0) {			/* On the top of the file? */
   2398          					clst = fp->sclust;			/* Follow from the origin */
   2399          				} else {						/* Middle or end of the file */
   2400          #if _USE_FASTSEEK
   2401          					if (fp->cltbl)
   2402          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2403          					else
   2404          #endif
   2405          						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   2406          				}
   2407          				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   2408          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2409          				fp->clust = clst;				/* Update current cluster */
   2410          			}
   2411          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2412          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2413          			sect += csect;
   2414          			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   2415          			if (cc) {							/* Read maximum contiguous sectors directly */
   2416          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2417          					cc = fp->fs->csize - csect;
   2418          				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
   2419          					ABORT(fp->fs, FR_DISK_ERR);
   2420          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   2421          #if _FS_TINY
   2422          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
   2423          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   2424          #else
   2425          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   2426          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   2427          #endif
   2428          #endif
   2429          				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   2430          				continue;
   2431          			}
   2432          #if !_FS_TINY
   2433          			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   2434          #if !_FS_READONLY
   2435          				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   2436          					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2437          						ABORT(fp->fs, FR_DISK_ERR);
   2438          					fp->flag &= ~FA__DIRTY;
   2439          				}
   2440          #endif
   2441          				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   2442          					ABORT(fp->fs, FR_DISK_ERR);
   2443          			}
   2444          #endif
   2445          			fp->dsect = sect;
   \                     ??f_read_5:
   \   00000044   0xF8C5 0x9018      STR      R9,[R5, #+24]
   2446          		}
   2447          		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   \                     ??f_read_6:
   \   00000048   0xF44F 0x7000      MOV      R0,#+512
   \   0000004C   0x68A9             LDR      R1,[R5, #+8]
   \   0000004E   0xF44F 0x7200      MOV      R2,#+512
   \   00000052   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   00000056   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   0000005A   0xEBB0 0x0803      SUBS     R8,R0,R3
   2448          		if (rcnt > btr) rcnt = btr;
   \   0000005E   0x4546             CMP      R6,R8
   \   00000060   0xD200             BCS.N    ??f_read_7
   \   00000062   0x46B0             MOV      R8,R6
   2449          #if _FS_TINY
   2450          		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
   2451          			ABORT(fp->fs, FR_DISK_ERR);
   2452          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   2453          #else
   2454          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_7:
   \   00000064   0x4642             MOV      R2,R8
   \   00000066   0x68A8             LDR      R0,[R5, #+8]
   \   00000068   0xF44F 0x7100      MOV      R1,#+512
   \   0000006C   0xFBB0 0xF3F1      UDIV     R3,R0,R1
   \   00000070   0xFB03 0x0311      MLS      R3,R3,R1,R0
   \   00000074   0x1958             ADDS     R0,R3,R5
   \   00000076   0xF110 0x0128      ADDS     R1,R0,#+40
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_8:
   \   00000080   0xEB18 0x0404      ADDS     R4,R8,R4
   \   00000084   0x68A8             LDR      R0,[R5, #+8]
   \   00000086   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000008A   0x60A8             STR      R0,[R5, #+8]
   \   0000008C   0x6838             LDR      R0,[R7, #+0]
   \   0000008E   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000092   0x6038             STR      R0,[R7, #+0]
   \   00000094   0xEBB6 0x0608      SUBS     R6,R6,R8
   \                     ??f_read_4:
   \   00000098   0x2E00             CMP      R6,#+0
   \   0000009A   0xF000 0x80AF      BEQ.W    ??f_read_9
   \   0000009E   0x68A8             LDR      R0,[R5, #+8]
   \   000000A0   0xF44F 0x7100      MOV      R1,#+512
   \   000000A4   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000A8   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000AC   0x2A00             CMP      R2,#+0
   \   000000AE   0xD1CB             BNE.N    ??f_read_6
   \   000000B0   0x68A8             LDR      R0,[R5, #+8]
   \   000000B2   0x0A40             LSRS     R0,R0,#+9
   \   000000B4   0x6829             LDR      R1,[R5, #+0]
   \   000000B6   0x7889             LDRB     R1,[R1, #+2]
   \   000000B8   0x1E49             SUBS     R1,R1,#+1
   \   000000BA   0xEA11 0x0800      ANDS     R8,R1,R0
   \   000000BE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C6   0xD122             BNE.N    ??f_read_10
   \   000000C8   0x68A8             LDR      R0,[R5, #+8]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD101             BNE.N    ??f_read_11
   \   000000CE   0x6928             LDR      R0,[R5, #+16]
   \   000000D0   0xE00B             B.N      ??f_read_12
   \                     ??f_read_11:
   \   000000D2   0x6A68             LDR      R0,[R5, #+36]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD004             BEQ.N    ??f_read_13
   \   000000D8   0x68A9             LDR      R1,[R5, #+8]
   \   000000DA   0x0028             MOVS     R0,R5
   \   000000DC   0x.... 0x....      BL       clmt_clust
   \   000000E0   0xE003             B.N      ??f_read_12
   \                     ??f_read_13:
   \   000000E2   0x6969             LDR      R1,[R5, #+20]
   \   000000E4   0x6828             LDR      R0,[R5, #+0]
   \   000000E6   0x.... 0x....      BL       get_fat
   \                     ??f_read_12:
   \   000000EA   0x2802             CMP      R0,#+2
   \   000000EC   0xD205             BCS.N    ??f_read_14
   \   000000EE   0x79A8             LDRB     R0,[R5, #+6]
   \   000000F0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000F4   0x71A8             STRB     R0,[R5, #+6]
   \   000000F6   0x2002             MOVS     R0,#+2
   \   000000F8   0xE081             B.N      ??f_read_1
   \                     ??f_read_14:
   \   000000FA   0xF110 0x0F01      CMN      R0,#+1
   \   000000FE   0xD105             BNE.N    ??f_read_15
   \   00000100   0x79A8             LDRB     R0,[R5, #+6]
   \   00000102   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000106   0x71A8             STRB     R0,[R5, #+6]
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0xE078             B.N      ??f_read_1
   \                     ??f_read_15:
   \   0000010C   0x6168             STR      R0,[R5, #+20]
   \                     ??f_read_10:
   \   0000010E   0x6969             LDR      R1,[R5, #+20]
   \   00000110   0x6828             LDR      R0,[R5, #+0]
   \   00000112   0x.... 0x....      BL       clust2sect
   \   00000116   0x4681             MOV      R9,R0
   \   00000118   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000011C   0xD105             BNE.N    ??f_read_16
   \   0000011E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000120   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000124   0x71A8             STRB     R0,[R5, #+6]
   \   00000126   0x2002             MOVS     R0,#+2
   \   00000128   0xE069             B.N      ??f_read_1
   \                     ??f_read_16:
   \   0000012A   0xFA59 0xF988      UXTAB    R9,R9,R8
   \   0000012E   0xEA5F 0x2A56      LSRS     R10,R6,#+9
   \   00000132   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000136   0xD035             BEQ.N    ??f_read_17
   \   00000138   0x6828             LDR      R0,[R5, #+0]
   \   0000013A   0x7880             LDRB     R0,[R0, #+2]
   \   0000013C   0xFA5A 0xF188      UXTAB    R1,R10,R8
   \   00000140   0x4288             CMP      R0,R1
   \   00000142   0xD205             BCS.N    ??f_read_18
   \   00000144   0x6828             LDR      R0,[R5, #+0]
   \   00000146   0x7880             LDRB     R0,[R0, #+2]
   \   00000148   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000014C   0xEBB0 0x0A08      SUBS     R10,R0,R8
   \                     ??f_read_18:
   \   00000150   0x4653             MOV      R3,R10
   \   00000152   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000154   0x464A             MOV      R2,R9
   \   00000156   0x0021             MOVS     R1,R4
   \   00000158   0x6828             LDR      R0,[R5, #+0]
   \   0000015A   0x7840             LDRB     R0,[R0, #+1]
   \   0000015C   0x.... 0x....      BL       disk_read
   \   00000160   0x2800             CMP      R0,#+0
   \   00000162   0xD005             BEQ.N    ??f_read_19
   \   00000164   0x79A8             LDRB     R0,[R5, #+6]
   \   00000166   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000016A   0x71A8             STRB     R0,[R5, #+6]
   \   0000016C   0x2001             MOVS     R0,#+1
   \   0000016E   0xE046             B.N      ??f_read_1
   \                     ??f_read_19:
   \   00000170   0x79A8             LDRB     R0,[R5, #+6]
   \   00000172   0x0640             LSLS     R0,R0,#+25
   \   00000174   0xD511             BPL.N    ??f_read_20
   \   00000176   0x69A8             LDR      R0,[R5, #+24]
   \   00000178   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   0000017C   0x4550             CMP      R0,R10
   \   0000017E   0xD20C             BCS.N    ??f_read_20
   \   00000180   0xF44F 0x7200      MOV      R2,#+512
   \   00000184   0xF115 0x0128      ADDS     R1,R5,#+40
   \   00000188   0x69A8             LDR      R0,[R5, #+24]
   \   0000018A   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   0000018E   0xF44F 0x7300      MOV      R3,#+512
   \   00000192   0xFB03 0x4000      MLA      R0,R3,R0,R4
   \   00000196   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_20:
   \   0000019A   0xF44F 0x7000      MOV      R0,#+512
   \   0000019E   0xFB00 0xF80A      MUL      R8,R0,R10
   \   000001A2   0xE76D             B.N      ??f_read_8
   \                     ??f_read_17:
   \   000001A4   0x69A8             LDR      R0,[R5, #+24]
   \   000001A6   0x4548             CMP      R0,R9
   \   000001A8   0xF43F 0xAF4C      BEQ.W    ??f_read_5
   \   000001AC   0x79A8             LDRB     R0,[R5, #+6]
   \   000001AE   0x0640             LSLS     R0,R0,#+25
   \   000001B0   0xD513             BPL.N    ??f_read_21
   \   000001B2   0x2301             MOVS     R3,#+1
   \   000001B4   0x69AA             LDR      R2,[R5, #+24]
   \   000001B6   0xF115 0x0128      ADDS     R1,R5,#+40
   \   000001BA   0x6828             LDR      R0,[R5, #+0]
   \   000001BC   0x7840             LDRB     R0,[R0, #+1]
   \   000001BE   0x.... 0x....      BL       disk_write
   \   000001C2   0x2800             CMP      R0,#+0
   \   000001C4   0xD005             BEQ.N    ??f_read_22
   \   000001C6   0x79A8             LDRB     R0,[R5, #+6]
   \   000001C8   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001CC   0x71A8             STRB     R0,[R5, #+6]
   \   000001CE   0x2001             MOVS     R0,#+1
   \   000001D0   0xE015             B.N      ??f_read_1
   \                     ??f_read_22:
   \   000001D2   0x79A8             LDRB     R0,[R5, #+6]
   \   000001D4   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000001D8   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_read_21:
   \   000001DA   0x2301             MOVS     R3,#+1
   \   000001DC   0x464A             MOV      R2,R9
   \   000001DE   0xF115 0x0128      ADDS     R1,R5,#+40
   \   000001E2   0x6828             LDR      R0,[R5, #+0]
   \   000001E4   0x7840             LDRB     R0,[R0, #+1]
   \   000001E6   0x.... 0x....      BL       disk_read
   \   000001EA   0x2800             CMP      R0,#+0
   \   000001EC   0xF43F 0xAF2A      BEQ.W    ??f_read_5
   \   000001F0   0x79A8             LDRB     R0,[R5, #+6]
   \   000001F2   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001F6   0x71A8             STRB     R0,[R5, #+6]
   \   000001F8   0x2001             MOVS     R0,#+1
   \   000001FA   0xE000             B.N      ??f_read_1
   2455          #endif
   2456          	}
   2457          
   2458          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_9:
   \   000001FC   0x2000             MOVS     R0,#+0
   \                     ??f_read_1:
   \   000001FE   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2459          }
   2460          
   2461          
   2462          
   2463          
   2464          #if !_FS_READONLY
   2465          /*-----------------------------------------------------------------------*/
   2466          /* Write File                                                            */
   2467          /*-----------------------------------------------------------------------*/
   2468          

   \                                 In section .text, align 2, keep-with-next
   2469          FRESULT f_write (
   2470          	FIL *fp,			/* Pointer to the file object */
   2471          	const void *buff,	/* Pointer to the data to be written */
   2472          	UINT btw,			/* Number of bytes to write */
   2473          	UINT *bw			/* Pointer to number of bytes written */
   2474          )
   2475          {
   \                     f_write:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
   2476          	FRESULT res;
   2477          	DWORD clst, sect;
   2478          	UINT wcnt, cc;
   2479          	const BYTE *wbuff = buff;
   \   0000000A   0x000C             MOVS     R4,R1
   2480          	BYTE csect;
   2481          
   2482          
   2483          	*bw = 0;	/* Initialize byte counter */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6038             STR      R0,[R7, #+0]
   2484          
   2485          	res = validate(fp->fs, fp->id);			/* Check validity */
   \   00000010   0x88A9             LDRH     R1,[R5, #+4]
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x.... 0x....      BL       validate
   2486          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??f_write_0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xE07A             B.N      ??f_write_1
   2487          	if (fp->flag & FA__ERROR)				/* Aborted file? */
   \                     ??f_write_0:
   \   00000022   0x79A8             LDRB     R0,[R5, #+6]
   \   00000024   0x0600             LSLS     R0,R0,#+24
   \   00000026   0xD501             BPL.N    ??f_write_2
   2488          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xE075             B.N      ??f_write_1
   2489          	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   \                     ??f_write_2:
   \   0000002C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD401             BMI.N    ??f_write_3
   2490          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00000032   0x2007             MOVS     R0,#+7
   \   00000034   0xE070             B.N      ??f_write_1
   2491          	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
   \                     ??f_write_3:
   \   00000036   0x68E8             LDR      R0,[R5, #+12]
   \   00000038   0x1830             ADDS     R0,R6,R0
   \   0000003A   0x68E9             LDR      R1,[R5, #+12]
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD22F             BCS.N    ??f_write_4
   \   00000040   0x2600             MOVS     R6,#+0
   \   00000042   0xE02D             B.N      ??f_write_4
   2492          
   2493          	for ( ;  btw;							/* Repeat until all data written */
   2494          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   2495          		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   2496          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2497          			if (!csect) {					/* On the cluster boundary? */
   2498          				if (fp->fptr == 0) {		/* On the top of the file? */
   2499          					clst = fp->sclust;		/* Follow from the origin */
   2500          					if (clst == 0)			/* When no cluster is allocated, */
   2501          						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   2502          				} else {					/* Middle or end of the file */
   2503          #if _USE_FASTSEEK
   2504          					if (fp->cltbl)
   2505          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2506          					else
   2507          #endif
   2508          						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   2509          				}
   2510          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   2511          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   2512          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2513          				fp->clust = clst;			/* Update current cluster */
   2514          			}
   2515          #if _FS_TINY
   2516          			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
   2517          				ABORT(fp->fs, FR_DISK_ERR);
   2518          #else
   2519          			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   2520          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2521          					ABORT(fp->fs, FR_DISK_ERR);
   2522          				fp->flag &= ~FA__DIRTY;
   2523          			}
   2524          #endif
   2525          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2526          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2527          			sect += csect;
   2528          			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   2529          			if (cc) {						/* Write maximum contiguous sectors directly */
   2530          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2531          					cc = fp->fs->csize - csect;
   2532          				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
   2533          					ABORT(fp->fs, FR_DISK_ERR);
   2534          #if _FS_TINY
   2535          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   2536          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   2537          					fp->fs->wflag = 0;
   2538          				}
   2539          #else
   2540          				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   2541          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   2542          					fp->flag &= ~FA__DIRTY;
   2543          				}
   2544          #endif
   2545          				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   2546          				continue;
   2547          			}
   2548          #if _FS_TINY
   2549          			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   2550          				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
   2551          				fp->fs->winsect = sect;
   2552          			}
   2553          #else
   2554          			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   2555          				if (fp->fptr < fp->fsize &&
   2556          					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   2557          						ABORT(fp->fs, FR_DISK_ERR);
   2558          			}
   2559          #endif
   2560          			fp->dsect = sect;
   \                     ??f_write_5:
   \   00000044   0xF8C5 0x9018      STR      R9,[R5, #+24]
   2561          		}
   2562          		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   \                     ??f_write_6:
   \   00000048   0xF44F 0x7000      MOV      R0,#+512
   \   0000004C   0x68A9             LDR      R1,[R5, #+8]
   \   0000004E   0xF44F 0x7200      MOV      R2,#+512
   \   00000052   0xFBB1 0xF3F2      UDIV     R3,R1,R2
   \   00000056   0xFB03 0x1312      MLS      R3,R3,R2,R1
   \   0000005A   0xEBB0 0x0803      SUBS     R8,R0,R3
   2563          		if (wcnt > btw) wcnt = btw;
   \   0000005E   0x4546             CMP      R6,R8
   \   00000060   0xD200             BCS.N    ??f_write_7
   \   00000062   0x46B0             MOV      R8,R6
   2564          #if _FS_TINY
   2565          		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
   2566          			ABORT(fp->fs, FR_DISK_ERR);
   2567          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2568          		fp->fs->wflag = 1;
   2569          #else
   2570          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   \                     ??f_write_7:
   \   00000064   0x4642             MOV      R2,R8
   \   00000066   0x0021             MOVS     R1,R4
   \   00000068   0x68A8             LDR      R0,[R5, #+8]
   \   0000006A   0xF44F 0x7300      MOV      R3,#+512
   \   0000006E   0xFBB0 0xFCF3      UDIV     R12,R0,R3
   \   00000072   0xFB0C 0x0C13      MLS      R12,R12,R3,R0
   \   00000076   0xEB1C 0x0005      ADDS     R0,R12,R5
   \   0000007A   0x3028             ADDS     R0,R0,#+40
   \   0000007C   0x.... 0x....      BL       mem_cpy
   2571          		fp->flag |= FA__DIRTY;
   \   00000080   0x79A8             LDRB     R0,[R5, #+6]
   \   00000082   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000086   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_8:
   \   00000088   0xEB18 0x0404      ADDS     R4,R8,R4
   \   0000008C   0x68A8             LDR      R0,[R5, #+8]
   \   0000008E   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000092   0x60A8             STR      R0,[R5, #+8]
   \   00000094   0x6838             LDR      R0,[R7, #+0]
   \   00000096   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000009A   0x6038             STR      R0,[R7, #+0]
   \   0000009C   0xEBB6 0x0608      SUBS     R6,R6,R8
   \                     ??f_write_4:
   \   000000A0   0x2E00             CMP      R6,#+0
   \   000000A2   0xD02E             BEQ.N    ??f_write_9
   \   000000A4   0x68A8             LDR      R0,[R5, #+8]
   \   000000A6   0xF44F 0x7100      MOV      R1,#+512
   \   000000AA   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   000000AE   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   000000B2   0x2A00             CMP      R2,#+0
   \   000000B4   0xD1C8             BNE.N    ??f_write_6
   \   000000B6   0x68A8             LDR      R0,[R5, #+8]
   \   000000B8   0x0A40             LSRS     R0,R0,#+9
   \   000000BA   0x6829             LDR      R1,[R5, #+0]
   \   000000BC   0x7889             LDRB     R1,[R1, #+2]
   \   000000BE   0x1E49             SUBS     R1,R1,#+1
   \   000000C0   0xEA11 0x0800      ANDS     R8,R1,R0
   \   000000C4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000CC   0xD138             BNE.N    ??f_write_10
   \   000000CE   0x68A8             LDR      R0,[R5, #+8]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD108             BNE.N    ??f_write_11
   \   000000D4   0x6928             LDR      R0,[R5, #+16]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD111             BNE.N    ??f_write_12
   \   000000DA   0x2100             MOVS     R1,#+0
   \   000000DC   0x6828             LDR      R0,[R5, #+0]
   \   000000DE   0x.... 0x....      BL       create_chain
   \   000000E2   0x6128             STR      R0,[R5, #+16]
   \   000000E4   0xE00B             B.N      ??f_write_12
   \                     ??f_write_11:
   \   000000E6   0x6A68             LDR      R0,[R5, #+36]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD004             BEQ.N    ??f_write_13
   \   000000EC   0x68A9             LDR      R1,[R5, #+8]
   \   000000EE   0x0028             MOVS     R0,R5
   \   000000F0   0x.... 0x....      BL       clmt_clust
   \   000000F4   0xE003             B.N      ??f_write_12
   \                     ??f_write_13:
   \   000000F6   0x6969             LDR      R1,[R5, #+20]
   \   000000F8   0x6828             LDR      R0,[R5, #+0]
   \   000000FA   0x.... 0x....      BL       create_chain
   \                     ??f_write_12:
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD10C             BNE.N    ??f_write_14
   2572          #endif
   2573          	}
   2574          
   2575          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_9:
   \   00000102   0x68E8             LDR      R0,[R5, #+12]
   \   00000104   0x68A9             LDR      R1,[R5, #+8]
   \   00000106   0x4288             CMP      R0,R1
   \   00000108   0xD201             BCS.N    ??f_write_15
   \   0000010A   0x68A8             LDR      R0,[R5, #+8]
   \   0000010C   0x60E8             STR      R0,[R5, #+12]
   2576          	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   \                     ??f_write_15:
   \   0000010E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000110   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000114   0x71A8             STRB     R0,[R5, #+6]
   2577          
   2578          	LEAVE_FF(fp->fs, FR_OK);
   \   00000116   0x2000             MOVS     R0,#+0
   \                     ??f_write_1:
   \   00000118   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??f_write_14:
   \   0000011C   0x2801             CMP      R0,#+1
   \   0000011E   0xD105             BNE.N    ??f_write_16
   \   00000120   0x79A8             LDRB     R0,[R5, #+6]
   \   00000122   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000126   0x71A8             STRB     R0,[R5, #+6]
   \   00000128   0x2002             MOVS     R0,#+2
   \   0000012A   0xE7F5             B.N      ??f_write_1
   \                     ??f_write_16:
   \   0000012C   0xF110 0x0F01      CMN      R0,#+1
   \   00000130   0xD105             BNE.N    ??f_write_17
   \   00000132   0x79A8             LDRB     R0,[R5, #+6]
   \   00000134   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000138   0x71A8             STRB     R0,[R5, #+6]
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xE7EC             B.N      ??f_write_1
   \                     ??f_write_17:
   \   0000013E   0x6168             STR      R0,[R5, #+20]
   \                     ??f_write_10:
   \   00000140   0x79A8             LDRB     R0,[R5, #+6]
   \   00000142   0x0640             LSLS     R0,R0,#+25
   \   00000144   0xD513             BPL.N    ??f_write_18
   \   00000146   0x2301             MOVS     R3,#+1
   \   00000148   0x69AA             LDR      R2,[R5, #+24]
   \   0000014A   0xF115 0x0128      ADDS     R1,R5,#+40
   \   0000014E   0x6828             LDR      R0,[R5, #+0]
   \   00000150   0x7840             LDRB     R0,[R0, #+1]
   \   00000152   0x.... 0x....      BL       disk_write
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xD005             BEQ.N    ??f_write_19
   \   0000015A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000015C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000160   0x71A8             STRB     R0,[R5, #+6]
   \   00000162   0x2001             MOVS     R0,#+1
   \   00000164   0xE7D8             B.N      ??f_write_1
   \                     ??f_write_19:
   \   00000166   0x79A8             LDRB     R0,[R5, #+6]
   \   00000168   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000016C   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_18:
   \   0000016E   0x6969             LDR      R1,[R5, #+20]
   \   00000170   0x6828             LDR      R0,[R5, #+0]
   \   00000172   0x.... 0x....      BL       clust2sect
   \   00000176   0x4681             MOV      R9,R0
   \   00000178   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000017C   0xD105             BNE.N    ??f_write_20
   \   0000017E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000180   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000184   0x71A8             STRB     R0,[R5, #+6]
   \   00000186   0x2002             MOVS     R0,#+2
   \   00000188   0xE7C6             B.N      ??f_write_1
   \                     ??f_write_20:
   \   0000018A   0xFA59 0xF988      UXTAB    R9,R9,R8
   \   0000018E   0xEA5F 0x2A56      LSRS     R10,R6,#+9
   \   00000192   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000196   0xD036             BEQ.N    ??f_write_21
   \   00000198   0x6828             LDR      R0,[R5, #+0]
   \   0000019A   0x7880             LDRB     R0,[R0, #+2]
   \   0000019C   0xFA5A 0xF188      UXTAB    R1,R10,R8
   \   000001A0   0x4288             CMP      R0,R1
   \   000001A2   0xD205             BCS.N    ??f_write_22
   \   000001A4   0x6828             LDR      R0,[R5, #+0]
   \   000001A6   0x7880             LDRB     R0,[R0, #+2]
   \   000001A8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001AC   0xEBB0 0x0A08      SUBS     R10,R0,R8
   \                     ??f_write_22:
   \   000001B0   0x4653             MOV      R3,R10
   \   000001B2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001B4   0x464A             MOV      R2,R9
   \   000001B6   0x0021             MOVS     R1,R4
   \   000001B8   0x6828             LDR      R0,[R5, #+0]
   \   000001BA   0x7840             LDRB     R0,[R0, #+1]
   \   000001BC   0x.... 0x....      BL       disk_write
   \   000001C0   0x2800             CMP      R0,#+0
   \   000001C2   0xD005             BEQ.N    ??f_write_23
   \   000001C4   0x79A8             LDRB     R0,[R5, #+6]
   \   000001C6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001CA   0x71A8             STRB     R0,[R5, #+6]
   \   000001CC   0x2001             MOVS     R0,#+1
   \   000001CE   0xE7A3             B.N      ??f_write_1
   \                     ??f_write_23:
   \   000001D0   0x69A8             LDR      R0,[R5, #+24]
   \   000001D2   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000001D6   0x4550             CMP      R0,R10
   \   000001D8   0xD210             BCS.N    ??f_write_24
   \   000001DA   0xF44F 0x7200      MOV      R2,#+512
   \   000001DE   0x69A8             LDR      R0,[R5, #+24]
   \   000001E0   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000001E4   0xF44F 0x7100      MOV      R1,#+512
   \   000001E8   0xFB01 0x4100      MLA      R1,R1,R0,R4
   \   000001EC   0xF115 0x0028      ADDS     R0,R5,#+40
   \   000001F0   0x.... 0x....      BL       mem_cpy
   \   000001F4   0x79A8             LDRB     R0,[R5, #+6]
   \   000001F6   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000001FA   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_24:
   \   000001FC   0xF44F 0x7000      MOV      R0,#+512
   \   00000200   0xFB00 0xF80A      MUL      R8,R0,R10
   \   00000204   0xE740             B.N      ??f_write_8
   \                     ??f_write_21:
   \   00000206   0x69A8             LDR      R0,[R5, #+24]
   \   00000208   0x4548             CMP      R0,R9
   \   0000020A   0xF43F 0xAF1B      BEQ.W    ??f_write_5
   \   0000020E   0x68A8             LDR      R0,[R5, #+8]
   \   00000210   0x68E9             LDR      R1,[R5, #+12]
   \   00000212   0x4288             CMP      R0,R1
   \   00000214   0xF4BF 0xAF16      BCS.W    ??f_write_5
   \   00000218   0x2301             MOVS     R3,#+1
   \   0000021A   0x464A             MOV      R2,R9
   \   0000021C   0xF115 0x0128      ADDS     R1,R5,#+40
   \   00000220   0x6828             LDR      R0,[R5, #+0]
   \   00000222   0x7840             LDRB     R0,[R0, #+1]
   \   00000224   0x.... 0x....      BL       disk_read
   \   00000228   0x2800             CMP      R0,#+0
   \   0000022A   0xF43F 0xAF0B      BEQ.W    ??f_write_5
   \   0000022E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000230   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000234   0x71A8             STRB     R0,[R5, #+6]
   \   00000236   0x2001             MOVS     R0,#+1
   \   00000238   0xE76E             B.N      ??f_write_1
   2579          }
   2580          
   2581          
   2582          
   2583          
   2584          /*-----------------------------------------------------------------------*/
   2585          /* Synchronize the File Object                                           */
   2586          /*-----------------------------------------------------------------------*/
   2587          

   \                                 In section .text, align 2, keep-with-next
   2588          FRESULT f_sync (
   2589          	FIL *fp		/* Pointer to the file object */
   2590          )
   2591          {
   \                     f_sync:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2592          	FRESULT res;
   2593          	DWORD tim;
   2594          	BYTE *dir;
   2595          
   2596          
   2597          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   \   00000004   0x88A1             LDRH     R1,[R4, #+4]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       validate
   2598          	if (res == FR_OK) {
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD150             BNE.N    ??f_sync_0
   2599          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   \   00000012   0x79A1             LDRB     R1,[R4, #+6]
   \   00000014   0x0689             LSLS     R1,R1,#+26
   \   00000016   0xD54D             BPL.N    ??f_sync_0
   2600          #if !_FS_TINY	/* Write-back dirty buffer */
   2601          			if (fp->flag & FA__DIRTY) {
   \   00000018   0x79A0             LDRB     R0,[R4, #+6]
   \   0000001A   0x0640             LSLS     R0,R0,#+25
   \   0000001C   0xD50F             BPL.N    ??f_sync_1
   2602          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0000001E   0x2301             MOVS     R3,#+1
   \   00000020   0x69A2             LDR      R2,[R4, #+24]
   \   00000022   0xF114 0x0128      ADDS     R1,R4,#+40
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x7840             LDRB     R0,[R0, #+1]
   \   0000002A   0x.... 0x....      BL       disk_write
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??f_sync_2
   2603          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE03F             B.N      ??f_sync_3
   2604          				fp->flag &= ~FA__DIRTY;
   \                     ??f_sync_2:
   \   00000036   0x79A0             LDRB     R0,[R4, #+6]
   \   00000038   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   0000003C   0x71A0             STRB     R0,[R4, #+6]
   2605          			}
   2606          #endif
   2607          			/* Update the directory entry */
   2608          			res = move_window(fp->fs, fp->dir_sect);
   \                     ??f_sync_1:
   \   0000003E   0x69E1             LDR      R1,[R4, #+28]
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       move_window
   2609          			if (res == FR_OK) {
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD133             BNE.N    ??f_sync_0
   2610          				dir = fp->dir_ptr;
   \   0000004C   0x6A25             LDR      R5,[R4, #+32]
   2611          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   0000004E   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000050   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000054   0x72E8             STRB     R0,[R5, #+11]
   2612          				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   \   00000056   0x68E0             LDR      R0,[R4, #+12]
   \   00000058   0x7728             STRB     R0,[R5, #+28]
   \   0000005A   0x68E0             LDR      R0,[R4, #+12]
   \   0000005C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005E   0x0A00             LSRS     R0,R0,#+8
   \   00000060   0x7768             STRB     R0,[R5, #+29]
   \   00000062   0x68E0             LDR      R0,[R4, #+12]
   \   00000064   0x0C00             LSRS     R0,R0,#+16
   \   00000066   0x77A8             STRB     R0,[R5, #+30]
   \   00000068   0x68E0             LDR      R0,[R4, #+12]
   \   0000006A   0x0E00             LSRS     R0,R0,#+24
   \   0000006C   0x77E8             STRB     R0,[R5, #+31]
   2613          				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0x76A8             STRB     R0,[R5, #+26]
   \   00000072   0x6920             LDR      R0,[R4, #+16]
   \   00000074   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000076   0x0A00             LSRS     R0,R0,#+8
   \   00000078   0x76E8             STRB     R0,[R5, #+27]
   \   0000007A   0x6920             LDR      R0,[R4, #+16]
   \   0000007C   0x0C00             LSRS     R0,R0,#+16
   \   0000007E   0x7528             STRB     R0,[R5, #+20]
   \   00000080   0x6920             LDR      R0,[R4, #+16]
   \   00000082   0x0C00             LSRS     R0,R0,#+16
   \   00000084   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000086   0x0A00             LSRS     R0,R0,#+8
   \   00000088   0x7568             STRB     R0,[R5, #+21]
   2614          				tim = get_fattime();						/* Update updated time */
   \   0000008A   0x.... 0x....      BL       get_fattime
   2615          				ST_DWORD(dir+DIR_WrtTime, tim);
   \   0000008E   0x75A8             STRB     R0,[R5, #+22]
   \   00000090   0x0001             MOVS     R1,R0
   \   00000092   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000094   0x0A09             LSRS     R1,R1,#+8
   \   00000096   0x75E9             STRB     R1,[R5, #+23]
   \   00000098   0x0C01             LSRS     R1,R0,#+16
   \   0000009A   0x7629             STRB     R1,[R5, #+24]
   \   0000009C   0x0E00             LSRS     R0,R0,#+24
   \   0000009E   0x7668             STRB     R0,[R5, #+25]
   2616          				fp->flag &= ~FA__WRITTEN;
   \   000000A0   0x79A0             LDRB     R0,[R4, #+6]
   \   000000A2   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   000000A6   0x71A0             STRB     R0,[R4, #+6]
   2617          				fp->fs->wflag = 1;
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x2101             MOVS     R1,#+1
   \   000000AC   0x7101             STRB     R1,[R0, #+4]
   2618          				res = sync(fp->fs);
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x.... 0x....      BL       sync
   2619          			}
   2620          		}
   2621          	}
   2622          
   2623          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0:
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_sync_3:
   \   000000B6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2624          }
   2625          
   2626          #endif /* !_FS_READONLY */
   2627          
   2628          
   2629          
   2630          
   2631          /*-----------------------------------------------------------------------*/
   2632          /* Close File                                                            */
   2633          /*-----------------------------------------------------------------------*/
   2634          

   \                                 In section .text, align 2, keep-with-next
   2635          FRESULT f_close (
   2636          	FIL *fp		/* Pointer to the file object to be closed */
   2637          )
   2638          {
   \                     f_close:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2639          	FRESULT res;
   2640          
   2641          #if _FS_READONLY
   2642          	FATFS *fs = fp->fs;
   2643          	res = validate(fs, fp->id);
   2644          	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   2645          	LEAVE_FF(fs, res);
   2646          
   2647          #else
   2648          	res = f_sync(fp);		/* Flush cached data */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       f_sync
   2649          #if _FS_SHARE
   2650          	if (res == FR_OK) {		/* Decrement open counter */
   2651          #if _FS_REENTRANT
   2652          		res = validate(fp->fs, fp->id);
   2653          		if (res == FR_OK) {
   2654          			res = dec_lock(fp->lockid);	
   2655          			unlock_fs(fp->fs, FR_OK);
   2656          		}
   2657          #else
   2658          		res = dec_lock(fp->lockid);
   2659          #endif
   2660          	}
   2661          #endif
   2662          	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE.N    ??f_close_0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6021             STR      R1,[R4, #+0]
   2663          	return res;
   \                     ??f_close_0:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   2664          #endif
   2665          }
   2666          
   2667          
   2668          
   2669          
   2670          /*-----------------------------------------------------------------------*/
   2671          /* Current Drive/Directory Handlings                                     */
   2672          /*-----------------------------------------------------------------------*/
   2673          
   2674          #if _FS_RPATH >= 1
   2675          

   \                                 In section .text, align 2, keep-with-next
   2676          FRESULT f_chdrive (
   2677          	BYTE drv		/* Drive number */
   2678          )
   2679          {
   2680          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   \                     f_chdrive:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD301             BCC.N    ??f_chdrive_0
   \   00000006   0x200B             MOVS     R0,#+11
   \   00000008   0xE002             B.N      ??f_chdrive_1
   2681          
   2682          	CurrVol = drv;
   \                     ??f_chdrive_0:
   \   0000000A   0x....             LDR.N    R1,??DataTable9_3
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
   2683          
   2684          	return FR_OK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??f_chdrive_1:
   \   00000010   0x4770             BX       LR               ;; return
   2685          }
   2686          
   2687          
   2688          

   \                                 In section .text, align 2, keep-with-next
   2689          FRESULT f_chdir (
   2690          	const TCHAR *path	/* Pointer to the directory path */
   2691          )
   2692          {
   \                     f_chdir:
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   2693          	FRESULT res;
   2694          	DIR dj;
   2695          	DEF_NAMEBUF;
   2696          
   2697          
   2698          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0xA80C             ADD      R0,SP,#+48
   \   0000000A   0x.... 0x....      BL       chk_mounted
   2699          	if (res == FR_OK) {
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD12E             BNE.N    ??f_chdir_0
   2700          		INIT_BUF(dj);
   \   00000014   0xA809             ADD      R0,SP,#+36
   \   00000016   0x9006             STR      R0,[SP, #+24]
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \   0000001C   0x9007             STR      R0,[SP, #+28]
   2701          		res = follow_path(&dj, path);		/* Follow the path */
   \   0000001E   0x990C             LDR      R1,[SP, #+48]
   \   00000020   0xA800             ADD      R0,SP,#+0
   \   00000022   0x.... 0x....      BL       follow_path
   2702          		FREE_BUF();
   2703          		if (res == FR_OK) {					/* Follow completed */
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD11E             BNE.N    ??f_chdir_1
   2704          			if (!dj.dir) {
   \   0000002C   0x9905             LDR      R1,[SP, #+20]
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD103             BNE.N    ??f_chdir_2
   2705          				dj.fs->cdir = dj.sclust;	/* Start directory itself */
   \   00000032   0x9900             LDR      R1,[SP, #+0]
   \   00000034   0x9A02             LDR      R2,[SP, #+8]
   \   00000036   0x618A             STR      R2,[R1, #+24]
   \   00000038   0xE017             B.N      ??f_chdir_1
   2706          			} else {
   2707          				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
   \                     ??f_chdir_2:
   \   0000003A   0x9905             LDR      R1,[SP, #+20]
   \   0000003C   0x7AC9             LDRB     R1,[R1, #+11]
   \   0000003E   0x06C9             LSLS     R1,R1,#+27
   \   00000040   0xD512             BPL.N    ??f_chdir_3
   2708          					dj.fs->cdir = LD_CLUST(dj.dir);
   \   00000042   0x9905             LDR      R1,[SP, #+20]
   \   00000044   0x7D49             LDRB     R1,[R1, #+21]
   \   00000046   0x9A05             LDR      R2,[SP, #+20]
   \   00000048   0x7D12             LDRB     R2,[R2, #+20]
   \   0000004A   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000004E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000050   0x9A05             LDR      R2,[SP, #+20]
   \   00000052   0x7ED2             LDRB     R2,[R2, #+27]
   \   00000054   0x9B05             LDR      R3,[SP, #+20]
   \   00000056   0x7E9B             LDRB     R3,[R3, #+26]
   \   00000058   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   \   0000005C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000005E   0xEA52 0x4101      ORRS     R1,R2,R1, LSL #+16
   \   00000062   0x9A00             LDR      R2,[SP, #+0]
   \   00000064   0x6191             STR      R1,[R2, #+24]
   \   00000066   0xE000             B.N      ??f_chdir_1
   2709          				else
   2710          					res = FR_NO_PATH;		/* Reached but a file */
   \                     ??f_chdir_3:
   \   00000068   0x2005             MOVS     R0,#+5
   2711          			}
   2712          		}
   2713          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_chdir_1:
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xD100             BNE.N    ??f_chdir_0
   \   00000070   0x2005             MOVS     R0,#+5
   2714          	}
   2715          
   2716          	LEAVE_FF(dj.fs, res);
   \                     ??f_chdir_0:
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0xB00D             ADD      SP,SP,#+52
   \   00000076   0xBD00             POP      {PC}             ;; return
   2717          }
   2718          
   2719          
   2720          #if _FS_RPATH >= 2
   2721          FRESULT f_getcwd (
   2722          	TCHAR *path,	/* Pointer to the directory path */
   2723          	UINT sz_path	/* Size of path */
   2724          )
   2725          {
   2726          	FRESULT res;
   2727          	DIR dj;
   2728          	UINT i, n;
   2729          	DWORD ccl;
   2730          	TCHAR *tp;
   2731          	FILINFO fno;
   2732          	DEF_NAMEBUF;
   2733          
   2734          
   2735          	*path = 0;
   2736          	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
   2737          	if (res == FR_OK) {
   2738          		INIT_BUF(dj);
   2739          		i = sz_path;		/* Bottom of buffer (dir stack base) */
   2740          		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
   2741          		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
   2742          			res = dir_sdi(&dj, 1);			/* Get parent dir */
   2743          			if (res != FR_OK) break;
   2744          			res = dir_read(&dj);
   2745          			if (res != FR_OK) break;
   2746          			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
   2747          			res = dir_sdi(&dj, 0);
   2748          			if (res != FR_OK) break;
   2749          			do {							/* Find the entry links to the child dir */
   2750          				res = dir_read(&dj);
   2751          				if (res != FR_OK) break;
   2752          				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
   2753          				res = dir_next(&dj, 0);	
   2754          			} while (res == FR_OK);
   2755          			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   2756          			if (res != FR_OK) break;
   2757          #if _USE_LFN
   2758          			fno.lfname = path;
   2759          			fno.lfsize = i;
   2760          #endif
   2761          			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
   2762          			tp = fno.fname;
   2763          			if (_USE_LFN && *path) tp = path;
   2764          			for (n = 0; tp[n]; n++) ;
   2765          			if (i < n + 3) {
   2766          				res = FR_NOT_ENOUGH_CORE; break;
   2767          			}
   2768          			while (n) path[--i] = tp[--n];
   2769          			path[--i] = '/';
   2770          		}
   2771          		tp = path;
   2772          		if (res == FR_OK) {
   2773          			*tp++ = '0' + CurrVol;			/* Put drive number */
   2774          			*tp++ = ':';
   2775          			if (i == sz_path) {				/* Root-dir */
   2776          				*tp++ = '/';
   2777          			} else {						/* Sub-dir */
   2778          				do		/* Add stacked path str */
   2779          					*tp++ = path[i++];
   2780          				while (i < sz_path);
   2781          			}
   2782          		}
   2783          		*tp = 0;
   2784          		FREE_BUF();
   2785          	}
   2786          
   2787          	LEAVE_FF(dj.fs, res);
   2788          }
   2789          #endif /* _FS_RPATH >= 2 */
   2790          #endif /* _FS_RPATH >= 1 */
   2791          
   2792          
   2793          
   2794          #if _FS_MINIMIZE <= 2
   2795          /*-----------------------------------------------------------------------*/
   2796          /* Seek File R/W Pointer                                                 */
   2797          /*-----------------------------------------------------------------------*/
   2798          

   \                                 In section .text, align 2, keep-with-next
   2799          FRESULT f_lseek (
   2800          	FIL *fp,		/* Pointer to the file object */
   2801          	DWORD ofs		/* File pointer from top of file */
   2802          )
   2803          {
   \                     f_lseek:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   2804          	FRESULT res;
   2805          
   2806          
   2807          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   \   00000008   0x88A9             LDRH     R1,[R5, #+4]
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x.... 0x....      BL       validate
   \   00000010   0x0004             MOVS     R4,R0
   2808          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD002             BEQ.N    ??f_lseek_0
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xE16E             B.N      ??f_lseek_1
   2809          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   \                     ??f_lseek_0:
   \   0000001E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD501             BPL.N    ??f_lseek_2
   2810          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE169             B.N      ??f_lseek_1
   2811          
   2812          #if _USE_FASTSEEK
   2813          	if (fp->cltbl) {	/* Fast seek */
   \                     ??f_lseek_2:
   \   00000028   0x6A68             LDR      R0,[R5, #+36]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF000 0x809E      BEQ.W    ??f_lseek_3
   2814          		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   2815          
   2816          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   \   00000030   0xF116 0x0F01      CMN      R6,#+1
   \   00000034   0xD142             BNE.N    ??f_lseek_4
   2817          			tbl = fp->cltbl;
   \   00000036   0xF8D5 0xA024      LDR      R10,[R5, #+36]
   2818          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   \   0000003A   0xF8DA 0x8000      LDR      R8,[R10, #+0]
   \   0000003E   0xF11A 0x0A04      ADDS     R10,R10,#+4
   \   00000042   0xF05F 0x0902      MOVS     R9,#+2
   2819          			cl = fp->sclust;			/* Top of the chain */
   \   00000046   0x6928             LDR      R0,[R5, #+16]
   2820          			if (cl) {
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD02C             BEQ.N    ??f_lseek_5
   2821          				do {
   2822          					/* Get a fragment */
   2823          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   \                     ??f_lseek_6:
   \   0000004C   0x0007             MOVS     R7,R0
   \   0000004E   0x2600             MOVS     R6,#+0
   \   00000050   0xF119 0x0902      ADDS     R9,R9,#+2
   2824          					do {
   2825          						pcl = cl; ncl++;
   \                     ??f_lseek_7:
   \   00000054   0x4683             MOV      R11,R0
   \   00000056   0x1C76             ADDS     R6,R6,#+1
   2826          						cl = get_fat(fp->fs, cl);
   \   00000058   0x0001             MOVS     R1,R0
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x.... 0x....      BL       get_fat
   2827          						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   \   00000060   0x2802             CMP      R0,#+2
   \   00000062   0xD205             BCS.N    ??f_lseek_8
   \   00000064   0x79A8             LDRB     R0,[R5, #+6]
   \   00000066   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000006A   0x71A8             STRB     R0,[R5, #+6]
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0xE145             B.N      ??f_lseek_1
   2828          						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_8:
   \   00000070   0xF110 0x0F01      CMN      R0,#+1
   \   00000074   0xD105             BNE.N    ??f_lseek_9
   \   00000076   0x79A8             LDRB     R0,[R5, #+6]
   \   00000078   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000007C   0x71A8             STRB     R0,[R5, #+6]
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xE13C             B.N      ??f_lseek_1
   2829          					} while (cl == pcl + 1);
   \                     ??f_lseek_9:
   \   00000082   0xF11B 0x0101      ADDS     R1,R11,#+1
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD0E4             BEQ.N    ??f_lseek_7
   2830          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   \   0000008A   0x45C8             CMP      R8,R9
   \   0000008C   0xD307             BCC.N    ??f_lseek_10
   2831          						*tbl++ = ncl; *tbl++ = tcl;
   \   0000008E   0xF8CA 0x6000      STR      R6,[R10, #+0]
   \   00000092   0xF11A 0x0A04      ADDS     R10,R10,#+4
   \   00000096   0xF8CA 0x7000      STR      R7,[R10, #+0]
   \   0000009A   0xF11A 0x0A04      ADDS     R10,R10,#+4
   2832          					}
   2833          				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
   \                     ??f_lseek_10:
   \   0000009E   0x6829             LDR      R1,[R5, #+0]
   \   000000A0   0x69C9             LDR      R1,[R1, #+28]
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD3D2             BCC.N    ??f_lseek_6
   2834          			}
   2835          			*fp->cltbl = ulen;	/* Number of items used */
   \                     ??f_lseek_5:
   \   000000A6   0x6A68             LDR      R0,[R5, #+36]
   \   000000A8   0xF8C0 0x9000      STR      R9,[R0, #+0]
   2836          			if (ulen <= tlen)
   \   000000AC   0x45C8             CMP      R8,R9
   \   000000AE   0xD303             BCC.N    ??f_lseek_11
   2837          				*tbl = 0;		/* Terminate table */
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   000000B6   0xE11F             B.N      ??f_lseek_12
   2838          			else
   2839          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   \                     ??f_lseek_11:
   \   000000B8   0x2411             MOVS     R4,#+17
   \   000000BA   0xE11D             B.N      ??f_lseek_12
   2840          
   2841          		} else {						/* Fast seek */
   2842          			if (ofs > fp->fsize)		/* Clip offset at the file size */
   \                     ??f_lseek_4:
   \   000000BC   0x68E8             LDR      R0,[R5, #+12]
   \   000000BE   0x42B0             CMP      R0,R6
   \   000000C0   0xD200             BCS.N    ??f_lseek_13
   2843          				ofs = fp->fsize;
   \   000000C2   0x68EE             LDR      R6,[R5, #+12]
   2844          			fp->fptr = ofs;				/* Set file pointer */
   \                     ??f_lseek_13:
   \   000000C4   0x60AE             STR      R6,[R5, #+8]
   2845          			if (ofs) {
   \   000000C6   0x2E00             CMP      R6,#+0
   \   000000C8   0xF000 0x8116      BEQ.W    ??f_lseek_12
   2846          				fp->clust = clmt_clust(fp, ofs - 1);
   \   000000CC   0x1E71             SUBS     R1,R6,#+1
   \   000000CE   0x0028             MOVS     R0,R5
   \   000000D0   0x.... 0x....      BL       clmt_clust
   \   000000D4   0x6168             STR      R0,[R5, #+20]
   2847          				dsc = clust2sect(fp->fs, fp->clust);
   \   000000D6   0x6969             LDR      R1,[R5, #+20]
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x.... 0x....      BL       clust2sect
   \   000000DE   0x0007             MOVS     R7,R0
   2848          				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   \   000000E0   0x2F00             CMP      R7,#+0
   \   000000E2   0xD105             BNE.N    ??f_lseek_14
   \   000000E4   0x79A8             LDRB     R0,[R5, #+6]
   \   000000E6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000EA   0x71A8             STRB     R0,[R5, #+6]
   \   000000EC   0x2002             MOVS     R0,#+2
   \   000000EE   0xE105             B.N      ??f_lseek_1
   2849          				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   \                     ??f_lseek_14:
   \   000000F0   0x1E70             SUBS     R0,R6,#+1
   \   000000F2   0x6829             LDR      R1,[R5, #+0]
   \   000000F4   0x7889             LDRB     R1,[R1, #+2]
   \   000000F6   0x1E49             SUBS     R1,R1,#+1
   \   000000F8   0xEA11 0x2050      ANDS     R0,R1,R0, LSR #+9
   \   000000FC   0x19C7             ADDS     R7,R0,R7
   2850          				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
   \   000000FE   0x68A8             LDR      R0,[R5, #+8]
   \   00000100   0xF44F 0x7100      MOV      R1,#+512
   \   00000104   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000108   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000010C   0x2A00             CMP      R2,#+0
   \   0000010E   0xF000 0x80F3      BEQ.W    ??f_lseek_12
   \   00000112   0x69A8             LDR      R0,[R5, #+24]
   \   00000114   0x4287             CMP      R7,R0
   \   00000116   0xF000 0x80EF      BEQ.W    ??f_lseek_12
   2851          #if !_FS_TINY
   2852          #if !_FS_READONLY
   2853          					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   \   0000011A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000011C   0x0640             LSLS     R0,R0,#+25
   \   0000011E   0xD513             BPL.N    ??f_lseek_15
   2854          						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   00000120   0x2301             MOVS     R3,#+1
   \   00000122   0x69AA             LDR      R2,[R5, #+24]
   \   00000124   0xF115 0x0128      ADDS     R1,R5,#+40
   \   00000128   0x6828             LDR      R0,[R5, #+0]
   \   0000012A   0x7840             LDRB     R0,[R0, #+1]
   \   0000012C   0x.... 0x....      BL       disk_write
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD005             BEQ.N    ??f_lseek_16
   2855          							ABORT(fp->fs, FR_DISK_ERR);
   \   00000134   0x79A8             LDRB     R0,[R5, #+6]
   \   00000136   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000013A   0x71A8             STRB     R0,[R5, #+6]
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0xE0DD             B.N      ??f_lseek_1
   2856          						fp->flag &= ~FA__DIRTY;
   \                     ??f_lseek_16:
   \   00000140   0x79A8             LDRB     R0,[R5, #+6]
   \   00000142   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   00000146   0x71A8             STRB     R0,[R5, #+6]
   2857          					}
   2858          #endif
   2859          					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
   \                     ??f_lseek_15:
   \   00000148   0x2301             MOVS     R3,#+1
   \   0000014A   0x003A             MOVS     R2,R7
   \   0000014C   0xF115 0x0128      ADDS     R1,R5,#+40
   \   00000150   0x6828             LDR      R0,[R5, #+0]
   \   00000152   0x7840             LDRB     R0,[R0, #+1]
   \   00000154   0x.... 0x....      BL       disk_read
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD005             BEQ.N    ??f_lseek_17
   2860          						ABORT(fp->fs, FR_DISK_ERR);
   \   0000015C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000015E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000162   0x71A8             STRB     R0,[R5, #+6]
   \   00000164   0x2001             MOVS     R0,#+1
   \   00000166   0xE0C9             B.N      ??f_lseek_1
   2861          #endif
   2862          					fp->dsect = dsc;
   \                     ??f_lseek_17:
   \   00000168   0x61AF             STR      R7,[R5, #+24]
   \   0000016A   0xE0C5             B.N      ??f_lseek_12
   2863          				}
   2864          			}
   2865          		}
   2866          	} else
   2867          #endif
   2868          
   2869          	/* Normal Seek */
   2870          	{
   2871          		DWORD clst, bcs, nsect, ifptr;
   2872          
   2873          		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   2874          #if !_FS_READONLY
   2875          			 && !(fp->flag & FA_WRITE)
   2876          #endif
   2877          			) ofs = fp->fsize;
   \                     ??f_lseek_3:
   \   0000016C   0x68E8             LDR      R0,[R5, #+12]
   \   0000016E   0x42B0             CMP      R0,R6
   \   00000170   0xD203             BCS.N    ??f_lseek_18
   \   00000172   0x79A8             LDRB     R0,[R5, #+6]
   \   00000174   0x0780             LSLS     R0,R0,#+30
   \   00000176   0xD400             BMI.N    ??f_lseek_18
   \   00000178   0x68EE             LDR      R6,[R5, #+12]
   2878          
   2879          		ifptr = fp->fptr;
   \                     ??f_lseek_18:
   \   0000017A   0x68A8             LDR      R0,[R5, #+8]
   2880          		fp->fptr = nsect = 0;
   \   0000017C   0x2700             MOVS     R7,#+0
   \   0000017E   0x60AF             STR      R7,[R5, #+8]
   2881          		if (ofs) {
   \   00000180   0x2E00             CMP      R6,#+0
   \   00000182   0xD07B             BEQ.N    ??f_lseek_19
   2882          			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   00000184   0x6829             LDR      R1,[R5, #+0]
   \   00000186   0x7889             LDRB     R1,[R1, #+2]
   \   00000188   0xF44F 0x7200      MOV      R2,#+512
   \   0000018C   0xFB02 0xF801      MUL      R8,R2,R1
   2883          			if (ifptr > 0 &&
   2884          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   00000190   0x2800             CMP      R0,#+0
   \   00000192   0xD010             BEQ.N    ??f_lseek_20
   \   00000194   0x1E41             SUBS     R1,R0,#+1
   \   00000196   0xFBB1 0xF1F8      UDIV     R1,R1,R8
   \   0000019A   0x1E72             SUBS     R2,R6,#+1
   \   0000019C   0xFBB2 0xF2F8      UDIV     R2,R2,R8
   \   000001A0   0x428A             CMP      R2,R1
   \   000001A2   0xD308             BCC.N    ??f_lseek_20
   2885          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \   000001A4   0x1E40             SUBS     R0,R0,#+1
   \   000001A6   0xF1B8 0x0101      SUBS     R1,R8,#+1
   \   000001AA   0x4388             BICS     R0,R0,R1
   \   000001AC   0x60A8             STR      R0,[R5, #+8]
   2886          				ofs -= fp->fptr;
   \   000001AE   0x68A8             LDR      R0,[R5, #+8]
   \   000001B0   0x1A36             SUBS     R6,R6,R0
   2887          				clst = fp->clust;
   \   000001B2   0x6969             LDR      R1,[R5, #+20]
   \   000001B4   0xE01A             B.N      ??f_lseek_21
   2888          			} else {									/* When seek to back cluster, */
   2889          				clst = fp->sclust;						/* start from the first cluster */
   \                     ??f_lseek_20:
   \   000001B6   0x6929             LDR      R1,[R5, #+16]
   2890          #if !_FS_READONLY
   2891          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   \   000001B8   0x2900             CMP      R1,#+0
   \   000001BA   0xD116             BNE.N    ??f_lseek_22
   2892          					clst = create_chain(fp->fs, 0);
   \   000001BC   0x2100             MOVS     R1,#+0
   \   000001BE   0x6828             LDR      R0,[R5, #+0]
   \   000001C0   0x.... 0x....      BL       create_chain
   \   000001C4   0x0001             MOVS     R1,R0
   2893          					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   000001C6   0x2901             CMP      R1,#+1
   \   000001C8   0xD105             BNE.N    ??f_lseek_23
   \   000001CA   0x79A8             LDRB     R0,[R5, #+6]
   \   000001CC   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001D0   0x71A8             STRB     R0,[R5, #+6]
   \   000001D2   0x2002             MOVS     R0,#+2
   \   000001D4   0xE092             B.N      ??f_lseek_1
   2894          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_23:
   \   000001D6   0xF111 0x0F01      CMN      R1,#+1
   \   000001DA   0xD105             BNE.N    ??f_lseek_24
   \   000001DC   0x79A8             LDRB     R0,[R5, #+6]
   \   000001DE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001E2   0x71A8             STRB     R0,[R5, #+6]
   \   000001E4   0x2001             MOVS     R0,#+1
   \   000001E6   0xE089             B.N      ??f_lseek_1
   2895          					fp->sclust = clst;
   \                     ??f_lseek_24:
   \   000001E8   0x6129             STR      R1,[R5, #+16]
   2896          				}
   2897          #endif
   2898          				fp->clust = clst;
   \                     ??f_lseek_22:
   \   000001EA   0x6169             STR      R1,[R5, #+20]
   2899          			}
   2900          			if (clst != 0) {
   \                     ??f_lseek_21:
   \   000001EC   0x2900             CMP      R1,#+0
   \   000001EE   0xD107             BNE.N    ??f_lseek_25
   \   000001F0   0xE044             B.N      ??f_lseek_19
   2901          				while (ofs > bcs) {						/* Cluster following loop */
   2902          #if !_FS_READONLY
   2903          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   2904          						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   2905          						if (clst == 0) {				/* When disk gets full, clip file size */
   2906          							ofs = bcs; break;
   2907          						}
   2908          					} else
   2909          #endif
   2910          						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   2911          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2912          					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   2913          					fp->clust = clst;
   \                     ??f_lseek_26:
   \   000001F2   0x6169             STR      R1,[R5, #+20]
   2914          					fp->fptr += bcs;
   \   000001F4   0x68A8             LDR      R0,[R5, #+8]
   \   000001F6   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001FA   0x60A8             STR      R0,[R5, #+8]
   2915          					ofs -= bcs;
   \   000001FC   0xEBB6 0x0608      SUBS     R6,R6,R8
   \                     ??f_lseek_25:
   \   00000200   0x45B0             CMP      R8,R6
   \   00000202   0xD209             BCS.N    ??f_lseek_27
   \   00000204   0x79A8             LDRB     R0,[R5, #+6]
   \   00000206   0x0780             LSLS     R0,R0,#+30
   \   00000208   0xD51D             BPL.N    ??f_lseek_28
   \   0000020A   0x6828             LDR      R0,[R5, #+0]
   \   0000020C   0x.... 0x....      BL       create_chain
   \   00000210   0x0001             MOVS     R1,R0
   \   00000212   0x2900             CMP      R1,#+0
   \   00000214   0xD11B             BNE.N    ??f_lseek_29
   \   00000216   0x4646             MOV      R6,R8
   2916          				}
   2917          				fp->fptr += ofs;
   \                     ??f_lseek_27:
   \   00000218   0x68A8             LDR      R0,[R5, #+8]
   \   0000021A   0x1830             ADDS     R0,R6,R0
   \   0000021C   0x60A8             STR      R0,[R5, #+8]
   2918          				if (ofs % SS(fp->fs)) {
   \   0000021E   0xF44F 0x7000      MOV      R0,#+512
   \   00000222   0xFBB6 0xF2F0      UDIV     R2,R6,R0
   \   00000226   0xFB02 0x6210      MLS      R2,R2,R0,R6
   \   0000022A   0x2A00             CMP      R2,#+0
   \   0000022C   0xD026             BEQ.N    ??f_lseek_19
   2919          					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   0000022E   0x6828             LDR      R0,[R5, #+0]
   \   00000230   0x.... 0x....      BL       clust2sect
   \   00000234   0x0007             MOVS     R7,R0
   2920          					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   00000236   0x2F00             CMP      R7,#+0
   \   00000238   0xD11E             BNE.N    ??f_lseek_30
   \   0000023A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000023C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000240   0x71A8             STRB     R0,[R5, #+6]
   \   00000242   0x2002             MOVS     R0,#+2
   \   00000244   0xE05A             B.N      ??f_lseek_1
   \                     ??f_lseek_28:
   \   00000246   0x6828             LDR      R0,[R5, #+0]
   \   00000248   0x.... 0x....      BL       get_fat
   \   0000024C   0x0001             MOVS     R1,R0
   \                     ??f_lseek_29:
   \   0000024E   0xF111 0x0F01      CMN      R1,#+1
   \   00000252   0xD105             BNE.N    ??f_lseek_31
   \   00000254   0x79A8             LDRB     R0,[R5, #+6]
   \   00000256   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000025A   0x71A8             STRB     R0,[R5, #+6]
   \   0000025C   0x2001             MOVS     R0,#+1
   \   0000025E   0xE04D             B.N      ??f_lseek_1
   \                     ??f_lseek_31:
   \   00000260   0x2902             CMP      R1,#+2
   \   00000262   0xD303             BCC.N    ??f_lseek_32
   \   00000264   0x6828             LDR      R0,[R5, #+0]
   \   00000266   0x69C0             LDR      R0,[R0, #+28]
   \   00000268   0x4281             CMP      R1,R0
   \   0000026A   0xD3C2             BCC.N    ??f_lseek_26
   \                     ??f_lseek_32:
   \   0000026C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000026E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000272   0x71A8             STRB     R0,[R5, #+6]
   \   00000274   0x2002             MOVS     R0,#+2
   \   00000276   0xE041             B.N      ??f_lseek_1
   2921          					nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_30:
   \   00000278   0xEB17 0x2756      ADDS     R7,R7,R6, LSR #+9
   2922          				}
   2923          			}
   2924          		}
   2925          		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   \                     ??f_lseek_19:
   \   0000027C   0x68A8             LDR      R0,[R5, #+8]
   \   0000027E   0xF44F 0x7100      MOV      R1,#+512
   \   00000282   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000286   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   0000028A   0x2A00             CMP      R2,#+0
   \   0000028C   0xD02A             BEQ.N    ??f_lseek_33
   \   0000028E   0x69A8             LDR      R0,[R5, #+24]
   \   00000290   0x4287             CMP      R7,R0
   \   00000292   0xD027             BEQ.N    ??f_lseek_33
   2926          #if !_FS_TINY
   2927          #if !_FS_READONLY
   2928          			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   \   00000294   0x79A8             LDRB     R0,[R5, #+6]
   \   00000296   0x0640             LSLS     R0,R0,#+25
   \   00000298   0xD513             BPL.N    ??f_lseek_34
   2929          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0000029A   0x2301             MOVS     R3,#+1
   \   0000029C   0x69AA             LDR      R2,[R5, #+24]
   \   0000029E   0xF115 0x0128      ADDS     R1,R5,#+40
   \   000002A2   0x6828             LDR      R0,[R5, #+0]
   \   000002A4   0x7840             LDRB     R0,[R0, #+1]
   \   000002A6   0x.... 0x....      BL       disk_write
   \   000002AA   0x2800             CMP      R0,#+0
   \   000002AC   0xD005             BEQ.N    ??f_lseek_35
   2930          					ABORT(fp->fs, FR_DISK_ERR);
   \   000002AE   0x79A8             LDRB     R0,[R5, #+6]
   \   000002B0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000002B4   0x71A8             STRB     R0,[R5, #+6]
   \   000002B6   0x2001             MOVS     R0,#+1
   \   000002B8   0xE020             B.N      ??f_lseek_1
   2931          				fp->flag &= ~FA__DIRTY;
   \                     ??f_lseek_35:
   \   000002BA   0x79A8             LDRB     R0,[R5, #+6]
   \   000002BC   0xF010 0x00BF      ANDS     R0,R0,#0xBF
   \   000002C0   0x71A8             STRB     R0,[R5, #+6]
   2932          			}
   2933          #endif
   2934          			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   \                     ??f_lseek_34:
   \   000002C2   0x2301             MOVS     R3,#+1
   \   000002C4   0x003A             MOVS     R2,R7
   \   000002C6   0xF115 0x0128      ADDS     R1,R5,#+40
   \   000002CA   0x6828             LDR      R0,[R5, #+0]
   \   000002CC   0x7840             LDRB     R0,[R0, #+1]
   \   000002CE   0x.... 0x....      BL       disk_read
   \   000002D2   0x2800             CMP      R0,#+0
   \   000002D4   0xD005             BEQ.N    ??f_lseek_36
   2935          				ABORT(fp->fs, FR_DISK_ERR);
   \   000002D6   0x79A8             LDRB     R0,[R5, #+6]
   \   000002D8   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000002DC   0x71A8             STRB     R0,[R5, #+6]
   \   000002DE   0x2001             MOVS     R0,#+1
   \   000002E0   0xE00C             B.N      ??f_lseek_1
   2936          #endif
   2937          			fp->dsect = nsect;
   \                     ??f_lseek_36:
   \   000002E2   0x61AF             STR      R7,[R5, #+24]
   2938          		}
   2939          #if !_FS_READONLY
   2940          		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   \                     ??f_lseek_33:
   \   000002E4   0x68E8             LDR      R0,[R5, #+12]
   \   000002E6   0x68A9             LDR      R1,[R5, #+8]
   \   000002E8   0x4288             CMP      R0,R1
   \   000002EA   0xD205             BCS.N    ??f_lseek_12
   2941          			fp->fsize = fp->fptr;
   \   000002EC   0x68A8             LDR      R0,[R5, #+8]
   \   000002EE   0x60E8             STR      R0,[R5, #+12]
   2942          			fp->flag |= FA__WRITTEN;
   \   000002F0   0x79A8             LDRB     R0,[R5, #+6]
   \   000002F2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000002F6   0x71A8             STRB     R0,[R5, #+6]
   2943          		}
   2944          #endif
   2945          	}
   2946          
   2947          	LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_12:
   \   000002F8   0x0020             MOVS     R0,R4
   \   000002FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??f_lseek_1:
   \   000002FC   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   2948          }
   2949          
   2950          
   2951          
   2952          #if _FS_MINIMIZE <= 1
   2953          /*-----------------------------------------------------------------------*/
   2954          /* Create a Directroy Object                                             */
   2955          /*-----------------------------------------------------------------------*/
   2956          

   \                                 In section .text, align 2, keep-with-next
   2957          FRESULT f_opendir (
   2958          	DIR *dj,			/* Pointer to directory object to create */
   2959          	const TCHAR *path	/* Pointer to the directory path */
   2960          )
   2961          {
   \                     f_opendir:
   \   00000000   0xB512             PUSH     {R1,R4,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   2962          	FRESULT res;
   2963          	DEF_NAMEBUF;
   2964          
   2965          
   2966          	res = chk_mounted(&path, &dj->fs, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0xA803             ADD      R0,SP,#+12
   \   0000000C   0x.... 0x....      BL       chk_mounted
   2967          	if (res == FR_OK) {
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD132             BNE.N    ??f_opendir_0
   2968          		INIT_BUF(*dj);
   \   00000016   0xA800             ADD      R0,SP,#+0
   \   00000018   0x61A0             STR      R0,[R4, #+24]
   \   0000001A   0x....             LDR.N    R0,??DataTable12_3
   \   0000001C   0x61E0             STR      R0,[R4, #+28]
   2969          		res = follow_path(dj, path);			/* Follow the path to the directory */
   \   0000001E   0x9903             LDR      R1,[SP, #+12]
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       follow_path
   2970          		FREE_BUF();
   2971          		if (res == FR_OK) {						/* Follow completed */
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD123             BNE.N    ??f_opendir_1
   2972          			if (dj->dir) {						/* It is not the root dir */
   \   0000002C   0x6961             LDR      R1,[R4, #+20]
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD016             BEQ.N    ??f_opendir_2
   2973          				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
   \   00000032   0x6961             LDR      R1,[R4, #+20]
   \   00000034   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000036   0x06C9             LSLS     R1,R1,#+27
   \   00000038   0xD511             BPL.N    ??f_opendir_3
   2974          					dj->sclust = LD_CLUST(dj->dir);
   \   0000003A   0x6961             LDR      R1,[R4, #+20]
   \   0000003C   0x7D49             LDRB     R1,[R1, #+21]
   \   0000003E   0x6962             LDR      R2,[R4, #+20]
   \   00000040   0x7D12             LDRB     R2,[R2, #+20]
   \   00000042   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000046   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000048   0x6962             LDR      R2,[R4, #+20]
   \   0000004A   0x7ED2             LDRB     R2,[R2, #+27]
   \   0000004C   0x6963             LDR      R3,[R4, #+20]
   \   0000004E   0x7E9B             LDRB     R3,[R3, #+26]
   \   00000050   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   \   00000054   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000056   0xEA52 0x4101      ORRS     R1,R2,R1, LSL #+16
   \   0000005A   0x60A1             STR      R1,[R4, #+8]
   \   0000005C   0xE000             B.N      ??f_opendir_2
   2975          				} else {						/* The object is not a directory */
   2976          					res = FR_NO_PATH;
   \                     ??f_opendir_3:
   \   0000005E   0x2005             MOVS     R0,#+5
   2977          				}
   2978          			}
   2979          			if (res == FR_OK) {
   \                     ??f_opendir_2:
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD106             BNE.N    ??f_opendir_1
   2980          				dj->id = dj->fs->id;
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x88C0             LDRH     R0,[R0, #+6]
   \   0000006A   0x80A0             STRH     R0,[R4, #+4]
   2981          				res = dir_sdi(dj, 0);			/* Rewind dir */
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       dir_sdi
   2982          			}
   2983          		}
   2984          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_opendir_1:
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x2804             CMP      R0,#+4
   \   00000078   0xD100             BNE.N    ??f_opendir_0
   \   0000007A   0x2005             MOVS     R0,#+5
   2985          	}
   2986          
   2987          	LEAVE_FF(dj->fs, res);
   \                     ??f_opendir_0:
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0xB004             ADD      SP,SP,#+16
   \   00000080   0xBD10             POP      {R4,PC}          ;; return
   2988          }
   2989          
   2990          
   2991          
   2992          
   2993          /*-----------------------------------------------------------------------*/
   2994          /* Read Directory Entry in Sequense                                      */
   2995          /*-----------------------------------------------------------------------*/
   2996          

   \                                 In section .text, align 2, keep-with-next
   2997          FRESULT f_readdir (
   2998          	DIR *dj,			/* Pointer to the open directory object */
   2999          	FILINFO *fno		/* Pointer to file information to return */
   3000          )
   3001          {
   \                     f_readdir:
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3002          	FRESULT res;
   3003          	DEF_NAMEBUF;
   3004          
   3005          
   3006          	res = validate(dj->fs, dj->id);			/* Check validity of the object */
   \   00000006   0x88A1             LDRH     R1,[R4, #+4]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       validate
   3007          	if (res == FR_OK) {
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD124             BNE.N    ??f_readdir_0
   3008          		if (!fno) {
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD104             BNE.N    ??f_readdir_1
   3009          			res = dir_sdi(dj, 0);			/* Rewind the directory object */
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       dir_sdi
   \   00000020   0xE01D             B.N      ??f_readdir_0
   3010          		} else {
   3011          			INIT_BUF(*dj);
   \                     ??f_readdir_1:
   \   00000022   0xA800             ADD      R0,SP,#+0
   \   00000024   0x61A0             STR      R0,[R4, #+24]
   \   00000026   0x....             LDR.N    R0,??DataTable12_3
   \   00000028   0x61E0             STR      R0,[R4, #+28]
   3012          			res = dir_read(dj);				/* Read an directory item */
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       dir_read
   3013          			if (res == FR_NO_FILE) {		/* Reached end of dir */
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD102             BNE.N    ??f_readdir_2
   3014          				dj->sect = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6120             STR      R0,[R4, #+16]
   3015          				res = FR_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   3016          			}
   3017          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_2:
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD10D             BNE.N    ??f_readdir_0
   3018          				get_fileinfo(dj, fno);		/* Get the object information */
   \   00000042   0x0029             MOVS     R1,R5
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       get_fileinfo
   3019          				res = dir_next(dj, 0);		/* Increment index for next */
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       dir_next
   3020          				if (res == FR_NO_FILE) {
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0x2804             CMP      R0,#+4
   \   00000056   0xD102             BNE.N    ??f_readdir_0
   3021          					dj->sect = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x6120             STR      R0,[R4, #+16]
   3022          					res = FR_OK;
   \   0000005C   0x2000             MOVS     R0,#+0
   3023          				}
   3024          			}
   3025          			FREE_BUF();
   3026          		}
   3027          	}
   3028          
   3029          	LEAVE_FF(dj->fs, res);
   \                     ??f_readdir_0:
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0xBD3E             POP      {R1-R5,PC}       ;; return
   3030          }
   3031          
   3032          
   3033          
   3034          #if _FS_MINIMIZE == 0
   3035          /*-----------------------------------------------------------------------*/
   3036          /* Get File Status                                                       */
   3037          /*-----------------------------------------------------------------------*/
   3038          

   \                                 In section .text, align 2, keep-with-next
   3039          FRESULT f_stat (
   3040          	const TCHAR *path,	/* Pointer to the file path */
   3041          	FILINFO *fno		/* Pointer to file information to return */
   3042          )
   3043          {
   \                     f_stat:
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x000C             MOVS     R4,R1
   3044          	FRESULT res;
   3045          	DIR dj;
   3046          	DEF_NAMEBUF;
   3047          
   3048          
   3049          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA903             ADD      R1,SP,#+12
   \   0000000A   0xA80C             ADD      R0,SP,#+48
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0005             MOVS     R5,R0
   3050          	if (res == FR_OK) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD114             BNE.N    ??f_stat_0
   3051          		INIT_BUF(dj);
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x9009             STR      R0,[SP, #+36]
   \   0000001C   0x....             LDR.N    R0,??DataTable12_3
   \   0000001E   0x900A             STR      R0,[SP, #+40]
   3052          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000020   0x990C             LDR      R1,[SP, #+48]
   \   00000022   0xA803             ADD      R0,SP,#+12
   \   00000024   0x.... 0x....      BL       follow_path
   \   00000028   0x0005             MOVS     R5,R0
   3053          		if (res == FR_OK) {				/* Follow completed */
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD108             BNE.N    ??f_stat_0
   3054          			if (dj.dir)		/* Found an object */
   \   00000030   0x9808             LDR      R0,[SP, #+32]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD004             BEQ.N    ??f_stat_1
   3055          				get_fileinfo(&dj, fno);
   \   00000036   0x0021             MOVS     R1,R4
   \   00000038   0xA803             ADD      R0,SP,#+12
   \   0000003A   0x.... 0x....      BL       get_fileinfo
   \   0000003E   0xE000             B.N      ??f_stat_0
   3056          			else			/* It is root dir */
   3057          				res = FR_INVALID_NAME;
   \                     ??f_stat_1:
   \   00000040   0x2506             MOVS     R5,#+6
   3058          		}
   3059          		FREE_BUF();
   3060          	}
   3061          
   3062          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0:
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xB00D             ADD      SP,SP,#+52
   \   00000048   0xBD30             POP      {R4,R5,PC}       ;; return
   3063          }
   3064          
   3065          
   3066          
   3067          #if !_FS_READONLY
   3068          /*-----------------------------------------------------------------------*/
   3069          /* Get Number of Free Clusters                                           */
   3070          /*-----------------------------------------------------------------------*/
   3071          

   \                                 In section .text, align 2, keep-with-next
   3072          FRESULT f_getfree (
   3073          	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
   3074          	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
   3075          	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
   3076          )
   3077          {
   \                     f_getfree:
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   3078          	FRESULT res;
   3079          	DWORD n, clst, sect, stat;
   3080          	UINT i;
   3081          	BYTE fat, *p;
   3082          
   3083          
   3084          	/* Get drive number */
   3085          	res = chk_mounted(&path, fatfs, 0);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0031             MOVS     R1,R6
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       chk_mounted
   \   00000014   0x4680             MOV      R8,R0
   3086          	if (res == FR_OK) {
   \   00000016   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xD172             BNE.N    ??f_getfree_0
   3087          		/* If free_clust is valid, return it without full cluster scan */
   3088          		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
   \   00000020   0x6830             LDR      R0,[R6, #+0]
   \   00000022   0x69C0             LDR      R0,[R0, #+28]
   \   00000024   0x1E80             SUBS     R0,R0,#+2
   \   00000026   0x6831             LDR      R1,[R6, #+0]
   \   00000028   0x6909             LDR      R1,[R1, #+16]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD303             BCC.N    ??f_getfree_1
   3089          			*nclst = (*fatfs)->free_clust;
   \   0000002E   0x6830             LDR      R0,[R6, #+0]
   \   00000030   0x6900             LDR      R0,[R0, #+16]
   \   00000032   0x6028             STR      R0,[R5, #+0]
   \   00000034   0xE067             B.N      ??f_getfree_0
   3090          		} else {
   3091          			/* Get number of free clusters */
   3092          			fat = (*fatfs)->fs_type;
   \                     ??f_getfree_1:
   \   00000036   0x6830             LDR      R0,[R6, #+0]
   \   00000038   0x7807             LDRB     R7,[R0, #+0]
   3093          			n = 0;
   \   0000003A   0xF05F 0x0900      MOVS     R9,#+0
   3094          			if (fat == FS_FAT12) {
   \   0000003E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000040   0x2F01             CMP      R7,#+1
   \   00000042   0xD119             BNE.N    ??f_getfree_2
   3095          				clst = 2;
   \   00000044   0x2402             MOVS     R4,#+2
   3096          				do {
   3097          					stat = get_fat(*fatfs, clst);
   \                     ??f_getfree_3:
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0x6830             LDR      R0,[R6, #+0]
   \   0000004A   0x.... 0x....      BL       get_fat
   3098          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   0000004E   0xF110 0x0F01      CMN      R0,#+1
   \   00000052   0xD102             BNE.N    ??f_getfree_4
   \   00000054   0xF05F 0x0801      MOVS     R8,#+1
   \   00000058   0xE04A             B.N      ??f_getfree_5
   3099          					if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_4:
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD102             BNE.N    ??f_getfree_6
   \   0000005E   0xF05F 0x0802      MOVS     R8,#+2
   \   00000062   0xE045             B.N      ??f_getfree_5
   3100          					if (stat == 0) n++;
   \                     ??f_getfree_6:
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD101             BNE.N    ??f_getfree_7
   \   00000068   0xF119 0x0901      ADDS     R9,R9,#+1
   3101          				} while (++clst < (*fatfs)->n_fatent);
   \                     ??f_getfree_7:
   \   0000006C   0x1C64             ADDS     R4,R4,#+1
   \   0000006E   0x6830             LDR      R0,[R6, #+0]
   \   00000070   0x69C0             LDR      R0,[R0, #+28]
   \   00000072   0x4284             CMP      R4,R0
   \   00000074   0xD3E7             BCC.N    ??f_getfree_3
   \   00000076   0xE03B             B.N      ??f_getfree_5
   3102          			} else {
   3103          				clst = (*fatfs)->n_fatent;
   \                     ??f_getfree_2:
   \   00000078   0x6830             LDR      R0,[R6, #+0]
   \   0000007A   0x69C4             LDR      R4,[R0, #+28]
   3104          				sect = (*fatfs)->fatbase;
   \   0000007C   0x6830             LDR      R0,[R6, #+0]
   \   0000007E   0xF8D0 0xA024      LDR      R10,[R0, #+36]
   3105          				i = 0; p = 0;
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x2000             MOVS     R0,#+0
   3106          				do {
   3107          					if (!i) {
   \                     ??f_getfree_8:
   \   00000086   0x2900             CMP      R1,#+0
   \   00000088   0xD110             BNE.N    ??f_getfree_9
   3108          						res = move_window(*fatfs, sect++);
   \   0000008A   0x4651             MOV      R1,R10
   \   0000008C   0x6830             LDR      R0,[R6, #+0]
   \   0000008E   0x.... 0x....      BL       move_window
   \   00000092   0x4680             MOV      R8,R0
   \   00000094   0xF11A 0x0A01      ADDS     R10,R10,#+1
   3109          						if (res != FR_OK) break;
   \   00000098   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009C   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000A0   0xD126             BNE.N    ??f_getfree_5
   3110          						p = (*fatfs)->win;
   \                     ??f_getfree_10:
   \   000000A2   0x6830             LDR      R0,[R6, #+0]
   \   000000A4   0xF200 0x0034      ADDW     R0,R0,#+52
   3111          						i = SS(*fatfs);
   \   000000A8   0xF44F 0x7100      MOV      R1,#+512
   3112          					}
   3113          					if (fat == FS_FAT16) {
   \                     ??f_getfree_9:
   \   000000AC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AE   0x2F02             CMP      R7,#+2
   \   000000B0   0xD10B             BNE.N    ??f_getfree_11
   3114          						if (LD_WORD(p) == 0) n++;
   \   000000B2   0x7842             LDRB     R2,[R0, #+1]
   \   000000B4   0x7803             LDRB     R3,[R0, #+0]
   \   000000B6   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   \   000000BA   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000BC   0x2A00             CMP      R2,#+0
   \   000000BE   0xD101             BNE.N    ??f_getfree_12
   \   000000C0   0xF119 0x0901      ADDS     R9,R9,#+1
   3115          						p += 2; i -= 2;
   \                     ??f_getfree_12:
   \   000000C4   0x1C80             ADDS     R0,R0,#+2
   \   000000C6   0x1E89             SUBS     R1,R1,#+2
   \   000000C8   0xE00F             B.N      ??f_getfree_13
   3116          					} else {
   3117          						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_11:
   \   000000CA   0x78C2             LDRB     R2,[R0, #+3]
   \   000000CC   0x7883             LDRB     R3,[R0, #+2]
   \   000000CE   0x041B             LSLS     R3,R3,#+16
   \   000000D0   0xEA53 0x6202      ORRS     R2,R3,R2, LSL #+24
   \   000000D4   0x7843             LDRB     R3,[R0, #+1]
   \   000000D6   0xEA52 0x2203      ORRS     R2,R2,R3, LSL #+8
   \   000000DA   0x7803             LDRB     R3,[R0, #+0]
   \   000000DC   0x431A             ORRS     R2,R3,R2
   \   000000DE   0x0112             LSLS     R2,R2,#+4
   \   000000E0   0xD101             BNE.N    ??f_getfree_14
   \   000000E2   0xF119 0x0901      ADDS     R9,R9,#+1
   3118          						p += 4; i -= 4;
   \                     ??f_getfree_14:
   \   000000E6   0x1D00             ADDS     R0,R0,#+4
   \   000000E8   0x1F09             SUBS     R1,R1,#+4
   3119          					}
   3120          				} while (--clst);
   \                     ??f_getfree_13:
   \   000000EA   0x1E64             SUBS     R4,R4,#+1
   \   000000EC   0x2C00             CMP      R4,#+0
   \   000000EE   0xD1CA             BNE.N    ??f_getfree_8
   3121          			}
   3122          			(*fatfs)->free_clust = n;
   \                     ??f_getfree_5:
   \   000000F0   0x6830             LDR      R0,[R6, #+0]
   \   000000F2   0xF8C0 0x9010      STR      R9,[R0, #+16]
   3123          			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
   \   000000F6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F8   0x2F03             CMP      R7,#+3
   \   000000FA   0xD102             BNE.N    ??f_getfree_15
   \   000000FC   0x6830             LDR      R0,[R6, #+0]
   \   000000FE   0x2101             MOVS     R1,#+1
   \   00000100   0x7141             STRB     R1,[R0, #+5]
   3124          			*nclst = n;
   \                     ??f_getfree_15:
   \   00000102   0xF8C5 0x9000      STR      R9,[R5, #+0]
   3125          		}
   3126          	}
   3127          	LEAVE_FF(*fatfs, res);
   \                     ??f_getfree_0:
   \   00000106   0x4640             MOV      R0,R8
   \   00000108   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010A   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3128          }
   3129          
   3130          
   3131          
   3132          
   3133          /*-----------------------------------------------------------------------*/
   3134          /* Truncate File                                                         */
   3135          /*-----------------------------------------------------------------------*/
   3136          

   \                                 In section .text, align 2, keep-with-next
   3137          FRESULT f_truncate (
   3138          	FIL *fp		/* Pointer to the file object */
   3139          )
   3140          {
   \                     f_truncate:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3141          	FRESULT res;
   3142          	DWORD ncl;
   3143          
   3144          
   3145          	res = validate(fp->fs, fp->id);		/* Check validity of the object */
   \   00000004   0x88A1             LDRH     R1,[R4, #+4]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       validate
   3146          	if (res == FR_OK) {
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD108             BNE.N    ??f_truncate_0
   3147          		if (fp->flag & FA__ERROR) {			/* Check abort flag */
   \   00000012   0x79A1             LDRB     R1,[R4, #+6]
   \   00000014   0x0609             LSLS     R1,R1,#+24
   \   00000016   0xD501             BPL.N    ??f_truncate_1
   3148          			res = FR_INT_ERR;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xE003             B.N      ??f_truncate_0
   3149          		} else {
   3150          			if (!(fp->flag & FA_WRITE))		/* Check access mode */
   \                     ??f_truncate_1:
   \   0000001C   0x79A1             LDRB     R1,[R4, #+6]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD400             BMI.N    ??f_truncate_0
   3151          				res = FR_DENIED;
   \   00000022   0x2007             MOVS     R0,#+7
   3152          		}
   3153          	}
   3154          	if (res == FR_OK) {
   \                     ??f_truncate_0:
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD13B             BNE.N    ??f_truncate_2
   3155          		if (fp->fsize > fp->fptr) {
   \   0000002A   0x68A1             LDR      R1,[R4, #+8]
   \   0000002C   0x68E2             LDR      R2,[R4, #+12]
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xD230             BCS.N    ??f_truncate_3
   3156          			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \   00000032   0x68A0             LDR      R0,[R4, #+8]
   \   00000034   0x60E0             STR      R0,[R4, #+12]
   3157          			fp->flag |= FA__WRITTEN;
   \   00000036   0x79A0             LDRB     R0,[R4, #+6]
   \   00000038   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000003C   0x71A0             STRB     R0,[R4, #+6]
   3158          			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD106             BNE.N    ??f_truncate_4
   3159          				res = remove_chain(fp->fs, fp->sclust);
   \   00000044   0x6921             LDR      R1,[R4, #+16]
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       remove_chain
   3160          				fp->sclust = 0;
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x6121             STR      R1,[R4, #+16]
   \   00000050   0xE020             B.N      ??f_truncate_3
   3161          			} else {				/* When truncate a part of the file, remove remaining clusters */
   3162          				ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_4:
   \   00000052   0x6961             LDR      R1,[R4, #+20]
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       get_fat
   \   0000005A   0x0005             MOVS     R5,R0
   3163          				res = FR_OK;
   \   0000005C   0x2000             MOVS     R0,#+0
   3164          				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   0000005E   0xF115 0x0F01      CMN      R5,#+1
   \   00000062   0xD100             BNE.N    ??f_truncate_5
   \   00000064   0x2001             MOVS     R0,#+1
   3165          				if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_5:
   \   00000066   0x2D01             CMP      R5,#+1
   \   00000068   0xD100             BNE.N    ??f_truncate_6
   \   0000006A   0x2002             MOVS     R0,#+2
   3166          				if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \                     ??f_truncate_6:
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD110             BNE.N    ??f_truncate_3
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x69C9             LDR      R1,[R1, #+28]
   \   00000076   0x428D             CMP      R5,R1
   \   00000078   0xD20C             BCS.N    ??f_truncate_3
   3167          					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \   0000007A   0xF07F 0x4270      MVNS     R2,#-268435456
   \   0000007E   0x6961             LDR      R1,[R4, #+20]
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       put_fat
   3168          					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD103             BNE.N    ??f_truncate_3
   \   0000008C   0x0029             MOVS     R1,R5
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x.... 0x....      BL       remove_chain
   3169          				}
   3170          			}
   3171          		}
   3172          		if (res != FR_OK) fp->flag |= FA__ERROR;
   \                     ??f_truncate_3:
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD003             BEQ.N    ??f_truncate_2
   \   0000009A   0x79A1             LDRB     R1,[R4, #+6]
   \   0000009C   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   000000A0   0x71A1             STRB     R1,[R4, #+6]
   3173          	}
   3174          
   3175          	LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_2:
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3176          }
   3177          
   3178          
   3179          
   3180          
   3181          /*-----------------------------------------------------------------------*/
   3182          /* Delete a File or Directory                                            */
   3183          /*-----------------------------------------------------------------------*/
   3184          

   \                                 In section .text, align 2, keep-with-next
   3185          FRESULT f_unlink (
   3186          	const TCHAR *path		/* Pointer to the file or directory path */
   3187          )
   3188          {
   \                     f_unlink:
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB095             SUB      SP,SP,#+84
   3189          	FRESULT res;
   3190          	DIR dj, sdj;
   3191          	BYTE *dir;
   3192          	DWORD dclst;
   3193          	DEF_NAMEBUF;
   3194          
   3195          
   3196          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0xA815             ADD      R0,SP,#+84
   \   0000000A   0x.... 0x....      BL       chk_mounted
   3197          	if (res == FR_OK) {
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD163             BNE.N    ??f_unlink_0
   3198          		INIT_BUF(dj);
   \   00000014   0xA809             ADD      R0,SP,#+36
   \   00000016   0x9006             STR      R0,[SP, #+24]
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000001C   0x9007             STR      R0,[SP, #+28]
   3199          		res = follow_path(&dj, path);		/* Follow the file path */
   \   0000001E   0x9915             LDR      R1,[SP, #+84]
   \   00000020   0xA800             ADD      R0,SP,#+0
   \   00000022   0x.... 0x....      BL       follow_path
   3200          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD104             BNE.N    ??f_unlink_1
   \   0000002C   0x9906             LDR      R1,[SP, #+24]
   \   0000002E   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000030   0x0689             LSLS     R1,R1,#+26
   \   00000032   0xD500             BPL.N    ??f_unlink_1
   3201          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   \   00000034   0x2006             MOVS     R0,#+6
   3202          #if _FS_SHARE
   3203          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
   3204          #endif
   3205          		if (res == FR_OK) {					/* The object is accessible */
   \                     ??f_unlink_1:
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD14F             BNE.N    ??f_unlink_0
   3206          			dir = dj.dir;
   \   0000003C   0x9905             LDR      R1,[SP, #+20]
   3207          			if (!dir) {
   \   0000003E   0x2900             CMP      R1,#+0
   \   00000040   0xD101             BNE.N    ??f_unlink_2
   3208          				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
   \   00000042   0x2006             MOVS     R0,#+6
   \   00000044   0xE003             B.N      ??f_unlink_3
   3209          			} else {
   3210          				if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_2:
   \   00000046   0x7ACA             LDRB     R2,[R1, #+11]
   \   00000048   0x07D2             LSLS     R2,R2,#+31
   \   0000004A   0xD500             BPL.N    ??f_unlink_3
   3211          					res = FR_DENIED;		/* Cannot remove R/O object */
   \   0000004C   0x2007             MOVS     R0,#+7
   3212          			}
   3213          			dclst = LD_CLUST(dir);
   \                     ??f_unlink_3:
   \   0000004E   0x7D4A             LDRB     R2,[R1, #+21]
   \   00000050   0x7D0B             LDRB     R3,[R1, #+20]
   \   00000052   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   \   00000056   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000058   0x7ECB             LDRB     R3,[R1, #+27]
   \   0000005A   0x7E8C             LDRB     R4,[R1, #+26]
   \   0000005C   0xEA54 0x2303      ORRS     R3,R4,R3, LSL #+8
   \   00000060   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000062   0xEA53 0x4402      ORRS     R4,R3,R2, LSL #+16
   3214          			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD122             BNE.N    ??f_unlink_4
   \   0000006C   0x7AC9             LDRB     R1,[R1, #+11]
   \   0000006E   0x06C9             LSLS     R1,R1,#+27
   \   00000070   0xD51F             BPL.N    ??f_unlink_4
   3215          				if (dclst < 2) {
   \   00000072   0x2C02             CMP      R4,#+2
   \   00000074   0xD201             BCS.N    ??f_unlink_5
   3216          					res = FR_INT_ERR;
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0xE01B             B.N      ??f_unlink_4
   3217          				} else {
   3218          					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
   \                     ??f_unlink_5:
   \   0000007A   0x2224             MOVS     R2,#+36
   \   0000007C   0xA900             ADD      R1,SP,#+0
   \   0000007E   0xA80C             ADD      R0,SP,#+48
   \   00000080   0x.... 0x....      BL       mem_cpy
   3219          					sdj.sclust = dclst;
   \   00000084   0x940E             STR      R4,[SP, #+56]
   3220          					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
   \   00000086   0x2102             MOVS     R1,#+2
   \   00000088   0xA80C             ADD      R0,SP,#+48
   \   0000008A   0x.... 0x....      BL       dir_sdi
   3221          					if (res == FR_OK) {
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD10E             BNE.N    ??f_unlink_4
   3222          						res = dir_read(&sdj);
   \   00000094   0xA80C             ADD      R0,SP,#+48
   \   00000096   0x.... 0x....      BL       dir_read
   3223          						if (res == FR_OK			/* Not empty dir */
   3224          #if _FS_RPATH
   3225          						|| dclst == sdj.fs->cdir	/* Current dir */
   3226          #endif
   3227          						) res = FR_DENIED;
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD003             BEQ.N    ??f_unlink_6
   \   000000A0   0x990C             LDR      R1,[SP, #+48]
   \   000000A2   0x6989             LDR      R1,[R1, #+24]
   \   000000A4   0x428C             CMP      R4,R1
   \   000000A6   0xD100             BNE.N    ??f_unlink_7
   \                     ??f_unlink_6:
   \   000000A8   0x2007             MOVS     R0,#+7
   3228          						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
   \                     ??f_unlink_7:
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0x2804             CMP      R0,#+4
   \   000000AE   0xD100             BNE.N    ??f_unlink_4
   \   000000B0   0x2000             MOVS     R0,#+0
   3229          					}
   3230          				}
   3231          			}
   3232          			if (res == FR_OK) {
   \                     ??f_unlink_4:
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD111             BNE.N    ??f_unlink_0
   3233          				res = dir_remove(&dj);		/* Remove the directory entry */
   \   000000B8   0xA800             ADD      R0,SP,#+0
   \   000000BA   0x.... 0x....      BL       dir_remove
   3234          				if (res == FR_OK) {
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD10B             BNE.N    ??f_unlink_0
   3235          					if (dclst)				/* Remove the cluster chain if exist */
   \   000000C4   0x2C00             CMP      R4,#+0
   \   000000C6   0xD003             BEQ.N    ??f_unlink_8
   3236          						res = remove_chain(dj.fs, dclst);
   \   000000C8   0x0021             MOVS     R1,R4
   \   000000CA   0x9800             LDR      R0,[SP, #+0]
   \   000000CC   0x.... 0x....      BL       remove_chain
   3237          					if (res == FR_OK) res = sync(dj.fs);
   \                     ??f_unlink_8:
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD102             BNE.N    ??f_unlink_0
   \   000000D6   0x9800             LDR      R0,[SP, #+0]
   \   000000D8   0x.... 0x....      BL       sync
   3238          				}
   3239          			}
   3240          		}
   3241          		FREE_BUF();
   3242          	}
   3243          	LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_0:
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0xB016             ADD      SP,SP,#+88
   \   000000E0   0xBD10             POP      {R4,PC}          ;; return
   3244          }
   3245          
   3246          
   3247          
   3248          
   3249          /*-----------------------------------------------------------------------*/
   3250          /* Create a Directory                                                    */
   3251          /*-----------------------------------------------------------------------*/
   3252          

   \                                 In section .text, align 2, keep-with-next
   3253          FRESULT f_mkdir (
   3254          	const TCHAR *path		/* Pointer to the directory path */
   3255          )
   3256          {
   \                     f_mkdir:
   \   00000000   0xE92D 0x43F1      PUSH     {R0,R4-R9,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   3257          	FRESULT res;
   3258          	DIR dj;
   3259          	BYTE *dir, n;
   3260          	DWORD dsc, dcl, pcl, tim = get_fattime();
   \   00000006   0x.... 0x....      BL       get_fattime
   \   0000000A   0x0004             MOVS     R4,R0
   3261          	DEF_NAMEBUF;
   3262          
   3263          
   3264          	res = chk_mounted(&path, &dj.fs, 1);
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0xA80C             ADD      R0,SP,#+48
   \   00000012   0x.... 0x....      BL       chk_mounted
   \   00000016   0x0005             MOVS     R5,R0
   3265          	if (res == FR_OK) {
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xF040 0x80E2      BNE.W    ??f_mkdir_0
   3266          		INIT_BUF(dj);
   \   00000020   0xA809             ADD      R0,SP,#+36
   \   00000022   0x9006             STR      R0,[SP, #+24]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000028   0x9007             STR      R0,[SP, #+28]
   3267          		res = follow_path(&dj, path);			/* Follow the file path */
   \   0000002A   0x990C             LDR      R1,[SP, #+48]
   \   0000002C   0xA800             ADD      R0,SP,#+0
   \   0000002E   0x.... 0x....      BL       follow_path
   \   00000032   0x0005             MOVS     R5,R0
   3268          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD100             BNE.N    ??f_mkdir_1
   \   0000003A   0x2508             MOVS     R5,#+8
   3269          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
   \                     ??f_mkdir_1:
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D04             CMP      R5,#+4
   \   00000040   0xD104             BNE.N    ??f_mkdir_2
   \   00000042   0x9806             LDR      R0,[SP, #+24]
   \   00000044   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000046   0x0680             LSLS     R0,R0,#+26
   \   00000048   0xD500             BPL.N    ??f_mkdir_2
   3270          			res = FR_INVALID_NAME;
   \   0000004A   0x2506             MOVS     R5,#+6
   3271          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   \                     ??f_mkdir_2:
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D04             CMP      R5,#+4
   \   00000050   0xF040 0x80C8      BNE.W    ??f_mkdir_0
   3272          			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0x.... 0x....      BL       create_chain
   \   0000005C   0x0006             MOVS     R6,R0
   3273          			res = FR_OK;
   \   0000005E   0x2500             MOVS     R5,#+0
   3274          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   \   00000060   0x2E00             CMP      R6,#+0
   \   00000062   0xD100             BNE.N    ??f_mkdir_3
   \   00000064   0x2507             MOVS     R5,#+7
   3275          			if (dcl == 1) res = FR_INT_ERR;
   \                     ??f_mkdir_3:
   \   00000066   0x2E01             CMP      R6,#+1
   \   00000068   0xD100             BNE.N    ??f_mkdir_4
   \   0000006A   0x2502             MOVS     R5,#+2
   3276          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \                     ??f_mkdir_4:
   \   0000006C   0xF116 0x0F01      CMN      R6,#+1
   \   00000070   0xD100             BNE.N    ??f_mkdir_5
   \   00000072   0x2501             MOVS     R5,#+1
   3277          			if (res == FR_OK)					/* Flush FAT */
   \                     ??f_mkdir_5:
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD104             BNE.N    ??f_mkdir_6
   3278          				res = move_window(dj.fs, 0);
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x.... 0x....      BL       move_window
   \   00000082   0x0005             MOVS     R5,R0
   3279          			if (res == FR_OK) {					/* Initialize the new directory table */
   \                     ??f_mkdir_6:
   \   00000084   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000086   0x2D00             CMP      R5,#+0
   \   00000088   0xD175             BNE.N    ??f_mkdir_7
   3280          				dsc = clust2sect(dj.fs, dcl);
   \   0000008A   0x0031             MOVS     R1,R6
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0x.... 0x....      BL       clust2sect
   \   00000092   0x0007             MOVS     R7,R0
   3281          				dir = dj.fs->win;
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0xF200 0x0834      ADDW     R8,R0,#+52
   3282          				mem_set(dir, 0, SS(dj.fs));
   \   0000009A   0xF44F 0x7200      MOV      R2,#+512
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0x4640             MOV      R0,R8
   \   000000A2   0x.... 0x....      BL       mem_set
   3283          				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
   \   000000A6   0x220B             MOVS     R2,#+11
   \   000000A8   0x2120             MOVS     R1,#+32
   \   000000AA   0x4640             MOV      R0,R8
   \   000000AC   0x.... 0x....      BL       mem_set
   3284          				dir[DIR_Name] = '.';
   \   000000B0   0x202E             MOVS     R0,#+46
   \   000000B2   0xF888 0x0000      STRB     R0,[R8, #+0]
   3285          				dir[DIR_Attr] = AM_DIR;
   \   000000B6   0x2010             MOVS     R0,#+16
   \   000000B8   0xF888 0x000B      STRB     R0,[R8, #+11]
   3286          				ST_DWORD(dir+DIR_WrtTime, tim);
   \   000000BC   0xF888 0x4016      STRB     R4,[R8, #+22]
   \   000000C0   0x0020             MOVS     R0,R4
   \   000000C2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C4   0x0A00             LSRS     R0,R0,#+8
   \   000000C6   0xF888 0x0017      STRB     R0,[R8, #+23]
   \   000000CA   0x0C20             LSRS     R0,R4,#+16
   \   000000CC   0xF888 0x0018      STRB     R0,[R8, #+24]
   \   000000D0   0x0E20             LSRS     R0,R4,#+24
   \   000000D2   0xF888 0x0019      STRB     R0,[R8, #+25]
   3287          				ST_CLUST(dir, dcl);
   \   000000D6   0xF888 0x601A      STRB     R6,[R8, #+26]
   \   000000DA   0x0030             MOVS     R0,R6
   \   000000DC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DE   0x0A00             LSRS     R0,R0,#+8
   \   000000E0   0xF888 0x001B      STRB     R0,[R8, #+27]
   \   000000E4   0x0C30             LSRS     R0,R6,#+16
   \   000000E6   0xF888 0x0014      STRB     R0,[R8, #+20]
   \   000000EA   0x0C30             LSRS     R0,R6,#+16
   \   000000EC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000EE   0x0A00             LSRS     R0,R0,#+8
   \   000000F0   0xF888 0x0015      STRB     R0,[R8, #+21]
   3288          				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
   \   000000F4   0x2220             MOVS     R2,#+32
   \   000000F6   0x4641             MOV      R1,R8
   \   000000F8   0xF118 0x0020      ADDS     R0,R8,#+32
   \   000000FC   0x.... 0x....      BL       mem_cpy
   3289          				dir[33] = '.'; pcl = dj.sclust;
   \   00000100   0x202E             MOVS     R0,#+46
   \   00000102   0xF888 0x0021      STRB     R0,[R8, #+33]
   \   00000106   0x9802             LDR      R0,[SP, #+8]
   3290          				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   00000108   0x9900             LDR      R1,[SP, #+0]
   \   0000010A   0x7809             LDRB     R1,[R1, #+0]
   \   0000010C   0x2903             CMP      R1,#+3
   \   0000010E   0xD104             BNE.N    ??f_mkdir_8
   \   00000110   0x9900             LDR      R1,[SP, #+0]
   \   00000112   0x6A89             LDR      R1,[R1, #+40]
   \   00000114   0x4288             CMP      R0,R1
   \   00000116   0xD100             BNE.N    ??f_mkdir_8
   3291          					pcl = 0;
   \   00000118   0x2000             MOVS     R0,#+0
   3292          				ST_CLUST(dir+SZ_DIR, pcl);
   \                     ??f_mkdir_8:
   \   0000011A   0xF888 0x003A      STRB     R0,[R8, #+58]
   \   0000011E   0x0001             MOVS     R1,R0
   \   00000120   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000122   0x0A09             LSRS     R1,R1,#+8
   \   00000124   0xF888 0x103B      STRB     R1,[R8, #+59]
   \   00000128   0x0C01             LSRS     R1,R0,#+16
   \   0000012A   0xF888 0x1034      STRB     R1,[R8, #+52]
   \   0000012E   0x0C00             LSRS     R0,R0,#+16
   \   00000130   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000132   0x0A00             LSRS     R0,R0,#+8
   \   00000134   0xF888 0x0035      STRB     R0,[R8, #+53]
   3293          				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   \   00000138   0x9800             LDR      R0,[SP, #+0]
   \   0000013A   0xF890 0x9002      LDRB     R9,[R0, #+2]
   \   0000013E   0xE007             B.N      ??f_mkdir_9
   3294          					dj.fs->winsect = dsc++;
   3295          					dj.fs->wflag = 1;
   3296          					res = move_window(dj.fs, 0);
   3297          					if (res != FR_OK) break;
   3298          					mem_set(dir, 0, SS(dj.fs));
   \                     ??f_mkdir_10:
   \   00000140   0xF44F 0x7200      MOV      R2,#+512
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0x4640             MOV      R0,R8
   \   00000148   0x.... 0x....      BL       mem_set
   \   0000014C   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \                     ??f_mkdir_9:
   \   00000150   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000154   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000158   0xD00D             BEQ.N    ??f_mkdir_7
   \   0000015A   0x9800             LDR      R0,[SP, #+0]
   \   0000015C   0x6307             STR      R7,[R0, #+48]
   \   0000015E   0x1C7F             ADDS     R7,R7,#+1
   \   00000160   0x9800             LDR      R0,[SP, #+0]
   \   00000162   0x2101             MOVS     R1,#+1
   \   00000164   0x7101             STRB     R1,[R0, #+4]
   \   00000166   0x2100             MOVS     R1,#+0
   \   00000168   0x9800             LDR      R0,[SP, #+0]
   \   0000016A   0x.... 0x....      BL       move_window
   \   0000016E   0x0005             MOVS     R5,R0
   \   00000170   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000172   0x2D00             CMP      R5,#+0
   \   00000174   0xD0E4             BEQ.N    ??f_mkdir_10
   3299          				}
   3300          			}
   3301          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   \                     ??f_mkdir_7:
   \   00000176   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000178   0x2D00             CMP      R5,#+0
   \   0000017A   0xD103             BNE.N    ??f_mkdir_11
   \   0000017C   0xA800             ADD      R0,SP,#+0
   \   0000017E   0x.... 0x....      BL       dir_register
   \   00000182   0x0005             MOVS     R5,R0
   3302          			if (res != FR_OK) {
   \                     ??f_mkdir_11:
   \   00000184   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000186   0x2D00             CMP      R5,#+0
   \   00000188   0xD004             BEQ.N    ??f_mkdir_12
   3303          				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   \   0000018A   0x0031             MOVS     R1,R6
   \   0000018C   0x9800             LDR      R0,[SP, #+0]
   \   0000018E   0x.... 0x....      BL       remove_chain
   \   00000192   0xE027             B.N      ??f_mkdir_0
   3304          			} else {
   3305          				dir = dj.dir;
   \                     ??f_mkdir_12:
   \   00000194   0xF8DD 0x8014      LDR      R8,[SP, #+20]
   3306          				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   \   00000198   0x2010             MOVS     R0,#+16
   \   0000019A   0xF888 0x000B      STRB     R0,[R8, #+11]
   3307          				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
   \   0000019E   0xF888 0x4016      STRB     R4,[R8, #+22]
   \   000001A2   0x0020             MOVS     R0,R4
   \   000001A4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001A6   0x0A00             LSRS     R0,R0,#+8
   \   000001A8   0xF888 0x0017      STRB     R0,[R8, #+23]
   \   000001AC   0x0C20             LSRS     R0,R4,#+16
   \   000001AE   0xF888 0x0018      STRB     R0,[R8, #+24]
   \   000001B2   0x0E20             LSRS     R0,R4,#+24
   \   000001B4   0xF888 0x0019      STRB     R0,[R8, #+25]
   3308          				ST_CLUST(dir, dcl);					/* Table start cluster */
   \   000001B8   0xF888 0x601A      STRB     R6,[R8, #+26]
   \   000001BC   0x0030             MOVS     R0,R6
   \   000001BE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001C0   0x0A00             LSRS     R0,R0,#+8
   \   000001C2   0xF888 0x001B      STRB     R0,[R8, #+27]
   \   000001C6   0x0C30             LSRS     R0,R6,#+16
   \   000001C8   0xF888 0x0014      STRB     R0,[R8, #+20]
   \   000001CC   0x0C30             LSRS     R0,R6,#+16
   \   000001CE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001D0   0x0A00             LSRS     R0,R0,#+8
   \   000001D2   0xF888 0x0015      STRB     R0,[R8, #+21]
   3309          				dj.fs->wflag = 1;
   \   000001D6   0x9800             LDR      R0,[SP, #+0]
   \   000001D8   0x2101             MOVS     R1,#+1
   \   000001DA   0x7101             STRB     R1,[R0, #+4]
   3310          				res = sync(dj.fs);
   \   000001DC   0x9800             LDR      R0,[SP, #+0]
   \   000001DE   0x.... 0x....      BL       sync
   \   000001E2   0x0005             MOVS     R5,R0
   3311          			}
   3312          		}
   3313          		FREE_BUF();
   3314          	}
   3315          
   3316          	LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_0:
   \   000001E4   0x0028             MOVS     R0,R5
   \   000001E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001E8   0xB00D             ADD      SP,SP,#+52
   \   000001EA   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   3317          }
   3318          
   3319          
   3320          
   3321          
   3322          /*-----------------------------------------------------------------------*/
   3323          /* Change Attribute                                                      */
   3324          /*-----------------------------------------------------------------------*/
   3325          

   \                                 In section .text, align 2, keep-with-next
   3326          FRESULT f_chmod (
   3327          	const TCHAR *path,	/* Pointer to the file path */
   3328          	BYTE value,			/* Attribute bits */
   3329          	BYTE mask			/* Attribute mask to change */
   3330          )
   3331          {
   \                     f_chmod:
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
   3332          	FRESULT res;
   3333          	DIR dj;
   3334          	BYTE *dir;
   3335          	DEF_NAMEBUF;
   3336          
   3337          
   3338          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0xA80C             ADD      R0,SP,#+48
   \   0000000E   0x.... 0x....      BL       chk_mounted
   3339          	if (res == FR_OK) {
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD125             BNE.N    ??f_chmod_0
   3340          		INIT_BUF(dj);
   \   00000018   0xA809             ADD      R0,SP,#+36
   \   0000001A   0x9006             STR      R0,[SP, #+24]
   \   0000001C   0x....             LDR.N    R0,??DataTable17
   \   0000001E   0x9007             STR      R0,[SP, #+28]
   3341          		res = follow_path(&dj, path);		/* Follow the file path */
   \   00000020   0x990C             LDR      R1,[SP, #+48]
   \   00000022   0xA800             ADD      R0,SP,#+0
   \   00000024   0x.... 0x....      BL       follow_path
   3342          		FREE_BUF();
   3343          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD104             BNE.N    ??f_chmod_1
   \   0000002E   0x9906             LDR      R1,[SP, #+24]
   \   00000030   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000032   0x0689             LSLS     R1,R1,#+26
   \   00000034   0xD500             BPL.N    ??f_chmod_1
   3344          			res = FR_INVALID_NAME;
   \   00000036   0x2006             MOVS     R0,#+6
   3345          		if (res == FR_OK) {
   \                     ??f_chmod_1:
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD112             BNE.N    ??f_chmod_0
   3346          			dir = dj.dir;
   \   0000003E   0x9805             LDR      R0,[SP, #+20]
   3347          			if (!dir) {						/* Is it a root directory? */
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD101             BNE.N    ??f_chmod_2
   3348          				res = FR_INVALID_NAME;
   \   00000044   0x2006             MOVS     R0,#+6
   \   00000046   0xE00D             B.N      ??f_chmod_0
   3349          			} else {						/* File or sub directory */
   3350          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_2:
   \   00000048   0xF015 0x0527      ANDS     R5,R5,#0x27
   3351          				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   \   0000004C   0xEA15 0x0104      ANDS     R1,R5,R4
   \   00000050   0x7AC2             LDRB     R2,[R0, #+11]
   \   00000052   0x43AA             BICS     R2,R2,R5
   \   00000054   0x4311             ORRS     R1,R2,R1
   \   00000056   0x72C1             STRB     R1,[R0, #+11]
   3352          				dj.fs->wflag = 1;
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0x7101             STRB     R1,[R0, #+4]
   3353          				res = sync(dj.fs);
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   \   00000060   0x.... 0x....      BL       sync
   3354          			}
   3355          		}
   3356          	}
   3357          
   3358          	LEAVE_FF(dj.fs, res);
   \                     ??f_chmod_0:
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xB00D             ADD      SP,SP,#+52
   \   00000068   0xBD30             POP      {R4,R5,PC}       ;; return
   3359          }
   3360          
   3361          
   3362          
   3363          
   3364          /*-----------------------------------------------------------------------*/
   3365          /* Change Timestamp                                                      */
   3366          /*-----------------------------------------------------------------------*/
   3367          

   \                                 In section .text, align 2, keep-with-next
   3368          FRESULT f_utime (
   3369          	const TCHAR *path,	/* Pointer to the file/directory name */
   3370          	const FILINFO *fno	/* Pointer to the time stamp to be set */
   3371          )
   3372          {
   \                     f_utime:
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x000C             MOVS     R4,R1
   3373          	FRESULT res;
   3374          	DIR dj;
   3375          	BYTE *dir;
   3376          	DEF_NAMEBUF;
   3377          
   3378          
   3379          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0xA80D             ADD      R0,SP,#+52
   \   0000000C   0x.... 0x....      BL       chk_mounted
   3380          	if (res == FR_OK) {
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD129             BNE.N    ??f_utime_0
   3381          		INIT_BUF(dj);
   \   00000016   0xA809             ADD      R0,SP,#+36
   \   00000018   0x9006             STR      R0,[SP, #+24]
   \   0000001A   0x....             LDR.N    R0,??DataTable17
   \   0000001C   0x9007             STR      R0,[SP, #+28]
   3382          		res = follow_path(&dj, path);	/* Follow the file path */
   \   0000001E   0x990D             LDR      R1,[SP, #+52]
   \   00000020   0xA800             ADD      R0,SP,#+0
   \   00000022   0x.... 0x....      BL       follow_path
   3383          		FREE_BUF();
   3384          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD104             BNE.N    ??f_utime_1
   \   0000002C   0x9906             LDR      R1,[SP, #+24]
   \   0000002E   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000030   0x0689             LSLS     R1,R1,#+26
   \   00000032   0xD500             BPL.N    ??f_utime_1
   3385          			res = FR_INVALID_NAME;
   \   00000034   0x2006             MOVS     R0,#+6
   3386          		if (res == FR_OK) {
   \                     ??f_utime_1:
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD116             BNE.N    ??f_utime_0
   3387          			dir = dj.dir;
   \   0000003C   0x9805             LDR      R0,[SP, #+20]
   3388          			if (!dir) {					/* Root directory */
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD101             BNE.N    ??f_utime_2
   3389          				res = FR_INVALID_NAME;
   \   00000042   0x2006             MOVS     R0,#+6
   \   00000044   0xE011             B.N      ??f_utime_0
   3390          			} else {					/* File or sub-directory */
   3391          				ST_WORD(dir+DIR_WrtTime, fno->ftime);
   \                     ??f_utime_2:
   \   00000046   0x88E1             LDRH     R1,[R4, #+6]
   \   00000048   0x7581             STRB     R1,[R0, #+22]
   \   0000004A   0x88E1             LDRH     R1,[R4, #+6]
   \   0000004C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004E   0x0A09             LSRS     R1,R1,#+8
   \   00000050   0x75C1             STRB     R1,[R0, #+23]
   3392          				ST_WORD(dir+DIR_WrtDate, fno->fdate);
   \   00000052   0x88A1             LDRH     R1,[R4, #+4]
   \   00000054   0x7601             STRB     R1,[R0, #+24]
   \   00000056   0x88A1             LDRH     R1,[R4, #+4]
   \   00000058   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005A   0x0A09             LSRS     R1,R1,#+8
   \   0000005C   0x7641             STRB     R1,[R0, #+25]
   3393          				dj.fs->wflag = 1;
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x7101             STRB     R1,[R0, #+4]
   3394          				res = sync(dj.fs);
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x.... 0x....      BL       sync
   3395          			}
   3396          		}
   3397          	}
   3398          
   3399          	LEAVE_FF(dj.fs, res);
   \                     ??f_utime_0:
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0xB00E             ADD      SP,SP,#+56
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
   3400          }
   3401          
   3402          
   3403          
   3404          
   3405          /*-----------------------------------------------------------------------*/
   3406          /* Rename File/Directory                                                 */
   3407          /*-----------------------------------------------------------------------*/
   3408          

   \                                 In section .text, align 2, keep-with-next
   3409          FRESULT f_rename (
   3410          	const TCHAR *path_old,	/* Pointer to the old name */
   3411          	const TCHAR *path_new	/* Pointer to the new name */
   3412          )
   3413          {
   \                     f_rename:
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB09C             SUB      SP,SP,#+112
   \   00000004   0x000C             MOVS     R4,R1
   3414          	FRESULT res;
   3415          	DIR djo, djn;
   3416          	BYTE buf[21], *dir;
   3417          	DWORD dw;
   3418          	DEF_NAMEBUF;
   3419          
   3420          
   3421          	res = chk_mounted(&path_old, &djo.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA909             ADD      R1,SP,#+36
   \   0000000A   0xA81C             ADD      R0,SP,#+112
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0005             MOVS     R5,R0
   3422          	if (res == FR_OK) {
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xF040 0x809B      BNE.W    ??f_rename_0
   3423          		djn.fs = djo.fs;
   \   0000001A   0x9809             LDR      R0,[SP, #+36]
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   3424          		INIT_BUF(djo);
   \   0000001E   0xA812             ADD      R0,SP,#+72
   \   00000020   0x900F             STR      R0,[SP, #+60]
   \   00000022   0x....             LDR.N    R0,??DataTable17
   \   00000024   0x9010             STR      R0,[SP, #+64]
   3425          		res = follow_path(&djo, path_old);		/* Check old object */
   \   00000026   0x991C             LDR      R1,[SP, #+112]
   \   00000028   0xA809             ADD      R0,SP,#+36
   \   0000002A   0x.... 0x....      BL       follow_path
   \   0000002E   0x0005             MOVS     R5,R0
   3426          		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD104             BNE.N    ??f_rename_1
   \   00000036   0x980F             LDR      R0,[SP, #+60]
   \   00000038   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000003A   0x0680             LSLS     R0,R0,#+26
   \   0000003C   0xD500             BPL.N    ??f_rename_1
   3427          			res = FR_INVALID_NAME;
   \   0000003E   0x2506             MOVS     R5,#+6
   3428          #if _FS_SHARE
   3429          		if (res == FR_OK) res = chk_lock(&djo, 2);
   3430          #endif
   3431          		if (res == FR_OK) {						/* Old object is found */
   \                     ??f_rename_1:
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xF040 0x8084      BNE.W    ??f_rename_0
   3432          			if (!djo.dir) {						/* Is root dir? */
   \   00000048   0x980E             LDR      R0,[SP, #+56]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD101             BNE.N    ??f_rename_2
   3433          				res = FR_NO_FILE;
   \   0000004E   0x2504             MOVS     R5,#+4
   \   00000050   0xE07E             B.N      ??f_rename_0
   3434          			} else {
   3435          				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
   \                     ??f_rename_2:
   \   00000052   0x2215             MOVS     R2,#+21
   \   00000054   0x980E             LDR      R0,[SP, #+56]
   \   00000056   0xF110 0x010B      ADDS     R1,R0,#+11
   \   0000005A   0xA815             ADD      R0,SP,#+84
   \   0000005C   0x.... 0x....      BL       mem_cpy
   3436          				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
   \   00000060   0x2224             MOVS     R2,#+36
   \   00000062   0xA909             ADD      R1,SP,#+36
   \   00000064   0xA800             ADD      R0,SP,#+0
   \   00000066   0x.... 0x....      BL       mem_cpy
   3437          				res = follow_path(&djn, path_new);
   \   0000006A   0x0021             MOVS     R1,R4
   \   0000006C   0xA800             ADD      R0,SP,#+0
   \   0000006E   0x.... 0x....      BL       follow_path
   \   00000072   0x0005             MOVS     R5,R0
   3438          				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD100             BNE.N    ??f_rename_3
   \   0000007A   0x2508             MOVS     R5,#+8
   3439          				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
   \                     ??f_rename_3:
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0x2D04             CMP      R5,#+4
   \   00000080   0xD166             BNE.N    ??f_rename_0
   3440          /* Start critical section that any interruption or error can cause cross-link */
   3441          					res = dir_register(&djn);			/* Register the new entry */
   \   00000082   0xA800             ADD      R0,SP,#+0
   \   00000084   0x.... 0x....      BL       dir_register
   \   00000088   0x0005             MOVS     R5,R0
   3442          					if (res == FR_OK) {
   \   0000008A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008C   0x2D00             CMP      R5,#+0
   \   0000008E   0xD15F             BNE.N    ??f_rename_0
   3443          						dir = djn.dir;					/* Copy object information except for name */
   \   00000090   0x9C05             LDR      R4,[SP, #+20]
   3444          						mem_cpy(dir+13, buf+2, 19);
   \   00000092   0x2213             MOVS     R2,#+19
   \   00000094   0xF10D 0x0156      ADD      R1,SP,#+86
   \   00000098   0xF114 0x000D      ADDS     R0,R4,#+13
   \   0000009C   0x.... 0x....      BL       mem_cpy
   3445          						dir[DIR_Attr] = buf[0] | AM_ARC;
   \   000000A0   0xF89D 0x0054      LDRB     R0,[SP, #+84]
   \   000000A4   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000A8   0x72E0             STRB     R0,[R4, #+11]
   3446          						djo.fs->wflag = 1;
   \   000000AA   0x9809             LDR      R0,[SP, #+36]
   \   000000AC   0x2101             MOVS     R1,#+1
   \   000000AE   0x7101             STRB     R1,[R0, #+4]
   3447          						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
   \   000000B0   0x980B             LDR      R0,[SP, #+44]
   \   000000B2   0x9902             LDR      R1,[SP, #+8]
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xD03D             BEQ.N    ??f_rename_4
   \   000000B8   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000BA   0x06C0             LSLS     R0,R0,#+27
   \   000000BC   0xD53A             BPL.N    ??f_rename_4
   3448          							dw = clust2sect(djn.fs, LD_CLUST(dir));
   \   000000BE   0x7D60             LDRB     R0,[R4, #+21]
   \   000000C0   0x7D21             LDRB     R1,[R4, #+20]
   \   000000C2   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000C6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C8   0x7EE1             LDRB     R1,[R4, #+27]
   \   000000CA   0x7EA2             LDRB     R2,[R4, #+26]
   \   000000CC   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   000000D0   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D2   0xEA51 0x4100      ORRS     R1,R1,R0, LSL #+16
   \   000000D6   0x9800             LDR      R0,[SP, #+0]
   \   000000D8   0x.... 0x....      BL       clust2sect
   3449          							if (!dw) {
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD101             BNE.N    ??f_rename_5
   3450          								res = FR_INT_ERR;
   \   000000E0   0x2502             MOVS     R5,#+2
   \   000000E2   0xE027             B.N      ??f_rename_4
   3451          							} else {
   3452          								res = move_window(djn.fs, dw);
   \                     ??f_rename_5:
   \   000000E4   0x0001             MOVS     R1,R0
   \   000000E6   0x9800             LDR      R0,[SP, #+0]
   \   000000E8   0x.... 0x....      BL       move_window
   \   000000EC   0x0005             MOVS     R5,R0
   3453          								dir = djn.fs->win+SZ_DIR;	/* .. entry */
   \   000000EE   0x9800             LDR      R0,[SP, #+0]
   \   000000F0   0xF200 0x0454      ADDW     R4,R0,#+84
   3454          								if (res == FR_OK && dir[1] == '.') {
   \   000000F4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F6   0x2D00             CMP      R5,#+0
   \   000000F8   0xD11C             BNE.N    ??f_rename_4
   \   000000FA   0x7860             LDRB     R0,[R4, #+1]
   \   000000FC   0x282E             CMP      R0,#+46
   \   000000FE   0xD119             BNE.N    ??f_rename_4
   3455          									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
   \   00000100   0x9800             LDR      R0,[SP, #+0]
   \   00000102   0x7800             LDRB     R0,[R0, #+0]
   \   00000104   0x2803             CMP      R0,#+3
   \   00000106   0xD106             BNE.N    ??f_rename_6
   \   00000108   0x9802             LDR      R0,[SP, #+8]
   \   0000010A   0x9900             LDR      R1,[SP, #+0]
   \   0000010C   0x6A89             LDR      R1,[R1, #+40]
   \   0000010E   0x4288             CMP      R0,R1
   \   00000110   0xD101             BNE.N    ??f_rename_6
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xE000             B.N      ??f_rename_7
   \                     ??f_rename_6:
   \   00000116   0x9802             LDR      R0,[SP, #+8]
   3456          									ST_CLUST(dir, dw);
   \                     ??f_rename_7:
   \   00000118   0x76A0             STRB     R0,[R4, #+26]
   \   0000011A   0x0001             MOVS     R1,R0
   \   0000011C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000011E   0x0A09             LSRS     R1,R1,#+8
   \   00000120   0x76E1             STRB     R1,[R4, #+27]
   \   00000122   0x0C01             LSRS     R1,R0,#+16
   \   00000124   0x7521             STRB     R1,[R4, #+20]
   \   00000126   0x0C00             LSRS     R0,R0,#+16
   \   00000128   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000012A   0x0A00             LSRS     R0,R0,#+8
   \   0000012C   0x7560             STRB     R0,[R4, #+21]
   3457          									djn.fs->wflag = 1;
   \   0000012E   0x9800             LDR      R0,[SP, #+0]
   \   00000130   0x2101             MOVS     R1,#+1
   \   00000132   0x7101             STRB     R1,[R0, #+4]
   3458          								}
   3459          							}
   3460          						}
   3461          						if (res == FR_OK) {
   \                     ??f_rename_4:
   \   00000134   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000136   0x2D00             CMP      R5,#+0
   \   00000138   0xD10A             BNE.N    ??f_rename_0
   3462          							res = dir_remove(&djo);		/* Remove old entry */
   \   0000013A   0xA809             ADD      R0,SP,#+36
   \   0000013C   0x.... 0x....      BL       dir_remove
   \   00000140   0x0005             MOVS     R5,R0
   3463          							if (res == FR_OK)
   \   00000142   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000144   0x2D00             CMP      R5,#+0
   \   00000146   0xD103             BNE.N    ??f_rename_0
   3464          								res = sync(djo.fs);
   \   00000148   0x9809             LDR      R0,[SP, #+36]
   \   0000014A   0x.... 0x....      BL       sync
   \   0000014E   0x0005             MOVS     R5,R0
   3465          						}
   3466          					}
   3467          /* End critical section */
   3468          				}
   3469          			}
   3470          		}
   3471          		FREE_BUF();
   3472          	}
   3473          	LEAVE_FF(djo.fs, res);
   \                     ??f_rename_0:
   \   00000150   0x0028             MOVS     R0,R5
   \   00000152   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000154   0xB01D             ADD      SP,SP,#+116
   \   00000156   0xBD30             POP      {R4,R5,PC}       ;; return
   3474          }
   3475          
   3476          #endif /* !_FS_READONLY */
   3477          #endif /* _FS_MINIMIZE == 0 */
   3478          #endif /* _FS_MINIMIZE <= 1 */
   3479          #endif /* _FS_MINIMIZE <= 2 */
   3480          
   3481          
   3482          
   3483          /*-----------------------------------------------------------------------*/
   3484          /* Forward data to the stream directly (available on only tiny cfg)      */
   3485          /*-----------------------------------------------------------------------*/
   3486          #if _USE_FORWARD && _FS_TINY
   3487          
   3488          FRESULT f_forward (
   3489          	FIL *fp, 						/* Pointer to the file object */
   3490          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   3491          	UINT btr,						/* Number of bytes to forward */
   3492          	UINT *bf						/* Pointer to number of bytes forwarded */
   3493          )
   3494          {
   3495          	FRESULT res;
   3496          	DWORD remain, clst, sect;
   3497          	UINT rcnt;
   3498          	BYTE csect;
   3499          
   3500          
   3501          	*bf = 0;	/* Initialize byte counter */
   3502          
   3503          	res = validate(fp->fs, fp->id);					/* Check validity of the object */
   3504          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   3505          	if (fp->flag & FA__ERROR)						/* Check error flag */
   3506          		LEAVE_FF(fp->fs, FR_INT_ERR);
   3507          	if (!(fp->flag & FA_READ))						/* Check access mode */
   3508          		LEAVE_FF(fp->fs, FR_DENIED);
   3509          
   3510          	remain = fp->fsize - fp->fptr;
   3511          	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
   3512          
   3513          	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   3514          		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
   3515          		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   3516          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   3517          			if (!csect) {							/* On the cluster boundary? */
   3518          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   3519          					fp->sclust : get_fat(fp->fs, fp->clust);
   3520          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   3521          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3522          				fp->clust = clst;					/* Update current cluster */
   3523          			}
   3524          		}
   3525          		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
   3526          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3527          		sect += csect;
   3528          		if (move_window(fp->fs, sect))				/* Move sector window */
   3529          			ABORT(fp->fs, FR_DISK_ERR);
   3530          		fp->dsect = sect;
   3531          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   3532          		if (rcnt > btr) rcnt = btr;
   3533          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   3534          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   3535          	}
   3536          
   3537          	LEAVE_FF(fp->fs, FR_OK);
   3538          }
   3539          #endif /* _USE_FORWARD */
   3540          
   3541          
   3542          
   3543          #if _USE_MKFS && !_FS_READONLY
   3544          /*-----------------------------------------------------------------------*/
   3545          /* Create File System on the Drive                                       */
   3546          /*-----------------------------------------------------------------------*/
   3547          #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
   3548          #define N_FATS		1		/* Number of FAT copies (1 or 2) */
   3549          
   3550          
   3551          FRESULT f_mkfs (
   3552          	BYTE drv,		/* Logical drive number */
   3553          	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
   3554          	UINT au			/* Allocation unit size [bytes] */
   3555          )
   3556          {
   3557          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   3558          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   3559          	BYTE fmt, md, *tbl;
   3560          	DWORD n_clst, vs, n, wsect;
   3561          	UINT i;
   3562          	DWORD b_vol, b_fat, b_dir, b_data;	/* Offset (LBA) */
   3563          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   3564          	FATFS *fs;
   3565          	DSTATUS stat;
   3566          
   3567          
   3568          	/* Check mounted drive and clear work area */
   3569          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   3570          	fs = FatFs[drv];
   3571          	if (!fs) return FR_NOT_ENABLED;
   3572          	fs->fs_type = 0;
   3573          	drv = LD2PD(drv);
   3574          
   3575          	/* Get disk statics */
   3576          	stat = disk_initialize(drv);
   3577          	if (stat & STA_NOINIT) return FR_NOT_READY;
   3578          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   3579          #if _MAX_SS != 512					/* Get disk sector size */
   3580          	if (disk_ioctl(drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK)
   3581          		return FR_DISK_ERR;
   3582          #endif
   3583          	if (disk_ioctl(drv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
   3584          		return FR_DISK_ERR;
   3585          	b_vol = (sfd) ? 0 : 63;	/* Volume start sector */
   3586          	n_vol -= b_vol;
   3587          	if (au & (au - 1)) au = 0;	/* Check validity of the AU size */
   3588          	if (!au) {					/* AU auto selection */
   3589          		vs = n_vol / (2000 / (SS(fs) / 512));
   3590          		for (i = 0; vs < vst[i]; i++) ;
   3591          		au = cst[i];
   3592          	}
   3593          	au /= SS(fs);		/* Number of sectors per cluster */
   3594          	if (au == 0) au = 1;
   3595          	if (au > 128) au = 128;
   3596          
   3597          	/* Pre-compute number of clusters and FAT syb-type */
   3598          	n_clst = n_vol / au;
   3599          	fmt = FS_FAT12;
   3600          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   3601          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   3602          
   3603          	/* Determine offset and size of FAT structure */
   3604          	if (fmt == FS_FAT32) {
   3605          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   3606          		n_rsv = 32;
   3607          		n_dir = 0;
   3608          	} else {
   3609          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   3610          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   3611          		n_rsv = 1;
   3612          		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
   3613          	}
   3614          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   3615          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   3616          	b_data = b_dir + n_dir;				/* Data area start sector */
   3617          	if (n_vol < b_data + au) return FR_MKFS_ABORTED;	/* Too small volume */
   3618          
   3619          	/* Align data start sector to erase block boundary (for flash memory media) */
   3620          	if (disk_ioctl(drv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   3621          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   3622          	n = (n - b_data) / N_FATS;
   3623          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   3624          		n_rsv += n;
   3625          		b_fat += n;
   3626          	} else {					/* FAT12/16: Expand FAT size */
   3627          		n_fat += n;
   3628          	}
   3629          
   3630          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   3631          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   3632          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   3633          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   3634          		return FR_MKFS_ABORTED;
   3635          
   3636          	/* Create partition table if required */
   3637          	if (sfd) {	/* No patition table (SFD) */
   3638          		md = 0xF0;
   3639          	} else {	/* With patition table (FDISK) */
   3640          		DWORD n_disk = b_vol + n_vol;
   3641          
   3642          		mem_set(fs->win, 0, SS(fs));
   3643          		tbl = fs->win+MBR_Table;
   3644          		ST_DWORD(tbl, 0x00010180);			/* Partition start in CHS */
   3645          		if (n_disk < 63UL * 255 * 1024) {	/* Partition end in CHS */
   3646          			n_disk = n_disk / 63 / 255;
   3647          			tbl[7] = (BYTE)n_disk;
   3648          			tbl[6] = (BYTE)((n_disk >> 2) | 63);
   3649          		} else {
   3650          			ST_WORD(&tbl[6], 0xFFFF);	/* CHS saturated */
   3651          		}
   3652          		tbl[5] = 254;
   3653          		if (fmt != FS_FAT32)				/* System ID */
   3654          			tbl[4] = (n_vol < 0x10000) ? 0x04 : 0x06;
   3655          		else
   3656          			tbl[4] = 0x0c;
   3657          		ST_DWORD(tbl+8, 63);				/* Partition start in LBA */
   3658          		ST_DWORD(tbl+12, n_vol);			/* Partition size in LBA */
   3659          		ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
   3660          		if (disk_write(drv, fs->win, 0, 1) != RES_OK)	/* Put the MBR into first physical sector */
   3661          			return FR_DISK_ERR;
   3662          		md = 0xF8;
   3663          	}
   3664          
   3665          	/* Create volume boot record */
   3666          	tbl = fs->win;							/* Clear sector */
   3667          	mem_set(tbl, 0, SS(fs));
   3668          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   3669          	i = SS(fs);								/* Sector size */
   3670          	ST_WORD(tbl+BPB_BytsPerSec, i);
   3671          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   3672          	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
   3673          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   3674          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
   3675          	ST_WORD(tbl+BPB_RootEntCnt, i);
   3676          	if (n_vol < 0x10000) {					/* Number of total sectors */
   3677          		ST_WORD(tbl+BPB_TotSec16, n_vol);
   3678          	} else {
   3679          		ST_DWORD(tbl+BPB_TotSec32, n_vol);
   3680          	}
   3681          	tbl[BPB_Media] = md;					/* Media descriptor */
   3682          	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
   3683          	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
   3684          	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
   3685          	n = get_fattime();						/* Use current time as VSN */
   3686          	if (fmt == FS_FAT32) {
   3687          		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
   3688          		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   3689          		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
   3690          		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
   3691          		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
   3692          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   3693          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   3694          		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   3695          	} else {
   3696          		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
   3697          		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
   3698          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   3699          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   3700          		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   3701          	}
   3702          	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   3703          	if (disk_write(drv, tbl, b_vol, 1) != RES_OK)	/* Write VBR */
   3704          		return FR_DISK_ERR;
   3705          	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
   3706          		disk_write(drv, tbl, b_vol + 6, 1);
   3707          
   3708          	/* Initialize FAT area */
   3709          	wsect = b_fat;
   3710          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   3711          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   3712          		n = md;								/* Media descriptor byte */
   3713          		if (fmt != FS_FAT32) {
   3714          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   3715          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
   3716          		} else {
   3717          			n |= 0xFFFFFF00;
   3718          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
   3719          			ST_DWORD(tbl+4, 0xFFFFFFFF);
   3720          			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
   3721          		}
   3722          		if (disk_write(drv, tbl, wsect++, 1) != RES_OK)
   3723          			return FR_DISK_ERR;
   3724          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   3725          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   3726          			if (disk_write(drv, tbl, wsect++, 1) != RES_OK)
   3727          				return FR_DISK_ERR;
   3728          		}
   3729          	}
   3730          
   3731          	/* Initialize root directory */
   3732          	i = (fmt == FS_FAT32) ? au : n_dir;
   3733          	do {
   3734          		if (disk_write(drv, tbl, wsect++, 1) != RES_OK)
   3735          			return FR_DISK_ERR;
   3736          	} while (--i);
   3737          
   3738          #if _USE_ERASE	/* Erase data area if needed */
   3739          	{
   3740          		DWORD eb[2];
   3741          
   3742          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   3743          		disk_ioctl(drv, CTRL_ERASE_SECTOR, eb);
   3744          	}
   3745          #endif
   3746          
   3747          	/* Create FSInfo if needed */
   3748          	if (fmt == FS_FAT32) {
   3749          		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   3750          		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   3751          		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   3752          		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
   3753          		ST_WORD(tbl+BS_55AA, 0xAA55);
   3754          		disk_write(drv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
   3755          		disk_write(drv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
   3756          	}
   3757          
   3758          	return (disk_ioctl(drv, CTRL_SYNC, (void*)0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   3759          }
   3760          
   3761          #endif /* _USE_MKFS && !_FS_READONLY */
   3762          
   3763          
   3764          
   3765          
   3766          #if _USE_STRFUNC
   3767          /*-----------------------------------------------------------------------*/
   3768          /* Get a string from the file                                            */
   3769          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3770          TCHAR* f_gets (
   3771          	TCHAR* buff,	/* Pointer to the string buffer to read */
   3772          	int len,		/* Size of string buffer (characters) */
   3773          	FIL* fil		/* Pointer to the file object */
   3774          )
   3775          {
   \                     f_gets:
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4690             MOV      R8,R2
   3776          	int n = 0;
   \   0000000A   0x2500             MOVS     R5,#+0
   3777          	TCHAR c, *p = buff;
   \   0000000C   0x0026             MOVS     R6,R4
   3778          	BYTE s[2];
   3779          	UINT rc;
   3780          
   3781          
   3782          	while (n < len - 1) {			/* Read bytes until buffer gets filled */
   \                     ??f_gets_0:
   \   0000000E   0x1E78             SUBS     R0,R7,#+1
   \   00000010   0x4285             CMP      R5,R0
   \   00000012   0xDA10             BGE.N    ??f_gets_1
   3783          		f_read(fil, s, 1, &rc);
   \   00000014   0xAB00             ADD      R3,SP,#+0
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       f_read
   3784          		if (rc != 1) break;			/* Break on EOF or error */
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD107             BNE.N    ??f_gets_1
   3785          		c = s[0];
   \                     ??f_gets_2:
   \   00000026   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   3786          #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
   3787          		if (c >= 0x80) {
   3788          			if (c < 0xC0) continue;	/* Skip stray trailer */
   3789          			if (c < 0xE0) {			/* Two-byte sequense */
   3790          				f_read(fil, s, 1, &rc);
   3791          				if (rc != 1) break;
   3792          				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
   3793          				if (c < 0x80) c = '?';
   3794          			} else {
   3795          				if (c < 0xF0) {		/* Three-byte sequense */
   3796          					f_read(fil, s, 2, &rc);
   3797          					if (rc != 2) break;
   3798          					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
   3799          					if (c < 0x800) c = '?';
   3800          				} else {			/* Reject four-byte sequense */
   3801          					c = '?';
   3802          				}
   3803          			}
   3804          		}
   3805          #endif
   3806          #if _USE_STRFUNC >= 2
   3807          		if (c == '\r') continue;	/* Strip '\r' */
   3808          #endif
   3809          		*p++ = c;
   \   0000002A   0x7030             STRB     R0,[R6, #+0]
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   3810          		n++;
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   3811          		if (c == '\n') break;		/* Break on EOL */
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x280A             CMP      R0,#+10
   \   00000034   0xD1EB             BNE.N    ??f_gets_0
   3812          	}
   3813          	*p = 0;
   \                     ??f_gets_1:
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7030             STRB     R0,[R6, #+0]
   3814          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD100             BNE.N    ??f_gets_3
   \                     ??f_gets_4:
   \   0000003E   0x2400             MOVS     R4,#+0
   \                     ??f_gets_3:
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3815          }
   3816          
   3817          
   3818          
   3819          #if !_FS_READONLY
   3820          #include <stdarg.h>
   3821          /*-----------------------------------------------------------------------*/
   3822          /* Put a character to the file                                           */
   3823          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3824          int f_putc (
   3825          	TCHAR c,	/* A character to be output */
   3826          	FIL* fil	/* Pointer to the file object */
   3827          )
   3828          {
   \                     f_putc:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x000C             MOVS     R4,R1
   3829          	UINT bw, btw;
   3830          	BYTE s[3];
   3831          
   3832          
   3833          #if _USE_STRFUNC >= 2
   3834          	if (c == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
   3835          #endif
   3836          
   3837          #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
   3838          	if (c < 0x80) {			/* 7-bit */
   3839          		s[0] = (BYTE)c;
   3840          		btw = 1;
   3841          	} else {
   3842          		if (c < 0x800) {	/* 11-bit */
   3843          			s[0] = (BYTE)(0xC0 | (c >> 6));
   3844          			s[1] = (BYTE)(0x80 | (c & 0x3F));
   3845          			btw = 2;
   3846          		} else {			/* 16-bit */
   3847          			s[0] = (BYTE)(0xE0 | (c >> 12));
   3848          			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
   3849          			s[2] = (BYTE)(0x80 | (c & 0x3F));
   3850          			btw = 3;
   3851          		}
   3852          	}
   3853          #else				/* Write the character without conversion */
   3854          	s[0] = (BYTE)c;
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3855          	btw = 1;
   \   0000000A   0x2501             MOVS     R5,#+1
   3856          #endif
   3857          	f_write(fil, s, btw, &bw);		/* Write the char to the file */
   \   0000000C   0xAB01             ADD      R3,SP,#+4
   \   0000000E   0x002A             MOVS     R2,R5
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       f_write
   3858          	return (bw == btw) ? 1 : EOF;	/* Return the result */
   \   00000018   0x9801             LDR      R0,[SP, #+4]
   \   0000001A   0x42A8             CMP      R0,R5
   \   0000001C   0xD101             BNE.N    ??f_putc_0
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE001             B.N      ??f_putc_1
   \                     ??f_putc_0:
   \   00000022   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??f_putc_1:
   \   00000026   0xBD3E             POP      {R1-R5,PC}       ;; return
   3859          }
   3860          
   3861          
   3862          
   3863          
   3864          /*-----------------------------------------------------------------------*/
   3865          /* Put a string to the file                                              */
   3866          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3867          int f_puts (
   3868          	const TCHAR* str,	/* Pointer to the string to be output */
   3869          	FIL* fil			/* Pointer to the file object */
   3870          )
   3871          {
   \                     f_puts:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3872          	int n;
   3873          
   3874          
   3875          	for (n = 0; *str; str++, n++) {
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE001             B.N      ??f_puts_0
   \                     ??f_puts_1:
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
   \   0000000C   0x1C76             ADDS     R6,R6,#+1
   \                     ??f_puts_0:
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??f_puts_2
   3876          		if (f_putc(*str, fil) == EOF) return EOF;
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       f_putc
   \   0000001C   0xF110 0x0F01      CMN      R0,#+1
   \   00000020   0xD1F3             BNE.N    ??f_puts_1
   \   00000022   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000026   0xE000             B.N      ??f_puts_3
   3877          	}
   3878          	return n;
   \                     ??f_puts_2:
   \   00000028   0x0030             MOVS     R0,R6
   \                     ??f_puts_3:
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
   3879          }
   3880          
   3881          
   3882          
   3883          
   3884          /*-----------------------------------------------------------------------*/
   3885          /* Put a formatted string to the file                                    */
   3886          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3887          int f_printf (
   3888          	FIL* fil,			/* Pointer to the file object */
   3889          	const TCHAR* str,	/* Pointer to the format string */
   3890          	...					/* Optional arguments... */
   3891          )
   3892          {
   \                     f_printf:
   \   00000000   0xB40D             PUSH     {R0,R2,R3}
   \   00000002   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000006   0x000D             MOVS     R5,R1
   3893          	va_list arp;
   3894          	BYTE f, r;
   3895          	UINT i, j, w;
   3896          	ULONG v;
   3897          	TCHAR c, d, s[16], *p;
   3898          	int res, cc;
   3899          
   3900          
   3901          	va_start(arp, str);
   \   00000008   0xAE0E             ADD      R6,SP,#+56
   3902          
   3903          	for (cc = res = 0; cc != EOF; res += cc) {
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0004             MOVS     R4,R0
   \   0000000E   0xE004             B.N      ??f_printf_0
   3904          		c = *str++;
   3905          		if (c == 0) break;			/* End of string */
   3906          		if (c != '%') {				/* Non escape character */
   3907          			cc = f_putc(c, fil);
   3908          			if (cc != EOF) cc = 1;
   3909          			continue;
   3910          		}
   3911          		w = f = 0;
   3912          		c = *str++;
   3913          		if (c == '0') {				/* Flag: '0' padding */
   3914          			f = 1; c = *str++;
   3915          		} else {
   3916          			if (c == '-') {			/* Flag: left justified */
   3917          				f = 2; c = *str++;
   3918          			}
   3919          		}
   3920          		while (IsDigit(c)) {		/* Precision */
   3921          			w = w * 10 + c - '0';
   3922          			c = *str++;
   3923          		}
   3924          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   3925          			f |= 4; c = *str++;
   3926          		}
   3927          		if (!c) break;
   3928          		d = c;
   3929          		if (IsLower(d)) d -= 0x20;
   3930          		switch (d) {				/* Type is... */
   3931          		case 'S' :					/* String */
   3932          			p = va_arg(arp, TCHAR*);
   3933          			for (j = 0; p[j]; j++) ;
   3934          			res = 0;
   3935          			while (!(f & 2) && j++ < w) res += (cc = f_putc(' ', fil));
   3936          			res += (cc = f_puts(p, fil));
   3937          			while (j++ < w) res += (cc = f_putc(' ', fil));
   3938          			if (cc != EOF) cc = res;
   3939          			continue;
   3940          		case 'C' :					/* Character */
   3941          			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
   3942          		case 'B' :					/* Binary */
   3943          			r = 2; break;
   3944          		case 'O' :					/* Octal */
   3945          			r = 8; break;
   3946          		case 'D' :					/* Signed decimal */
   3947          		case 'U' :					/* Unsigned decimal */
   3948          			r = 10; break;
   3949          		case 'X' :					/* Hexdecimal */
   3950          			r = 16; break;
   3951          		default:					/* Unknown type (passthrough) */
   3952          			cc = f_putc(c, fil); continue;
   3953          		}
   3954          
   3955          		/* Get an argument and put it in numeral */
   3956          		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : va_arg(arp, unsigned int));
   3957          		if (d == 'D' && (v & 0x80000000)) {
   3958          			v = 0 - v;
   3959          			f |= 8;
   3960          		}
   3961          		i = 0;
   3962          		do {
   3963          			d = (TCHAR)(v % r); v /= r;
   3964          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   3965          			s[i++] = d + '0';
   3966          		} while (v && i < sizeof(s) / sizeof(s[0]));
   3967          		if (f & 8) s[i++] = '-';
   3968          		j = i; d = (f & 1) ? '0' : ' ';
   3969          		res = 0;
   3970          		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
   3971          		do res += (cc = f_putc(s[--i], fil)); while(i);
   3972          		while (j++ < w) res += (cc = f_putc(' ', fil));
   3973          		if (cc != EOF) cc = res;
   \                     ??f_printf_1:
   \   00000010   0xF110 0x0F01      CMN      R0,#+1
   \   00000014   0xD000             BEQ.N    ??f_printf_2
   \   00000016   0x0020             MOVS     R0,R4
   \                     ??f_printf_2:
   \   00000018   0x1904             ADDS     R4,R0,R4
   \                     ??f_printf_0:
   \   0000001A   0xF110 0x0F01      CMN      R0,#+1
   \   0000001E   0xD004             BEQ.N    ??f_printf_3
   \   00000020   0x782A             LDRB     R2,[R5, #+0]
   \   00000022   0x1C6D             ADDS     R5,R5,#+1
   \   00000024   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD104             BNE.N    ??f_printf_4
   3974          	}
   3975          
   3976          	va_end(arp);
   3977          	return (cc == EOF) ? cc : res;
   \                     ??f_printf_3:
   \   0000002A   0xF110 0x0F01      CMN      R0,#+1
   \   0000002E   0xF040 0x810E      BNE.W    ??f_printf_5
   \   00000032   0xE10D             B.N      ??f_printf_6
   \                     ??f_printf_4:
   \   00000034   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000036   0x2A25             CMP      R2,#+37
   \   00000038   0xD009             BEQ.N    ??f_printf_7
   \   0000003A   0x990D             LDR      R1,[SP, #+52]
   \   0000003C   0x0010             MOVS     R0,R2
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x.... 0x....      BL       f_putc
   \   00000044   0xF110 0x0F01      CMN      R0,#+1
   \   00000048   0xD000             BEQ.N    ??f_printf_8
   \   0000004A   0x2001             MOVS     R0,#+1
   \                     ??f_printf_8:
   \   0000004C   0xE7E4             B.N      ??f_printf_2
   \                     ??f_printf_7:
   \   0000004E   0xF05F 0x0800      MOVS     R8,#+0
   \   00000052   0x4647             MOV      R7,R8
   \   00000054   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000058   0x782A             LDRB     R2,[R5, #+0]
   \   0000005A   0x1C6D             ADDS     R5,R5,#+1
   \   0000005C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005E   0x2A30             CMP      R2,#+48
   \   00000060   0xD103             BNE.N    ??f_printf_9
   \   00000062   0x2701             MOVS     R7,#+1
   \   00000064   0x782A             LDRB     R2,[R5, #+0]
   \   00000066   0x1C6D             ADDS     R5,R5,#+1
   \   00000068   0xE00E             B.N      ??f_printf_10
   \                     ??f_printf_9:
   \   0000006A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006C   0x2A2D             CMP      R2,#+45
   \   0000006E   0xD10B             BNE.N    ??f_printf_10
   \   00000070   0x2702             MOVS     R7,#+2
   \   00000072   0x782A             LDRB     R2,[R5, #+0]
   \   00000074   0x1C6D             ADDS     R5,R5,#+1
   \   00000076   0xE007             B.N      ??f_printf_10
   \                     ??f_printf_11:
   \   00000078   0x210A             MOVS     R1,#+10
   \   0000007A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000007C   0xFB01 0x2108      MLA      R1,R1,R8,R2
   \   00000080   0xF1B1 0x0830      SUBS     R8,R1,#+48
   \   00000084   0x782A             LDRB     R2,[R5, #+0]
   \   00000086   0x1C6D             ADDS     R5,R5,#+1
   \                     ??f_printf_10:
   \   00000088   0xF1B2 0x0130      SUBS     R1,R2,#+48
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0x290A             CMP      R1,#+10
   \   00000090   0xD3F2             BCC.N    ??f_printf_11
   \   00000092   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000094   0x2A6C             CMP      R2,#+108
   \   00000096   0xD002             BEQ.N    ??f_printf_12
   \   00000098   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000009A   0x2A4C             CMP      R2,#+76
   \   0000009C   0xD103             BNE.N    ??f_printf_13
   \                     ??f_printf_12:
   \   0000009E   0xF057 0x0704      ORRS     R7,R7,#0x4
   \   000000A2   0x782A             LDRB     R2,[R5, #+0]
   \   000000A4   0x1C6D             ADDS     R5,R5,#+1
   \                     ??f_printf_13:
   \   000000A6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A8   0x2A00             CMP      R2,#+0
   \   000000AA   0xD0BE             BEQ.N    ??f_printf_3
   \                     ??f_printf_14:
   \   000000AC   0x4693             MOV      R11,R2
   \   000000AE   0xF1BB 0x0061      SUBS     R0,R11,#+97
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x281A             CMP      R0,#+26
   \   000000B6   0xD201             BCS.N    ??f_printf_15
   \   000000B8   0xF1BB 0x0B20      SUBS     R11,R11,#+32
   \                     ??f_printf_15:
   \   000000BC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000C0   0x4658             MOV      R0,R11
   \   000000C2   0x2842             CMP      R0,#+66
   \   000000C4   0xD043             BEQ.N    ??f_printf_16
   \   000000C6   0x2843             CMP      R0,#+67
   \   000000C8   0xD039             BEQ.N    ??f_printf_17
   \   000000CA   0x2844             CMP      R0,#+68
   \   000000CC   0xD047             BEQ.N    ??f_printf_18
   \   000000CE   0x284F             CMP      R0,#+79
   \   000000D0   0xD043             BEQ.N    ??f_printf_19
   \   000000D2   0x2853             CMP      R0,#+83
   \   000000D4   0xD004             BEQ.N    ??f_printf_20
   \   000000D6   0x2855             CMP      R0,#+85
   \   000000D8   0xD041             BEQ.N    ??f_printf_18
   \   000000DA   0x2858             CMP      R0,#+88
   \   000000DC   0xD041             BEQ.N    ??f_printf_21
   \   000000DE   0xE042             B.N      ??f_printf_22
   \                     ??f_printf_20:
   \   000000E0   0xF8D6 0xA000      LDR      R10,[R6, #+0]
   \   000000E4   0x1D36             ADDS     R6,R6,#+4
   \   000000E6   0xF05F 0x0900      MOVS     R9,#+0
   \   000000EA   0xE001             B.N      ??f_printf_23
   \                     ??f_printf_24:
   \   000000EC   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??f_printf_23:
   \   000000F0   0xF819 0x000A      LDRB     R0,[R9, R10]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD1F9             BNE.N    ??f_printf_24
   \   000000F8   0x2400             MOVS     R4,#+0
   \   000000FA   0xE004             B.N      ??f_printf_25
   \                     ??f_printf_26:
   \   000000FC   0x990D             LDR      R1,[SP, #+52]
   \   000000FE   0x2020             MOVS     R0,#+32
   \   00000100   0x.... 0x....      BL       f_putc
   \   00000104   0x1904             ADDS     R4,R0,R4
   \                     ??f_printf_25:
   \   00000106   0x07B8             LSLS     R0,R7,#+30
   \   00000108   0xD404             BMI.N    ??f_printf_27
   \   0000010A   0x4648             MOV      R0,R9
   \   0000010C   0xF110 0x0901      ADDS     R9,R0,#+1
   \   00000110   0x4540             CMP      R0,R8
   \   00000112   0xD3F3             BCC.N    ??f_printf_26
   \                     ??f_printf_27:
   \   00000114   0x990D             LDR      R1,[SP, #+52]
   \   00000116   0x4650             MOV      R0,R10
   \   00000118   0x.... 0x....      BL       f_puts
   \   0000011C   0x1904             ADDS     R4,R0,R4
   \   0000011E   0xE004             B.N      ??f_printf_28
   \                     ??f_printf_29:
   \   00000120   0x990D             LDR      R1,[SP, #+52]
   \   00000122   0x2020             MOVS     R0,#+32
   \   00000124   0x.... 0x....      BL       f_putc
   \   00000128   0x1904             ADDS     R4,R0,R4
   \                     ??f_printf_28:
   \   0000012A   0x4649             MOV      R1,R9
   \   0000012C   0xF111 0x0901      ADDS     R9,R1,#+1
   \   00000130   0x4541             CMP      R1,R8
   \   00000132   0xD3F5             BCC.N    ??f_printf_29
   \   00000134   0xF110 0x0F01      CMN      R0,#+1
   \   00000138   0xD000             BEQ.N    ??f_printf_30
   \   0000013A   0x0020             MOVS     R0,R4
   \                     ??f_printf_30:
   \   0000013C   0xE76C             B.N      ??f_printf_2
   \                     ??f_printf_17:
   \   0000013E   0x0030             MOVS     R0,R6
   \   00000140   0x1D06             ADDS     R6,R0,#+4
   \   00000142   0x990D             LDR      R1,[SP, #+52]
   \   00000144   0x6800             LDR      R0,[R0, #+0]
   \   00000146   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000148   0x.... 0x....      BL       f_putc
   \   0000014C   0xE764             B.N      ??f_printf_2
   \                     ??f_printf_16:
   \   0000014E   0x2002             MOVS     R0,#+2
   \                     ??f_printf_31:
   \   00000150   0x0779             LSLS     R1,R7,#+29
   \   00000152   0xD50E             BPL.N    ??f_printf_32
   \   00000154   0x6831             LDR      R1,[R6, #+0]
   \   00000156   0x1D36             ADDS     R6,R6,#+4
   \   00000158   0xE015             B.N      ??f_printf_33
   \                     ??f_printf_19:
   \   0000015A   0x2008             MOVS     R0,#+8
   \   0000015C   0xE7F8             B.N      ??f_printf_31
   \                     ??f_printf_18:
   \   0000015E   0x200A             MOVS     R0,#+10
   \   00000160   0xE7F6             B.N      ??f_printf_31
   \                     ??f_printf_21:
   \   00000162   0x2010             MOVS     R0,#+16
   \   00000164   0xE7F4             B.N      ??f_printf_31
   \                     ??f_printf_22:
   \   00000166   0x990D             LDR      R1,[SP, #+52]
   \   00000168   0x0010             MOVS     R0,R2
   \   0000016A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016C   0x.... 0x....      BL       f_putc
   \   00000170   0xE752             B.N      ??f_printf_2
   \                     ??f_printf_32:
   \   00000172   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000176   0xF1BB 0x0F44      CMP      R11,#+68
   \   0000017A   0xD102             BNE.N    ??f_printf_34
   \   0000017C   0x6831             LDR      R1,[R6, #+0]
   \   0000017E   0x1D36             ADDS     R6,R6,#+4
   \   00000180   0xE001             B.N      ??f_printf_33
   \                     ??f_printf_34:
   \   00000182   0x6831             LDR      R1,[R6, #+0]
   \   00000184   0x1D36             ADDS     R6,R6,#+4
   \                     ??f_printf_33:
   \   00000186   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000018A   0xF1BB 0x0F44      CMP      R11,#+68
   \   0000018E   0xD104             BNE.N    ??f_printf_35
   \   00000190   0x2900             CMP      R1,#+0
   \   00000192   0xD502             BPL.N    ??f_printf_35
   \   00000194   0x4249             RSBS     R1,R1,#+0
   \   00000196   0xF057 0x0708      ORRS     R7,R7,#0x8
   \                     ??f_printf_35:
   \   0000019A   0xF05F 0x0A00      MOVS     R10,#+0
   \                     ??f_printf_36:
   \   0000019E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A0   0xFBB1 0xF3F0      UDIV     R3,R1,R0
   \   000001A4   0xFB00 0x1B13      MLS      R11,R0,R3,R1
   \   000001A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AA   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   \   000001AE   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000001B2   0xF1BB 0x0F0A      CMP      R11,#+10
   \   000001B6   0xD307             BCC.N    ??f_printf_37
   \   000001B8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001BA   0x2A78             CMP      R2,#+120
   \   000001BC   0xD101             BNE.N    ??f_printf_38
   \   000001BE   0x2327             MOVS     R3,#+39
   \   000001C0   0xE000             B.N      ??f_printf_39
   \                     ??f_printf_38:
   \   000001C2   0x2307             MOVS     R3,#+7
   \                     ??f_printf_39:
   \   000001C4   0xEB13 0x0B0B      ADDS     R11,R3,R11
   \                     ??f_printf_37:
   \   000001C8   0xAB00             ADD      R3,SP,#+0
   \   000001CA   0xF11B 0x0430      ADDS     R4,R11,#+48
   \   000001CE   0xF80A 0x4003      STRB     R4,[R10, R3]
   \   000001D2   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000001D6   0x2900             CMP      R1,#+0
   \   000001D8   0xD002             BEQ.N    ??f_printf_40
   \   000001DA   0xF1BA 0x0F10      CMP      R10,#+16
   \   000001DE   0xD3DE             BCC.N    ??f_printf_36
   \                     ??f_printf_40:
   \   000001E0   0x0738             LSLS     R0,R7,#+28
   \   000001E2   0xD505             BPL.N    ??f_printf_41
   \   000001E4   0xA800             ADD      R0,SP,#+0
   \   000001E6   0x212D             MOVS     R1,#+45
   \   000001E8   0xF80A 0x1000      STRB     R1,[R10, R0]
   \   000001EC   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??f_printf_41:
   \   000001F0   0x46D1             MOV      R9,R10
   \   000001F2   0x07F8             LSLS     R0,R7,#+31
   \   000001F4   0xD502             BPL.N    ??f_printf_42
   \   000001F6   0xF05F 0x0B30      MOVS     R11,#+48
   \   000001FA   0xE001             B.N      ??f_printf_43
   \                     ??f_printf_42:
   \   000001FC   0xF05F 0x0B20      MOVS     R11,#+32
   \                     ??f_printf_43:
   \   00000200   0x2400             MOVS     R4,#+0
   \   00000202   0xE005             B.N      ??f_printf_44
   \                     ??f_printf_45:
   \   00000204   0x990D             LDR      R1,[SP, #+52]
   \   00000206   0x4658             MOV      R0,R11
   \   00000208   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000020A   0x.... 0x....      BL       f_putc
   \   0000020E   0x1904             ADDS     R4,R0,R4
   \                     ??f_printf_44:
   \   00000210   0x07B8             LSLS     R0,R7,#+30
   \   00000212   0xD404             BMI.N    ??f_printf_46
   \   00000214   0x4648             MOV      R0,R9
   \   00000216   0xF110 0x0901      ADDS     R9,R0,#+1
   \   0000021A   0x4540             CMP      R0,R8
   \   0000021C   0xD3F2             BCC.N    ??f_printf_45
   \                     ??f_printf_46:
   \   0000021E   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000222   0x990D             LDR      R1,[SP, #+52]
   \   00000224   0xA800             ADD      R0,SP,#+0
   \   00000226   0xF81A 0x0000      LDRB     R0,[R10, R0]
   \   0000022A   0x.... 0x....      BL       f_putc
   \   0000022E   0x1904             ADDS     R4,R0,R4
   \   00000230   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000234   0xD1F3             BNE.N    ??f_printf_46
   \                     ??f_printf_47:
   \   00000236   0x4649             MOV      R1,R9
   \   00000238   0xF111 0x0901      ADDS     R9,R1,#+1
   \   0000023C   0x4541             CMP      R1,R8
   \   0000023E   0xF4BF 0xAEE7      BCS.W    ??f_printf_1
   \   00000242   0x990D             LDR      R1,[SP, #+52]
   \   00000244   0x2020             MOVS     R0,#+32
   \   00000246   0x.... 0x....      BL       f_putc
   \   0000024A   0x1904             ADDS     R4,R0,R4
   \   0000024C   0xE7F3             B.N      ??f_printf_47
   \                     ??f_printf_5:
   \   0000024E   0x0020             MOVS     R0,R4
   \                     ??f_printf_6:
   \   00000250   0xB004             ADD      SP,SP,#+16
   \   00000252   0xE8BD 0x0FF0      POP      {R4-R11}
   \   00000256   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
   3978          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     LfnOfs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     `?<Constant "\\"*:<>?|\\177">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     ??excvt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     `?<Constant "+,;=[]">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x00544146         DC32     0x544146

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     FatFs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x41615252         DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x61417272         DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     Fsid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     LfnBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     LfnBuf

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"*:<>?|\\177">`:
   \   00000000   0x22 0x2A          DC8 "\"*:<>?|\177"
   \              0x3A 0x3C    
   \              0x3E 0x3F    
   \              0x7C 0x7F    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "+,;=[]">`:
   \   00000000   0x2B 0x2C          DC8 "+,;=[]"
   \              0x3B 0x3D    
   \              0x5B 0x5D    
   \              0x00         
   \   00000007   0x00               DC8 0
   3979          
   3980          #endif /* !_FS_READONLY */
   3981          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  check_fs
               8 -> disk_read
        0  chk_chr
       24  chk_mounted
              24 -> check_fs
              24 -> disk_initialize
              24 -> disk_read
              24 -> disk_status
        0  clmt_clust
        0  clust2sect
       24  cmp_lfn
              24 -> ff_wtoupper
       24  create_chain
              24 -> get_fat
              24 -> put_fat
       40  create_name
              40 -> chk_chr
              40 -> ff_convert
              40 -> mem_set
       24  dir_find
              24 -> cmp_lfn
              24 -> dir_next
              24 -> dir_sdi
              24 -> mem_cmp
              24 -> move_window
              24 -> sum_sfn
       24  dir_next
              24 -> clust2sect
              24 -> create_chain
              24 -> get_fat
              24 -> mem_set
              24 -> move_window
       24  dir_read
              24 -> dir_next
              24 -> move_window
              24 -> pick_lfn
              24 -> sum_sfn
       40  dir_register
              40 -> dir_find
              40 -> dir_next
              40 -> dir_sdi
              40 -> fit_lfn
              40 -> gen_numname
              40 -> mem_cpy
              40 -> mem_set
              40 -> move_window
              40 -> sum_sfn
       16  dir_remove
              16 -> dir_next
              16 -> dir_sdi
              16 -> move_window
       16  dir_sdi
              16 -> clust2sect
              16 -> get_fat
       56  f_chdir
              56 -> chk_mounted
              56 -> follow_path
        0  f_chdrive
       64  f_chmod
              64 -> chk_mounted
              64 -> follow_path
              64 -> sync
        8  f_close
               8 -> f_sync
       40  f_getfree
              40 -> chk_mounted
              40 -> get_fat
              40 -> move_window
       32  f_gets
              32 -> f_read
       40  f_lseek
              40 -> clmt_clust
              40 -> clust2sect
              40 -> create_chain
              40 -> disk_read
              40 -> disk_write
              40 -> get_fat
              40 -> validate
       80  f_mkdir
              80 -> chk_mounted
              80 -> clust2sect
              80 -> create_chain
              80 -> dir_register
              80 -> follow_path
              80 -> get_fattime
              80 -> mem_cpy
              80 -> mem_set
              80 -> move_window
              80 -> remove_chain
              80 -> sync
        0  f_mount
       80  f_open
              80 -> chk_mounted
              80 -> dir_register
              80 -> follow_path
              80 -> get_fattime
              80 -> move_window
              80 -> remove_chain
       24  f_opendir
              24 -> chk_mounted
              24 -> dir_sdi
              24 -> follow_path
       64  f_printf
              64 -> f_putc
              64 -> f_puts
       24  f_putc
              24 -> f_write
       16  f_puts
              16 -> f_putc
       32  f_read
              32 -> clmt_clust
              32 -> clust2sect
              32 -> disk_read
              32 -> disk_write
              32 -> get_fat
              32 -> mem_cpy
              32 -> validate
       24  f_readdir
              24 -> dir_next
              24 -> dir_read
              24 -> dir_sdi
              24 -> get_fileinfo
              24 -> validate
      128  f_rename
             128 -> chk_mounted
             128 -> clust2sect
             128 -> dir_register
             128 -> dir_remove
             128 -> follow_path
             128 -> mem_cpy
             128 -> move_window
             128 -> sync
       64  f_stat
              64 -> chk_mounted
              64 -> follow_path
              64 -> get_fileinfo
       16  f_sync
              16 -> disk_write
              16 -> get_fattime
              16 -> move_window
              16 -> sync
              16 -> validate
       16  f_truncate
              16 -> get_fat
              16 -> put_fat
              16 -> remove_chain
              16 -> validate
       96  f_unlink
              96 -> chk_mounted
              96 -> dir_read
              96 -> dir_remove
              96 -> dir_sdi
              96 -> follow_path
              96 -> mem_cpy
              96 -> remove_chain
              96 -> sync
       64  f_utime
              64 -> chk_mounted
              64 -> follow_path
              64 -> sync
       32  f_write
              32 -> clmt_clust
              32 -> clust2sect
              32 -> create_chain
              32 -> disk_read
              32 -> disk_write
              32 -> mem_cpy
              32 -> validate
       16  fit_lfn
       16  follow_path
              16 -> create_name
              16 -> dir_find
              16 -> dir_sdi
       24  gen_numname
              24 -> mem_cpy
       24  get_fat
              24 -> move_window
       24  get_fileinfo
              24 -> ff_convert
        4  mem_cmp
        0  mem_cpy
        0  mem_set
       24  move_window
              24 -> disk_read
              24 -> disk_write
       12  pick_lfn
       24  put_fat
              24 -> move_window
       24  remove_chain
              24 -> get_fat
              24 -> put_fat
        0  sum_sfn
       16  sync
              16 -> disk_ioctl
              16 -> disk_write
              16 -> mem_set
              16 -> move_window
        8  validate
               8 -> disk_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "+,;=[]">
      12  ?<Constant "\"*:<>?|\177">
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable17
       4  ??DataTable4
       4  ??DataTable7
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       1  CurrVol
       4  FatFs
       2  Fsid
     512  LfnBuf
      16  LfnOfs
     120  check_fs
      20  chk_chr
     860  chk_mounted
      42  clmt_clust
      24  clust2sect
     150  cmp_lfn
     180  create_chain
     672  create_name
     230  dir_find
     306  dir_next
     184  dir_read
     454  dir_register
      96  dir_remove
     176  dir_sdi
     128  excvt
     120  f_chdir
      18  f_chdrive
     106  f_chmod
      24  f_close
     270  f_getfree
      70  f_gets
     768  f_lseek
     494  f_mkdir
      50  f_mount
     416  f_open
     130  f_opendir
     602  f_printf
      40  f_putc
      44  f_puts
     514  f_read
      98  f_readdir
     344  f_rename
      74  f_stat
     184  f_sync
     166  f_truncate
     226  f_unlink
     112  f_utime
     570  f_write
     116  fit_lfn
     168  follow_path
     136  gen_numname
     246  get_fat
     250  get_fileinfo
      32  mem_cmp
      20  mem_cpy
      16  mem_set
     116  move_window
     108  pick_lfn
     298  put_fat
     106  remove_chain
      30  sum_sfn
     214  sync
      42  validate

 
    519 bytes in section .bss
    164 bytes in section .rodata
 10 900 bytes in section .text
 
 10 900 bytes of CODE  memory
    164 bytes of CONST memory
    519 bytes of DATA  memory

Errors: none
Warnings: 2
