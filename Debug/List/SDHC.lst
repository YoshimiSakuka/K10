###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     13/Mar/2015  12:44:23 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Administrator\Desktop\3.11换结构BLOCK nd        #
#                    black\common\SDHC.c                                      #
#    Command line =  "C:\Users\Administrator\Desktop\3.11换结构BLOCK nd       #
#                    black\common\SDHC.c" -D DEBUG -lCN                       #
#                    "C:\Users\Administrator\Desktop\3.11换结构BLOCK nd       #
#                    black\Debug\List\" -lB "C:\Users\Administrator\Desktop\3 #
#                    .11换结构BLOCK nd  black\Debug\List\" -o                 #
#                    "C:\Users\Administrator\Desktop\3.11换结构BLOCK nd       #
#                    black\Debug\Obj\" --no_cse --no_unroll --no_inline       #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -Ol --use_c++_inline                              #
#    List file    =  C:\Users\Administrator\Desktop\3.11换结构BLOCK nd        #
#                    black\Debug\List\SDHC.lst                                #
#    Object file  =  C:\Users\Administrator\Desktop\3.11换结构BLOCK nd        #
#                    black\Debug\Obj\SDHC.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Administrator\Desktop\3.11换结构BLOCK nd  black\common\SDHC.c
      1          /*
      2           * SDHC.c
      3           *
      4           *  Created on: 16/05/2011
      5           *      Author: gustavo
      6           */
      7          
      8          #include "..\K60_datatype.h"
      9          

   \                                 In section .bss, align 4
     10          OS_RTC rtc;
   \                     rtc:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     11          SDCARD_STRUCT       SDHC_Card;
   \                     SDHC_Card:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     12          SDCARD_INIT_STRUCT  SDHC_Init;
   \                     SDHC_Init:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     13          ESDHC_INFO_STRUCT   SDHC_Info;
   \                     SDHC_Info:
   \   00000000                      DS8 516

   \                                 In section .bss, align 4
     14          ESDHC_DEVICE_STRUCT SDHC_Device;
   \                     SDHC_Device:
   \   00000000                      DS8 8
     15          

   \                                 In section .data, align 1
     16          static volatile DSTATUS   Stat             = STA_NOINIT;    /* Disk status */
   \                     Stat:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 4
     17          static volatile U32  Timer            = 0;             /* Read/Write timer */
   \                     Timer:
   \   00000000                      DS8 4
     18          
     19          

   \                                 In section .rodata, align 4
     20          const ESDHC_INIT_STRUCT K60_SDHC0_init = {
   \                     K60_SDHC0_init:
   \   00000000   0x00000000         DC32 0, 25000000, 100000000
   \              0x017D7840   
   \              0x05F5E100   
     21              0,                          /* ESDHC device number */ 
     22              25000000,                   /* ESDHC baudrate      */
     23              BSP_SYSTEM_CLOCK            /* ESDHC clock source  */ 
     24          };
     25          

   \                                 In section .text, align 2, keep-with-next
     26          U32 get_fattime (void)
     27          {
     28           
     29            
     30            
     31          
     32            return  (  ((U32)(rtc.Year - 1980) << 25)
     33                    | ((U32)rtc.Month << 21)
     34                    | ((U32)rtc.Day   << 16)
     35                    | ((U32)rtc.Hour  << 11)
     36                    | ((U32)rtc.Min << 5)
     37                    | ((U32)rtc.Sec << 1));   
   \                     get_fattime:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable7  ;; 0xfffff844
   \   0000000A   0xFA11 0xF080      UXTAH    R0,R1,R0
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000012   0x7889             LDRB     R1,[R1, #+2]
   \   00000014   0x0549             LSLS     R1,R1,#+21
   \   00000016   0xEA51 0x6040      ORRS     R0,R1,R0, LSL #+25
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000001E   0x78C9             LDRB     R1,[R1, #+3]
   \   00000020   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000028   0x7909             LDRB     R1,[R1, #+4]
   \   0000002A   0xEA50 0x20C1      ORRS     R0,R0,R1, LSL #+11
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000032   0x7949             LDRB     R1,[R1, #+5]
   \   00000034   0xEA50 0x1041      ORRS     R0,R0,R1, LSL #+5
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000003C   0x7989             LDRB     R1,[R1, #+6]
   \   0000003E   0xEA50 0x0041      ORRS     R0,R0,R1, LSL #+1
   \   00000042   0x4770             BX       LR               ;; return
     38          /*return  (  ((U32)(2011 - 1980) << 25)
     39                    | ((U32)11 << 21)
     40                    | ((U32)10  << 16)
     41                    | ((U32)22  << 11)
     42                    | ((U32)0 << 5)
     43                    | ((U32)0 << 1));*/
     44          }
     45          
     46          

   \                                 In section .rodata, align 4
     47          static const unsigned long ESDHC_COMMAND_XFERTYP[] = 
   \                     ESDHC_COMMAND_XFERTYP:
   \   00000000   0x00000000         DC32 0, 16777216, 34144256, 52035584, 67108864, 84017152, 102367232
   \              0x01000000   
   \              0x02090000   
   \              0x031A0000   
   \              0x04000000   
   \              0x05020000   
   \              0x061A0000   
   \   0000001C   0x071B0000         DC32 119209984, 135921664, 151584768, 168361984, 186253312, 215678976
   \              0x081A0000   
   \              0x09090000   
   \              0x0A090000   
   \              0x0B1A0000   
   \              0x0CDB0000   
   \   00000034   0x0D1A0000         DC32 219807744, 0, 251658240, 270139392, 286916608, 303693824, 0
   \              0x00000000   
   \              0x0F000000   
   \              0x101A0000   
   \              0x111A0000   
   \              0x121A0000   
   \              0x00000000   
   \   00000050   0x141A0000         DC32 337248256, 0, 370802688, 387579904, 404357120, 421134336
   \              0x00000000   
   \              0x161A0000   
   \              0x171A0000   
   \              0x181A0000   
   \              0x191A0000   
   \   00000068   0x1A1A0000         DC32 437911552, 454688768, 471531520, 488308736, 505020416, 0
   \              0x1B1A0000   
   \              0x1C1B0000   
   \              0x1D1B0000   
   \              0x1E1A0000   
   \              0x00000000   
   \   00000080   0x201A0000         DC32 538574848, 555352064, 572129280, 588906496, 605683712, 622460928
   \              0x211A0000   
   \              0x221A0000   
   \              0x231A0000   
   \              0x241A0000   
   \              0x251A0000   
   \   00000098   0x261B0000         DC32 639303680, 654442496, 672792576, 687996928, 706412544, 0, 0, 0, 0
   \              0x27020000   
   \              0x281A0000   
   \              0x29020000   
   \              0x2A1B0000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   000000BC   0x00000000         DC32 0, 0, 0, 0, 857341952, 874119168, 890896384, 0, 924450816
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x331A0000   
   \              0x341A0000   
   \              0x351A0000   
   \              0x00000000   
   \              0x371A0000   
   \   000000E0   0x381B0000         DC32 941293568, 0, 0, 0, 1008402432, 1025179648, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x3C1B0000   
   \              0x3D1B0000   
   \              0x00000000   
   \              0x00000000   
     48          {   /* CMD0 */
     49              SDHC_XFERTYP_CMDINX(ESDHC_CMD0) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     50              SDHC_XFERTYP_CMDINX(ESDHC_CMD1) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     51              SDHC_XFERTYP_CMDINX(ESDHC_CMD2) | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136),
     52              SDHC_XFERTYP_CMDINX(ESDHC_CMD3) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     53              SDHC_XFERTYP_CMDINX(ESDHC_CMD4) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     54              /* CMD5 */
     55              SDHC_XFERTYP_CMDINX(ESDHC_CMD5) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     56              SDHC_XFERTYP_CMDINX(ESDHC_CMD6) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     57              SDHC_XFERTYP_CMDINX(ESDHC_CMD7) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     58              SDHC_XFERTYP_CMDINX(ESDHC_CMD8) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     59              SDHC_XFERTYP_CMDINX(ESDHC_CMD9) | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136),
     60              /* CMD10 */
     61              SDHC_XFERTYP_CMDINX(ESDHC_CMD10) | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136),
     62              SDHC_XFERTYP_CMDINX(ESDHC_CMD11) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     63              SDHC_XFERTYP_CMDINX(ESDHC_CMD12) | SDHC_XFERTYP_CMDTYP(ESDHC_XFERTYP_CMDTYP_ABORT) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     64              SDHC_XFERTYP_CMDINX(ESDHC_CMD13) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     65              0,
     66              /* CMD15 */
     67              SDHC_XFERTYP_CMDINX(ESDHC_CMD15) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     68              SDHC_XFERTYP_CMDINX(ESDHC_CMD16) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     69              SDHC_XFERTYP_CMDINX(ESDHC_CMD17) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     70              SDHC_XFERTYP_CMDINX(ESDHC_CMD18) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     71              0,
     72              /* CMD20 */
     73              SDHC_XFERTYP_CMDINX(ESDHC_CMD20) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     74              0,
     75              SDHC_XFERTYP_CMDINX(ESDHC_ACMD22) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     76              SDHC_XFERTYP_CMDINX(ESDHC_ACMD23) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     77              SDHC_XFERTYP_CMDINX(ESDHC_CMD24) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     78              /* CMD25 */
     79              SDHC_XFERTYP_CMDINX(ESDHC_CMD25) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     80              SDHC_XFERTYP_CMDINX(ESDHC_CMD26) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     81              SDHC_XFERTYP_CMDINX(ESDHC_CMD27) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     82              SDHC_XFERTYP_CMDINX(ESDHC_CMD28) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     83              SDHC_XFERTYP_CMDINX(ESDHC_CMD29) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     84              /* CMD30 */
     85              SDHC_XFERTYP_CMDINX(ESDHC_CMD30) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     86              0,
     87              SDHC_XFERTYP_CMDINX(ESDHC_CMD32) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     88              SDHC_XFERTYP_CMDINX(ESDHC_CMD33) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     89              SDHC_XFERTYP_CMDINX(ESDHC_CMD34) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     90              /* CMD35 */
     91              SDHC_XFERTYP_CMDINX(ESDHC_CMD35) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     92              SDHC_XFERTYP_CMDINX(ESDHC_CMD36) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     93              SDHC_XFERTYP_CMDINX(ESDHC_CMD37) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     94              SDHC_XFERTYP_CMDINX(ESDHC_CMD38) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     95              SDHC_XFERTYP_CMDINX(ESDHC_CMD39) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     96              /* CMD40 */
     97              SDHC_XFERTYP_CMDINX(ESDHC_CMD40) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     98              SDHC_XFERTYP_CMDINX(ESDHC_ACMD41) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     99              SDHC_XFERTYP_CMDINX(ESDHC_CMD42) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
    100              0,
    101              0,
    102              /* CMD45 */
    103              0,
    104              0,
    105              0,
    106              0,
    107              0,
    108              /* CMD50 */
    109              0,
    110              SDHC_XFERTYP_CMDINX(ESDHC_ACMD51) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
    111              SDHC_XFERTYP_CMDINX(ESDHC_CMD52) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
    112              SDHC_XFERTYP_CMDINX(ESDHC_CMD53) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
    113              0,
    114              /* CMD55 */
    115              SDHC_XFERTYP_CMDINX(ESDHC_CMD55) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
    116              SDHC_XFERTYP_CMDINX(ESDHC_CMD56) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
    117              0,
    118              0,
    119              0,
    120              /* CMD60 */
    121              SDHC_XFERTYP_CMDINX(ESDHC_CMD60) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
    122              SDHC_XFERTYP_CMDINX(ESDHC_CMD61) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
    123              0,
    124              0
    125          };
    126          
    127          

   \                                 In section .text, align 2, keep-with-next
    128          static void SDHC_set_baudrate 
    129          (       
    130                  /* [IN] Module input clock in Hz */
    131                  U32         clock, 
    132                  
    133                  /* [IN] Desired baudrate in Hz */
    134                  U32         baudrate
    135          ) 
    136          {
   \                     SDHC_set_baudrate:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    137              U32 pres, div, min, minpres = 0x80, mindiv = 0x0F;
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x230F             MOVS     R3,#+15
    138              S32  val;
    139          
    140              /* Find closest setting */
    141              min = (U32)-1;
   \   00000006   0xF05F 0x36FF      MOVS     R6,#-1
    142              for (pres = 2; pres <= 256; pres <<= 1) 
   \   0000000A   0x2402             MOVS     R4,#+2
   \   0000000C   0xE00E             B.N      ??SDHC_set_baudrate_0
    143              {
    144                  for (div = 1; div <= 16; div++) 
    145                  {
    146                      val = pres * div * baudrate - clock;
   \                     ??SDHC_set_baudrate_1:
   \   0000000E   0xFB05 0xF704      MUL      R7,R5,R4
   \   00000012   0x434F             MULS     R7,R1,R7
   \   00000014   0x1A3F             SUBS     R7,R7,R0
    147                      if (val >= 0)
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD404             BMI.N    ??SDHC_set_baudrate_2
    148                      {
    149                          if (min > val) 
   \   0000001A   0x42B7             CMP      R7,R6
   \   0000001C   0xD202             BCS.N    ??SDHC_set_baudrate_2
    150                          {
    151                              min = val;
   \   0000001E   0x003E             MOVS     R6,R7
    152                              minpres = pres;
   \   00000020   0x0022             MOVS     R2,R4
    153                              mindiv = div;
   \   00000022   0x002B             MOVS     R3,R5
    154                          }
    155                      }
    156                  }
   \                     ??SDHC_set_baudrate_2:
   \   00000024   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SDHC_set_baudrate_3:
   \   00000026   0x2D11             CMP      R5,#+17
   \   00000028   0xD3F1             BCC.N    ??SDHC_set_baudrate_1
   \   0000002A   0x0064             LSLS     R4,R4,#+1
   \                     ??SDHC_set_baudrate_0:
   \   0000002C   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000030   0xD801             BHI.N    ??SDHC_set_baudrate_4
   \   00000032   0x2501             MOVS     R5,#+1
   \   00000034   0xE7F7             B.N      ??SDHC_set_baudrate_3
    157              }
    158          
    159              /* Disable ESDHC clocks */
    160              SDHC_SYSCTL &= (~ SDHC_SYSCTL_SDCLKEN_MASK);
   \                     ??SDHC_set_baudrate_4:
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x400b102c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x400b102c
   \   00000044   0x6008             STR      R0,[R1, #+0]
    161          
    162              /* Change dividers */
    163              div = SDHC_SYSCTL & (~ (SDHC_SYSCTL_DTOCV_MASK | SDHC_SYSCTL_SDCLKFS_MASK | SDHC_SYSCTL_DVS_MASK));
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x400b102c
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable8_1  ;; 0xfff0000f
   \   00000050   0xEA11 0x0500      ANDS     R5,R1,R0
    164              SDHC_SYSCTL = div | (SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_SDCLKFS(minpres >> 1) | SDHC_SYSCTL_DVS(mindiv - 1));
   \   00000054   0x01D0             LSLS     R0,R2,#+7
   \   00000056   0xF410 0x407F      ANDS     R0,R0,#0xFF00
   \   0000005A   0x4328             ORRS     R0,R0,R5
   \   0000005C   0x1E59             SUBS     R1,R3,#+1
   \   0000005E   0x0109             LSLS     R1,R1,#+4
   \   00000060   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   00000064   0x4308             ORRS     R0,R1,R0
   \   00000066   0xF450 0x2060      ORRS     R0,R0,#0xE0000
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x400b102c
   \   0000006E   0x6008             STR      R0,[R1, #+0]
   \   00000070   0xE002             B.N      ??SDHC_set_baudrate_5
    165          
    166              /* Wait for stable clock */
    167              while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB_MASK))
    168              {
    169                  /* Workaround... */
    170                   Delay(10);
   \                     ??SDHC_set_baudrate_6:
   \   00000072   0x200A             MOVS     R0,#+10
   \   00000074   0x.... 0x....      BL       Delay
    171              };
   \                     ??SDHC_set_baudrate_5:
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x400b1024
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x0700             LSLS     R0,R0,#+28
   \   00000080   0xD5F7             BPL.N    ??SDHC_set_baudrate_6
    172          
    173              /* Enable ESDHC clocks */
    174              SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN_MASK;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x400b102c
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x400b102c
   \   00000090   0x6008             STR      R0,[R1, #+0]
    175              SDHC_IRQSTAT |= SDHC_IRQSTAT_DTOE_MASK;
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000A0   0x6008             STR      R0,[R1, #+0]
    176          }
   \   000000A2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    177          
    178          

   \                                 In section .text, align 2, keep-with-next
    179          U32 SDHC_init(
    180                  /* [IN/OUT] Device runtime information */
    181                  ESDHC_INFO_STRUCT_PTR  esdhc_info_ptr,
    182          
    183                  /* [IN] Device initialization data */
    184                  ESDHC_INIT_STRUCT_CPTR esdhc_init_ptr
    185                  )   
    186          {
   \                     SDHC_init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0008             MOVS     R0,R1
    187              esdhc_info_ptr->CARD = ESDHC_CARD_NONE;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6021             STR      R1,[R4, #+0]
    188              
    189              /* Reset ESDHC */
    190              SDHC_SYSCTL = SDHC_SYSCTL_RSTA_MASK | SDHC_SYSCTL_SDCLKFS(0x80);    
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x400b102c
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable8_3  ;; 0x1008000
   \   00000012   0x600A             STR      R2,[R1, #+0]
    191              while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA_MASK){};
   \                     ??SDHC_init_0:
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x400b102c
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x01C9             LSLS     R1,R1,#+7
   \   0000001C   0xD4FA             BMI.N    ??SDHC_init_0
    192              
    193              /* Initial values */
    194              SDHC_VENDOR = 0;
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable8_4  ;; 0x400b10c0
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x600A             STR      R2,[R1, #+0]
    195              SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(512);
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x400b1004
   \   0000002A   0xF45F 0x3281      MOVS     R2,#+66048
   \   0000002E   0x600A             STR      R2,[R1, #+0]
    196              SDHC_PROCTL = SDHC_PROCTL_EMODE(ESDHC_PROCTL_EMODE_INVARIANT) | SDHC_PROCTL_D3CD_MASK; 
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b1028
   \   00000034   0x2228             MOVS     R2,#+40
   \   00000036   0x600A             STR      R2,[R1, #+0]
    197              SDHC_WML = SDHC_WML_RDWML(1) | SDHC_WML_WRWML(1);
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable8_7  ;; 0x400b1044
   \   0000003C   0xF05F 0x1201      MOVS     R2,#+65537
   \   00000040   0x600A             STR      R2,[R1, #+0]
    198              
    199              /* Set the ESDHC initial baud rate divider and start */
    200              SDHC_set_baudrate (esdhc_init_ptr->CLOCK_SPEED,380000);
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable8_8  ;; 0x5cc60
   \   00000046   0x6880             LDR      R0,[R0, #+8]
   \   00000048   0x.... 0x....      BL       SDHC_set_baudrate
    201              
    202              /* Poll inhibit bits */
    203              while (SDHC_PRSSTAT & (SDHC_PRSSTAT_CIHB_MASK | SDHC_PRSSTAT_CDIHB_MASK)){};
   \                     ??SDHC_init_1:
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x400b1024
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD1F8             BNE.N    ??SDHC_init_1
    204          
    205              /* Init GPIO again */
    206              PORTE_PCR(0) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x4004d000
   \   0000005E   0xF240 0x4143      MOVW     R1,#+1091
   \   00000062   0x6001             STR      R1,[R0, #+0]
    207              PORTE_PCR(1) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x4004d004
   \   00000068   0xF240 0x4143      MOVW     R1,#+1091
   \   0000006C   0x6001             STR      R1,[R0, #+0]
    208              PORTE_PCR(2) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x4004d008
   \   00000072   0xF44F 0x6188      MOV      R1,#+1088
   \   00000076   0x6001             STR      R1,[R0, #+0]
    209              PORTE_PCR(3) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x4004d00c
   \   0000007C   0xF240 0x4143      MOVW     R1,#+1091
   \   00000080   0x6001             STR      R1,[R0, #+0]
    210              PORTE_PCR(4) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable9_5  ;; 0x4004d010
   \   00000086   0xF240 0x4143      MOVW     R1,#+1091
   \   0000008A   0x6001             STR      R1,[R0, #+0]
    211              PORTE_PCR(5) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable9_6  ;; 0x4004d014
   \   00000090   0xF240 0x4143      MOVW     R1,#+1091
   \   00000094   0x6001             STR      R1,[R0, #+0]
    212          
    213              /* Enable clock gate to SDHC module */
    214              SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable9_7  ;; 0x40048030
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable9_7  ;; 0x40048030
   \   000000A4   0x6008             STR      R0,[R1, #+0]
    215              
    216              /* Enable requests */
    217              SDHC_IRQSTAT = 0xFFFF;
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000AA   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000AE   0x6001             STR      R1,[R0, #+0]
    218              SDHC_IRQSTATEN = 	  SDHC_IRQSTATEN_DEBESEN_MASK | SDHC_IRQSTATEN_DCESEN_MASK | SDHC_IRQSTATEN_DTOESEN_MASK 
    219                                   | SDHC_IRQSTATEN_CIESEN_MASK | SDHC_IRQSTATEN_CEBESEN_MASK | SDHC_IRQSTATEN_CCESEN_MASK | SDHC_IRQSTATEN_CTOESEN_MASK 
    220                                   | SDHC_IRQSTATEN_BRRSEN_MASK | SDHC_IRQSTATEN_BWRSEN_MASK | SDHC_IRQSTATEN_CRMSEN_MASK
    221                                   | SDHC_IRQSTATEN_TCSEN_MASK | SDHC_IRQSTATEN_CCSEN_MASK;
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable10_1  ;; 0x400b1034
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x7f00b3
   \   000000B8   0x6001             STR      R1,[R0, #+0]
    222              
    223              /* 80 initial clocks */
    224              SDHC_SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x400b102c
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x400b102c
   \   000000C8   0x6008             STR      R0,[R1, #+0]
    225              while (SDHC_SYSCTL & SDHC_SYSCTL_INITA_MASK){};
   \                     ??SDHC_init_2:
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x400b102c
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x0100             LSLS     R0,R0,#+4
   \   000000D2   0xD4FA             BMI.N    ??SDHC_init_2
    226          
    227              /* Check card */
    228              if (SDHC_PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x400b1024
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x03C0             LSLS     R0,R0,#+15
   \   000000DC   0xD501             BPL.N    ??SDHC_init_3
    229              {
    230                  esdhc_info_ptr->CARD = ESDHC_CARD_UNKNOWN;
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x6020             STR      R0,[R4, #+0]
    231              }
    232              SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??SDHC_init_3:
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000F0   0x6008             STR      R0,[R1, #+0]
    233              
    234              return ESDHC_OK;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xBD10             POP      {R4,PC}          ;; return
    235          }
    236          
    237          /*FUNCTION****************************************************************
    238          * 
    239          * Function Name    : _esdhc_is_running
    240          * Returned Value   : TRUE if running, FALSE otherwise
    241          * Comments         :
    242          *    Checks whether eSDHC module is currently in use.
    243          *
    244          *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    245          static U8 SDHC_is_running(void)
    246          {
    247              return (0 != (SDHC_PRSSTAT & (SDHC_PRSSTAT_RTA_MASK | SDHC_PRSSTAT_WTA_MASK | SDHC_PRSSTAT_DLA_MASK | SDHC_PRSSTAT_CDIHB_MASK | SDHC_PRSSTAT_CIHB_MASK)));
   \                     SDHC_is_running:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x400b1024
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF240 0x3107      MOVW     R1,#+775
   \   0000000A   0x4208             TST      R0,R1
   \   0000000C   0xD001             BEQ.N    ??SDHC_is_running_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??SDHC_is_running_1
   \                     ??SDHC_is_running_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??SDHC_is_running_1:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    248          }   
    249          
    250          /*FUNCTION****************************************************************
    251          * 
    252          * Function Name    : SDHC_status_wait
    253          * Returned Value   : bits set for given mask
    254          * Comments         :
    255          *    Waits for ESDHC interrupt status register bits according to given mask.
    256          *
    257          *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    258          static U32 SDHC_status_wait(U32 mask)        /* [IN] Mask of IRQSTAT bits to wait for */
    259          {
    260              U32 result;
    261              do
    262              {
    263                  result = SDHC_IRQSTAT & mask;
   \                     SDHC_status_wait:
   \                     ??SDHC_status_wait_0:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x4001             ANDS     R1,R0,R1
    264              } 
    265              while (0 == result);
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD0F9             BEQ.N    ??SDHC_status_wait_0
    266              return result;
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    267          }   
    268          
    269          /*FUNCTION****************************************************************
    270          * 
    271          * Function Name    : SDHC_send_command
    272          * Returned Value   : 0 on success, 1 on error, -1 on timeout
    273          * Comments         :
    274          *    One ESDHC command transaction.
    275          *
    276          *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    277          static U32 SDHC_send_command (ESDHC_COMMAND_STRUCT_PTR command) /* [IN/OUT] Command specification */
    278          {
   \                     SDHC_send_command:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    279              U32 xfertyp;
    280              
    281              /* Check command */
    282              xfertyp = ESDHC_COMMAND_XFERTYP[command->COMMAND & 0x3F];
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   0000000E   0xF851 0x5020      LDR      R5,[R1, R0, LSL #+2]
    283              if ((0 == xfertyp) && (0 != command->COMMAND))
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD104             BNE.N    ??SDHC_send_command_0
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??SDHC_send_command_0
    284              {
    285                  return 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE0B0             B.N      ??SDHC_send_command_1
    286              }
    287          
    288              /* Card removal check preparation */
    289              SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??SDHC_send_command_0:
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    290          
    291              /* Wait for cmd line idle */
    292              while (SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB_MASK){};
   \                     ??SDHC_send_command_2:
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x400b1024
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x07C0             LSLS     R0,R0,#+31
   \   00000038   0xD4FA             BMI.N    ??SDHC_send_command_2
    293          
    294              /* Setup command */
    295              SDHC_CMDARG = command->ARGUMENT;
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable10_4  ;; 0x400b1008
   \   00000040   0x6008             STR      R0,[R1, #+0]
    296              xfertyp &= (~ SDHC_XFERTYP_CMDTYP_MASK);
   \   00000042   0xF435 0x0540      BICS     R5,R5,#0xC00000
    297              xfertyp |= SDHC_XFERTYP_CMDTYP(command->TYPE);
   \   00000046   0x7860             LDRB     R0,[R4, #+1]
   \   00000048   0x0580             LSLS     R0,R0,#+22
   \   0000004A   0xF410 0x0040      ANDS     R0,R0,#0xC00000
   \   0000004E   0x4305             ORRS     R5,R0,R5
    298              if (ESDHC_TYPE_RESUME == command->TYPE)
   \   00000050   0x7860             LDRB     R0,[R4, #+1]
   \   00000052   0x2802             CMP      R0,#+2
   \   00000054   0xD101             BNE.N    ??SDHC_send_command_3
    299              {
    300                  xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   00000056   0xF455 0x1500      ORRS     R5,R5,#0x200000
    301              }
    302              if (ESDHC_TYPE_SWITCH_BUSY == command->TYPE)
   \                     ??SDHC_send_command_3:
   \   0000005A   0x7860             LDRB     R0,[R4, #+1]
   \   0000005C   0x2804             CMP      R0,#+4
   \   0000005E   0xD10D             BNE.N    ??SDHC_send_command_4
    303              {
    304                  if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) == SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48))
   \   00000060   0xF415 0x3040      ANDS     R0,R5,#0x30000
   \   00000064   0xF5B0 0x3F00      CMP      R0,#+131072
   \   00000068   0xD104             BNE.N    ??SDHC_send_command_5
    305                  {
    306                      xfertyp &= (~ SDHC_XFERTYP_RSPTYP_MASK);
   \   0000006A   0xF435 0x3540      BICS     R5,R5,#0x30000
    307                      xfertyp |= SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY);
   \   0000006E   0xF455 0x3540      ORRS     R5,R5,#0x30000
   \   00000072   0xE003             B.N      ??SDHC_send_command_4
    308                  }
    309                  else
    310                  {
    311                      xfertyp &= (~ SDHC_XFERTYP_RSPTYP_MASK);
   \                     ??SDHC_send_command_5:
   \   00000074   0xF435 0x3540      BICS     R5,R5,#0x30000
    312                      xfertyp |= SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48);
   \   00000078   0xF455 0x3500      ORRS     R5,R5,#0x20000
    313                  }
    314              }
    315              SDHC_BLKATTR &= (~ SDHC_BLKATTR_BLKCNT_MASK);
   \                     ??SDHC_send_command_4:
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x400b1004
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x400b1004
   \   00000088   0x6008             STR      R0,[R1, #+0]
    316              if (0 != command->BLOCKS)
   \   0000008A   0x68E0             LDR      R0,[R4, #+12]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD01F             BEQ.N    ??SDHC_send_command_6
    317              {
    318                  if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) != SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY))
   \   00000090   0xF415 0x3040      ANDS     R0,R5,#0x30000
   \   00000094   0xF5B0 0x3F40      CMP      R0,#+196608
   \   00000098   0xD001             BEQ.N    ??SDHC_send_command_7
    319                  {
    320                      xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   0000009A   0xF455 0x1500      ORRS     R5,R5,#0x200000
    321                  }
    322                  if (command->READ)
   \                     ??SDHC_send_command_7:
   \   0000009E   0x7A20             LDRB     R0,[R4, #+8]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD001             BEQ.N    ??SDHC_send_command_8
    323                  {
    324                      xfertyp |= SDHC_XFERTYP_DTDSEL_MASK;    
   \   000000A4   0xF055 0x0510      ORRS     R5,R5,#0x10
    325                  }
    326                  if (command->BLOCKS > 1)
   \                     ??SDHC_send_command_8:
   \   000000A8   0x68E0             LDR      R0,[R4, #+12]
   \   000000AA   0x2802             CMP      R0,#+2
   \   000000AC   0xD301             BCC.N    ??SDHC_send_command_9
    327                  {
    328                      xfertyp |= SDHC_XFERTYP_MSBSEL_MASK;    
   \   000000AE   0xF055 0x0520      ORRS     R5,R5,#0x20
    329                  }
    330                  if ((U32)-1 != command->BLOCKS)
   \                     ??SDHC_send_command_9:
   \   000000B2   0x68E0             LDR      R0,[R4, #+12]
   \   000000B4   0xF110 0x0F01      CMN      R0,#+1
   \   000000B8   0xD00A             BEQ.N    ??SDHC_send_command_6
    331                  {
    332                      SDHC_BLKATTR |= SDHC_BLKATTR_BLKCNT(command->BLOCKS);
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x400b1004
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0x68E1             LDR      R1,[R4, #+12]
   \   000000C2   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x400b1004
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    333                      xfertyp |= SDHC_XFERTYP_BCEN_MASK;
   \   000000CC   0xF055 0x0502      ORRS     R5,R5,#0x2
    334                  }
    335              }
    336          
    337              /* Issue command */
    338              SDHC_DSADDR = 0;
   \                     ??SDHC_send_command_6:
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x400b1000
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x6001             STR      R1,[R0, #+0]
    339              SDHC_XFERTYP = xfertyp;
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable11_1  ;; 0x400b100c
   \   000000DC   0x6005             STR      R5,[R0, #+0]
    340              
    341              /* Wait for response */
    342              if (SDHC_status_wait (SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK) != SDHC_IRQSTAT_CC_MASK)
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0xe0001
   \   000000E2   0x.... 0x....      BL       SDHC_status_wait
   \   000000E6   0x2801             CMP      R0,#+1
   \   000000E8   0xD00B             BEQ.N    ??SDHC_send_command_10
    343              {
    344                  SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xF440 0x2070      ORR      R0,R0,#0xF0000
   \   000000F4   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000000FC   0x6008             STR      R0,[R1, #+0]
    345                  return 1;
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0xE03F             B.N      ??SDHC_send_command_1
    346              }
    347          
    348              /* Check card removal */
    349              if (SDHC_IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \                     ??SDHC_send_command_10:
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0x0600             LSLS     R0,R0,#+24
   \   0000010A   0xD509             BPL.N    ??SDHC_send_command_11
    350              {
    351                  SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   0000011A   0x6008             STR      R0,[R1, #+0]
    352                  return 1;
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0xE030             B.N      ??SDHC_send_command_1
    353              }
    354          
    355              /* Get response, if available */
    356              if (SDHC_IRQSTAT & SDHC_IRQSTAT_CTOE_MASK)
   \                     ??SDHC_send_command_11:
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0x03C0             LSLS     R0,R0,#+15
   \   00000128   0xD50A             BPL.N    ??SDHC_send_command_12
    357              {
    358                  SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   0000012E   0x6800             LDR      R0,[R0, #+0]
   \   00000130   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   00000138   0x6008             STR      R0,[R1, #+0]
    359                  return -1;
   \   0000013A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000013E   0xE020             B.N      ??SDHC_send_command_1
    360              }
    361              if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) != SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO))
   \                     ??SDHC_send_command_12:
   \   00000140   0xF415 0x3F40      TST      R5,#0x30000
   \   00000144   0xD014             BEQ.N    ??SDHC_send_command_13
    362              {
    363                  command->RESPONSE[0] = SDHC_CMDRSP(0);
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x400b1010
   \   0000014A   0x6800             LDR      R0,[R0, #+0]
   \   0000014C   0x6120             STR      R0,[R4, #+16]
    364                  if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) == SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136))
   \   0000014E   0xF415 0x3040      ANDS     R0,R5,#0x30000
   \   00000152   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000156   0xD10B             BNE.N    ??SDHC_send_command_13
    365                  {
    366                      command->RESPONSE[1] = SDHC_CMDRSP(1);
   \   00000158   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x400b1014
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0x6160             STR      R0,[R4, #+20]
    367                      command->RESPONSE[2] = SDHC_CMDRSP(2);
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x400b1018
   \   00000164   0x6800             LDR      R0,[R0, #+0]
   \   00000166   0x61A0             STR      R0,[R4, #+24]
    368                      command->RESPONSE[3] = SDHC_CMDRSP(3);
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x400b101c
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0x61E0             STR      R0,[R4, #+28]
    369                  }
    370              }
    371              
    372              SDHC_IRQSTAT |= SDHC_IRQSTAT_CC_MASK;
   \                     ??SDHC_send_command_13:
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000174   0x6800             LDR      R0,[R0, #+0]
   \   00000176   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   0000017E   0x6008             STR      R0,[R1, #+0]
    373          
    374              return 0;
   \   00000180   0x2000             MOVS     R0,#+0
   \                     ??SDHC_send_command_1:
   \   00000182   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    375          }
    376          
    377          
    378          /*FUNCTION****************************************************************
    379          * 
    380          * Function Name    : _esdhc_ioctl
    381          * Returned Value   : MQX error code
    382          * Comments         : 
    383          *    This function performs miscellaneous services for the ESDHC I/O device.  
    384          *
    385          *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    386          S32 SDHC_ioctl
    387                  (
    388                  /* [IN] The command to perform */
    389                  U32              cmd,
    390                  
    391                  /* [IN/OUT] Parameters for the command */
    392                  void                *param_ptr
    393                  )
    394          {
   \                     SDHC_ioctl:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x000E             MOVS     R6,R1
    395              ESDHC_INFO_STRUCT_PTR   esdhc_info_ptr;
    396              ESDHC_DEVICE_STRUCT_PTR esdhc_device_ptr;
    397              ESDHC_INIT_STRUCT_CPTR  esdhc_init_ptr;
    398              ESDHC_COMMAND_STRUCT    command;
    399              U8                      mem, io, mmc, ceata, mp, hc;
    400              U32                  val;
    401              U32                  result = ESDHC_OK;
   \   00000008   0xF05F 0x0B00      MOVS     R11,#+0
    402              U32                  *param32_ptr = param_ptr;
    403          
    404              /* Check parameters */
    405              esdhc_info_ptr = (ESDHC_INFO_STRUCT_PTR)&SDHC_Info;
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable16
    406              
    407              if (NULL == esdhc_info_ptr)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD102             BNE.N    ??SDHC_ioctl_0
    408              {
    409                  return IO_DEVICE_DOES_NOT_EXIST;
   \   00000014   0xF640 0x2001      MOVW     R0,#+2561
   \   00000018   0xE2E2             B.N      ??SDHC_ioctl_1
    410              }
    411              
    412              esdhc_device_ptr = &SDHC_Device;
   \                     ??SDHC_ioctl_0:
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable16_1
    413              if (NULL == esdhc_device_ptr)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD102             BNE.N    ??SDHC_ioctl_2
    414              {
    415                  return IO_ERROR_DEVICE_INVALID;
   \   00000022   0xF640 0x200B      MOVW     R0,#+2571
   \   00000026   0xE2DB             B.N      ??SDHC_ioctl_1
    416              }
    417              
    418              esdhc_init_ptr = esdhc_device_ptr->INIT;
   \                     ??SDHC_ioctl_2:
   \   00000028   0x680D             LDR      R5,[R1, #+0]
    419              if (NULL == esdhc_init_ptr)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD102             BNE.N    ??SDHC_ioctl_3
    420              {
    421                  return IO_ERROR_DEVICE_INVALID;
   \   0000002E   0xF640 0x200B      MOVW     R0,#+2571
   \   00000032   0xE2D5             B.N      ??SDHC_ioctl_1
    422              }    
    423              
    424              switch (cmd) 
   \                     ??SDHC_ioctl_3:
   \   00000034   0x1EC0             SUBS     R0,R0,#+3
   \   00000036   0xF000 0x82B4      BEQ.W    ??SDHC_ioctl_4
   \   0000003A   0x1F80             SUBS     R0,R0,#+6
   \   0000003C   0xF000 0x82A9      BEQ.W    ??SDHC_ioctl_5
   \   00000040   0xF241 0x21F8      MOVW     R1,#+4856
   \   00000044   0x1A40             SUBS     R0,R0,R1
   \   00000046   0xD018             BEQ.N    ??SDHC_ioctl_6
   \   00000048   0x1E40             SUBS     R0,R0,#+1
   \   0000004A   0xF000 0x8162      BEQ.W    ??SDHC_ioctl_7
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0xF000 0x826E      BEQ.W    ??SDHC_ioctl_8
   \   00000054   0x1E40             SUBS     R0,R0,#+1
   \   00000056   0xF000 0x8166      BEQ.W    ??SDHC_ioctl_9
   \   0000005A   0x1E40             SUBS     R0,R0,#+1
   \   0000005C   0xF000 0x817B      BEQ.W    ??SDHC_ioctl_10
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0xF000 0x81FF      BEQ.W    ??SDHC_ioctl_11
   \   00000066   0x1E40             SUBS     R0,R0,#+1
   \   00000068   0xF000 0x821B      BEQ.W    ??SDHC_ioctl_12
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \   0000006E   0xF000 0x81C7      BEQ.W    ??SDHC_ioctl_13
   \   00000072   0x1E40             SUBS     R0,R0,#+1
   \   00000074   0xF000 0x81D0      BEQ.W    ??SDHC_ioctl_14
   \   00000078   0xE2AF             B.N      ??SDHC_ioctl_15
    425              {
    426                  case IO_IOCTL_ESDHC_INIT:
    427          
    428                      result = SDHC_init (esdhc_info_ptr, &K60_SDHC0_init);
   \                     ??SDHC_ioctl_6:
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       SDHC_init
   \   00000084   0x4683             MOV      R11,R0
    429                      if (ESDHC_OK != result)
   \   00000086   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000008A   0xF040 0x82A8      BNE.W    ??SDHC_ioctl_16
    430                      {
    431                          break;
    432                      }
    433                      
    434                      mem = FALSE;
   \                     ??SDHC_ioctl_17:
   \   0000008E   0x2600             MOVS     R6,#+0
    435                      io = FALSE;
   \   00000090   0x2700             MOVS     R7,#+0
    436                      mmc = FALSE;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xF88D 0x0020      STRB     R0,[SP, #+32]
    437                      ceata = FALSE;
   \   00000098   0xF05F 0x0800      MOVS     R8,#+0
    438                      hc = FALSE;
   \   0000009C   0xF05F 0x0900      MOVS     R9,#+0
    439                      mp = FALSE;
   \   000000A0   0xF05F 0x0A00      MOVS     R10,#+0
    440          
    441                      /* CMD0 - Go to idle - reset card */
    442                      command.COMMAND = ESDHC_CMD0;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF88D 0x0000      STRB     R0,[SP, #+0]
    443                      command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF88D 0x0001      STRB     R0,[SP, #+1]
    444                      command.ARGUMENT = 0;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x9001             STR      R0,[SP, #+4]
    445                      command.READ = FALSE;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF88D 0x0008      STRB     R0,[SP, #+8]
    446                      command.BLOCKS = 0;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x9003             STR      R0,[SP, #+12]
    447                      if (SDHC_send_command (&command))
   \   000000BE   0xA800             ADD      R0,SP,#+0
   \   000000C0   0x.... 0x....      BL       SDHC_send_command
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD002             BEQ.N    ??SDHC_ioctl_18
    448                      {
    449                          result = ESDHC_ERROR_INIT_FAILED;
   \   000000C8   0xF05F 0x0B01      MOVS     R11,#+1
    450                          break;
   \   000000CC   0xE287             B.N      ??SDHC_ioctl_16
    451                      }
    452                      
    453                      Delay(1100);
   \                     ??SDHC_ioctl_18:
   \   000000CE   0xF240 0x404C      MOVW     R0,#+1100
   \   000000D2   0x.... 0x....      BL       Delay
    454          
    455                      /* CMD8 - Send interface condition - check HC support */
    456                      command.COMMAND = ESDHC_CMD8;
   \   000000D6   0x2008             MOVS     R0,#+8
   \   000000D8   0xF88D 0x0000      STRB     R0,[SP, #+0]
    457                      command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xF88D 0x0001      STRB     R0,[SP, #+1]
    458                      command.ARGUMENT = 0x000001AA;
   \   000000E2   0xF44F 0x70D5      MOV      R0,#+426
   \   000000E6   0x9001             STR      R0,[SP, #+4]
    459                      command.READ = FALSE;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xF88D 0x0008      STRB     R0,[SP, #+8]
    460                      command.BLOCKS = 0;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x9003             STR      R0,[SP, #+12]
    461                      val = SDHC_send_command (&command);
   \   000000F2   0xA800             ADD      R0,SP,#+0
   \   000000F4   0x.... 0x....      BL       SDHC_send_command
   \   000000F8   0x4682             MOV      R10,R0
    462                      
    463                      if (val == 0)
   \   000000FA   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000FE   0xD108             BNE.N    ??SDHC_ioctl_19
    464                      {
    465                          // SDHC Card
    466                          if (command.RESPONSE[0] != command.ARGUMENT)
   \   00000100   0x9804             LDR      R0,[SP, #+16]
   \   00000102   0x9901             LDR      R1,[SP, #+4]
   \   00000104   0x4288             CMP      R0,R1
   \   00000106   0xD002             BEQ.N    ??SDHC_ioctl_20
    467                          {
    468                              result = ESDHC_ERROR_INIT_FAILED;
   \   00000108   0xF05F 0x0B01      MOVS     R11,#+1
    469                              break;
   \   0000010C   0xE267             B.N      ??SDHC_ioctl_16
    470                          }
    471                          hc = TRUE;
   \                     ??SDHC_ioctl_20:
   \   0000010E   0xF05F 0x0901      MOVS     R9,#+1
    472                      }
    473          
    474                      mp = TRUE;
   \                     ??SDHC_ioctl_19:
   \   00000112   0xF05F 0x0A01      MOVS     R10,#+1
    475                      
    476                      if (mp)
   \   00000116   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000011A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000011E   0xF000 0x8088      BEQ.W    ??SDHC_ioctl_21
    477                      {
    478                          /* CMD55 - Application specific command - check MMC */
    479                          command.COMMAND = ESDHC_CMD55;
   \   00000122   0x2037             MOVS     R0,#+55
   \   00000124   0xF88D 0x0000      STRB     R0,[SP, #+0]
    480                          command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    481                          command.ARGUMENT = 0;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x9001             STR      R0,[SP, #+4]
    482                          command.READ = FALSE;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xF88D 0x0008      STRB     R0,[SP, #+8]
    483                          command.BLOCKS = 0;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x9003             STR      R0,[SP, #+12]
    484                          val = SDHC_send_command (&command);
   \   0000013C   0xA800             ADD      R0,SP,#+0
   \   0000013E   0x.... 0x....      BL       SDHC_send_command
   \   00000142   0x4682             MOV      R10,R0
    485                          if (val > 0)
   \   00000144   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000148   0xD002             BEQ.N    ??SDHC_ioctl_22
    486                          {
    487                              result = ESDHC_ERROR_INIT_FAILED;
   \   0000014A   0xF05F 0x0B01      MOVS     R11,#+1
    488                              break;
   \   0000014E   0xE246             B.N      ??SDHC_ioctl_16
    489                          }
    490                          if (val < 0)
    491                          {
    492                              /* MMC or CE-ATA */
    493                              io = FALSE;
    494                              mem = FALSE;
    495                              hc = FALSE;
    496                              
    497                              /* CMD1 - Send operating conditions - check HC */
    498                              command.COMMAND = ESDHC_CMD1;
    499                              command.TYPE = ESDHC_TYPE_NORMAL;
    500                              command.ARGUMENT = 0x40300000;
    501                              command.READ = FALSE;
    502                              command.BLOCKS = 0;
    503                              if (SDHC_send_command (&command))
    504                              {
    505                                  result = ESDHC_ERROR_INIT_FAILED;
    506                                  break;
    507                              }
    508                              if (0x20000000 == (command.RESPONSE[0] & 0x60000000))
    509                              {
    510                                  hc = TRUE;
    511                              }
    512                              mmc = TRUE;
    513          
    514                              /* CMD39 - Fast IO - check CE-ATA signature CE */
    515                              command.COMMAND = ESDHC_CMD39;
    516                              command.TYPE = ESDHC_TYPE_NORMAL;
    517                              command.ARGUMENT = 0x0C00;
    518                              command.READ = FALSE;
    519                              command.BLOCKS = 0;
    520                              if (SDHC_send_command (&command))
    521                              {
    522                                  result = ESDHC_ERROR_INIT_FAILED;
    523                                  break;
    524                              }
    525                              if (0xCE == (command.RESPONSE[0] >> 8) & 0xFF)
    526                              {
    527                                  /* CMD39 - Fast IO - check CE-ATA signature AA */
    528                                  command.COMMAND = ESDHC_CMD39;
    529                                  command.TYPE = ESDHC_TYPE_NORMAL;
    530                                  command.ARGUMENT = 0x0D00;
    531                                  command.READ = FALSE;
    532                                  command.BLOCKS = 0;
    533                                  if (SDHC_send_command (&command))
    534                                  {
    535                                      result = ESDHC_ERROR_INIT_FAILED;
    536                                      break;
    537                                  }
    538                                  if (0xAA == (command.RESPONSE[0] >> 8) & 0xFF)
    539                                  {
    540                                      mmc = FALSE;
    541                                      ceata = TRUE;
    542                                  }
    543                              }
    544                          }
    545                          else
    546                          {
    547                              /* SD */
    548                              /* ACMD41 - Send Operating Conditions */
    549                              command.COMMAND = ESDHC_ACMD41;
   \                     ??SDHC_ioctl_22:
   \   00000150   0x2069             MOVS     R0,#+105
   \   00000152   0xF88D 0x0000      STRB     R0,[SP, #+0]
    550                              command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xF88D 0x0001      STRB     R0,[SP, #+1]
    551                              command.ARGUMENT = 0;
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0x9001             STR      R0,[SP, #+4]
    552                              command.READ = FALSE;
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0xF88D 0x0008      STRB     R0,[SP, #+8]
    553                              command.BLOCKS = 0;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0x9003             STR      R0,[SP, #+12]
    554                              if (SDHC_send_command (&command))
   \   0000016A   0xA800             ADD      R0,SP,#+0
   \   0000016C   0x.... 0x....      BL       SDHC_send_command
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0xD002             BEQ.N    ??SDHC_ioctl_23
    555                              {
    556                                  result = ESDHC_ERROR_INIT_FAILED;
   \   00000174   0xF05F 0x0B01      MOVS     R11,#+1
    557                                  break;
   \   00000178   0xE231             B.N      ??SDHC_ioctl_16
    558                              }
    559                              if (command.RESPONSE[0] & 0x300000)
   \                     ??SDHC_ioctl_23:
   \   0000017A   0x9804             LDR      R0,[SP, #+16]
   \   0000017C   0xF410 0x1F40      TST      R0,#0x300000
   \   00000180   0xD057             BEQ.N    ??SDHC_ioctl_21
    560                              {
    561                                  val = 0;
   \   00000182   0xF05F 0x0A00      MOVS     R10,#+0
    562                                  do 
    563                                  {
    564                                      Delay(BSP_ALARM_RESOLUTION);
   \                     ??SDHC_ioctl_24:
   \   00000186   0x200A             MOVS     R0,#+10
   \   00000188   0x.... 0x....      BL       Delay
    565                                      val++;
   \   0000018C   0xF11A 0x0A01      ADDS     R10,R10,#+1
    566                                      
    567                                      /* CMD55 + ACMD41 - Send OCR */
    568                                      command.COMMAND = ESDHC_CMD55;
   \   00000190   0x2037             MOVS     R0,#+55
   \   00000192   0xF88D 0x0000      STRB     R0,[SP, #+0]
    569                                      command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0xF88D 0x0001      STRB     R0,[SP, #+1]
    570                                      command.ARGUMENT = 0;
   \   0000019C   0x2000             MOVS     R0,#+0
   \   0000019E   0x9001             STR      R0,[SP, #+4]
    571                                      command.READ = FALSE;
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0xF88D 0x0008      STRB     R0,[SP, #+8]
    572                                      command.BLOCKS = 0;
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0x9003             STR      R0,[SP, #+12]
    573                                      if (SDHC_send_command (&command))
   \   000001AA   0xA800             ADD      R0,SP,#+0
   \   000001AC   0x.... 0x....      BL       SDHC_send_command
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD002             BEQ.N    ??SDHC_ioctl_25
    574                                      {
    575                                          result = ESDHC_ERROR_INIT_FAILED;
   \   000001B4   0xF05F 0x0B01      MOVS     R11,#+1
    576                                          break;
   \   000001B8   0xE024             B.N      ??SDHC_ioctl_26
    577                                      }
    578          
    579                                      command.COMMAND = ESDHC_ACMD41;
   \                     ??SDHC_ioctl_25:
   \   000001BA   0x2069             MOVS     R0,#+105
   \   000001BC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    580                                      command.TYPE = ESDHC_TYPE_NORMAL;
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0xF88D 0x0001      STRB     R0,[SP, #+1]
    581                                      if (hc)
   \   000001C6   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001CA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001CE   0xD003             BEQ.N    ??SDHC_ioctl_27
    582                                      {
    583                                          command.ARGUMENT = 0x40300000;
   \   000001D0   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40300000
   \   000001D4   0x9001             STR      R0,[SP, #+4]
   \   000001D6   0xE002             B.N      ??SDHC_ioctl_28
    584                                      }
    585                                      else
    586                                      {
    587                                          command.ARGUMENT = 0x00300000;
   \                     ??SDHC_ioctl_27:
   \   000001D8   0xF45F 0x1040      MOVS     R0,#+3145728
   \   000001DC   0x9001             STR      R0,[SP, #+4]
    588                                      }
    589                                      command.READ = FALSE;
   \                     ??SDHC_ioctl_28:
   \   000001DE   0x2000             MOVS     R0,#+0
   \   000001E0   0xF88D 0x0008      STRB     R0,[SP, #+8]
    590                                      command.BLOCKS = 0;
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0x9003             STR      R0,[SP, #+12]
    591                                      if (SDHC_send_command (&command))
   \   000001E8   0xA800             ADD      R0,SP,#+0
   \   000001EA   0x.... 0x....      BL       SDHC_send_command
   \   000001EE   0x2800             CMP      R0,#+0
   \   000001F0   0xD002             BEQ.N    ??SDHC_ioctl_29
    592                                      {
    593                                          result = ESDHC_ERROR_INIT_FAILED;
   \   000001F2   0xF05F 0x0B01      MOVS     R11,#+1
    594                                          break;
   \   000001F6   0xE005             B.N      ??SDHC_ioctl_26
    595                                      }
    596                                  } while ((0 == (command.RESPONSE[0] & 0x80000000)) && (val < BSP_ALARM_FREQUENCY));
   \                     ??SDHC_ioctl_29:
   \   000001F8   0x9804             LDR      R0,[SP, #+16]
   \   000001FA   0x2800             CMP      R0,#+0
   \   000001FC   0xD402             BMI.N    ??SDHC_ioctl_26
   \   000001FE   0xF1BA 0x0F64      CMP      R10,#+100
   \   00000202   0xD3C0             BCC.N    ??SDHC_ioctl_24
    597                                  if (ESDHC_OK != result)
   \                     ??SDHC_ioctl_26:
   \   00000204   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000208   0xF040 0x81E9      BNE.W    ??SDHC_ioctl_16
    598                                  {
    599                                      break;
    600                                  }
    601                                  if (val >= BSP_ALARM_FREQUENCY)
   \                     ??SDHC_ioctl_30:
   \   0000020C   0xF1BA 0x0F64      CMP      R10,#+100
   \   00000210   0xD302             BCC.N    ??SDHC_ioctl_31
    602                                  {
    603                                      hc = FALSE;
   \   00000212   0xF05F 0x0900      MOVS     R9,#+0
   \   00000216   0xE00C             B.N      ??SDHC_ioctl_21
    604                                  }
    605                                  else
    606                                  {
    607                                      mem = TRUE;
   \                     ??SDHC_ioctl_31:
   \   00000218   0x2601             MOVS     R6,#+1
    608                                      if (hc)
   \   0000021A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000021E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000222   0xD006             BEQ.N    ??SDHC_ioctl_21
    609                                      {
    610                                          hc = FALSE;
   \   00000224   0xF05F 0x0900      MOVS     R9,#+0
    611                                          if (command.RESPONSE[0] & 0x40000000)
   \   00000228   0x9804             LDR      R0,[SP, #+16]
   \   0000022A   0x0040             LSLS     R0,R0,#+1
   \   0000022C   0xD501             BPL.N    ??SDHC_ioctl_21
    612                                          {
    613                                              hc = TRUE;
   \   0000022E   0xF05F 0x0901      MOVS     R9,#+1
    614                                          }
    615                                      }
    616                                  }
    617                              }
    618                          }
    619                      }
    620                      
    621                      
    622                      if (mmc)
   \                     ??SDHC_ioctl_21:
   \   00000232   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \   00000236   0x2800             CMP      R0,#+0
   \   00000238   0xD001             BEQ.N    ??SDHC_ioctl_32
    623                      {
    624                          esdhc_info_ptr->CARD = ESDHC_CARD_MMC;
   \   0000023A   0x2007             MOVS     R0,#+7
   \   0000023C   0x6020             STR      R0,[R4, #+0]
    625                      }
    626                      if (ceata)
   \                     ??SDHC_ioctl_32:
   \   0000023E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000242   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000246   0xD001             BEQ.N    ??SDHC_ioctl_33
    627                      {
    628                          esdhc_info_ptr->CARD = ESDHC_CARD_CEATA;
   \   00000248   0x2008             MOVS     R0,#+8
   \   0000024A   0x6020             STR      R0,[R4, #+0]
    629                      }
    630                      if (io)
   \                     ??SDHC_ioctl_33:
   \   0000024C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000024E   0x2F00             CMP      R7,#+0
   \   00000250   0xD001             BEQ.N    ??SDHC_ioctl_34
    631                      {
    632                          esdhc_info_ptr->CARD = ESDHC_CARD_SDIO;
   \   00000252   0x2004             MOVS     R0,#+4
   \   00000254   0x6020             STR      R0,[R4, #+0]
    633                      }
    634                      if (mem)
   \                     ??SDHC_ioctl_34:
   \   00000256   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000258   0x2E00             CMP      R6,#+0
   \   0000025A   0xD008             BEQ.N    ??SDHC_ioctl_35
    635                      {
    636                          esdhc_info_ptr->CARD = ESDHC_CARD_SD;
   \   0000025C   0x2002             MOVS     R0,#+2
   \   0000025E   0x6020             STR      R0,[R4, #+0]
    637                          if (hc)
   \   00000260   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000264   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000268   0xD001             BEQ.N    ??SDHC_ioctl_35
    638                          {
    639                              esdhc_info_ptr->CARD = ESDHC_CARD_SDHC;
   \   0000026A   0x2003             MOVS     R0,#+3
   \   0000026C   0x6020             STR      R0,[R4, #+0]
    640                          }
    641                      }
    642                      if (io && mem)
   \                     ??SDHC_ioctl_35:
   \   0000026E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000270   0x2F00             CMP      R7,#+0
   \   00000272   0xD00B             BEQ.N    ??SDHC_ioctl_36
   \   00000274   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000276   0x2E00             CMP      R6,#+0
   \   00000278   0xD008             BEQ.N    ??SDHC_ioctl_36
    643                      {
    644                          esdhc_info_ptr->CARD = ESDHC_CARD_SDCOMBO;
   \   0000027A   0x2005             MOVS     R0,#+5
   \   0000027C   0x6020             STR      R0,[R4, #+0]
    645                          if (hc)
   \   0000027E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000282   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000286   0xD001             BEQ.N    ??SDHC_ioctl_36
    646                          {
    647                              esdhc_info_ptr->CARD = ESDHC_CARD_SDHCCOMBO;
   \   00000288   0x2006             MOVS     R0,#+6
   \   0000028A   0x6020             STR      R0,[R4, #+0]
    648                          }
    649                      }
    650          
    651                      /* De-Init GPIO */
    652                      PORTE_PCR(0) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
   \                     ??SDHC_ioctl_36:
   \   0000028C   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x4004d000
   \   00000290   0x2100             MOVS     R1,#+0
   \   00000292   0x6001             STR      R1,[R0, #+0]
    653                      PORTE_PCR(1) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
   \   00000294   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x4004d004
   \   00000298   0x2100             MOVS     R1,#+0
   \   0000029A   0x6001             STR      R1,[R0, #+0]
    654                      PORTE_PCR(2) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
   \   0000029C   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x4004d008
   \   000002A0   0x2100             MOVS     R1,#+0
   \   000002A2   0x6001             STR      R1,[R0, #+0]
    655                      PORTE_PCR(3) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
   \   000002A4   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x4004d00c
   \   000002A8   0x2100             MOVS     R1,#+0
   \   000002AA   0x6001             STR      R1,[R0, #+0]
    656                      PORTE_PCR(4) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
   \   000002AC   0x.... 0x....      LDR.W    R0,??DataTable9_5  ;; 0x4004d010
   \   000002B0   0x2100             MOVS     R1,#+0
   \   000002B2   0x6001             STR      R1,[R0, #+0]
    657                      PORTE_PCR(5) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
   \   000002B4   0x.... 0x....      LDR.W    R0,??DataTable9_6  ;; 0x4004d014
   \   000002B8   0x2100             MOVS     R1,#+0
   \   000002BA   0x6001             STR      R1,[R0, #+0]
    658          
    659                      /* Set the ESDHC default baud rate */
    660                      SDHC_set_baudrate (esdhc_init_ptr->CLOCK_SPEED, esdhc_init_ptr->BAUD_RATE);
   \   000002BC   0x6869             LDR      R1,[R5, #+4]
   \   000002BE   0x68A8             LDR      R0,[R5, #+8]
   \   000002C0   0x.... 0x....      BL       SDHC_set_baudrate
    661          
    662                      /* Init GPIO again */
    663                      PORTE_PCR(0) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
   \   000002C4   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x4004d000
   \   000002C8   0xF240 0x4143      MOVW     R1,#+1091
   \   000002CC   0x6001             STR      R1,[R0, #+0]
    664                      PORTE_PCR(1) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
   \   000002CE   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x4004d004
   \   000002D2   0xF240 0x4143      MOVW     R1,#+1091
   \   000002D6   0x6001             STR      R1,[R0, #+0]
    665                      PORTE_PCR(2) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
   \   000002D8   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x4004d008
   \   000002DC   0xF44F 0x6188      MOV      R1,#+1088
   \   000002E0   0x6001             STR      R1,[R0, #+0]
    666                      PORTE_PCR(3) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
   \   000002E2   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x4004d00c
   \   000002E6   0xF240 0x4143      MOVW     R1,#+1091
   \   000002EA   0x6001             STR      R1,[R0, #+0]
    667                      PORTE_PCR(4) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
   \   000002EC   0x.... 0x....      LDR.W    R0,??DataTable9_5  ;; 0x4004d010
   \   000002F0   0xF240 0x4143      MOVW     R1,#+1091
   \   000002F4   0x6001             STR      R1,[R0, #+0]
    668                      PORTE_PCR(5) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
   \   000002F6   0x.... 0x....      LDR.W    R0,??DataTable9_6  ;; 0x4004d014
   \   000002FA   0xF240 0x4143      MOVW     R1,#+1091
   \   000002FE   0x6001             STR      R1,[R0, #+0]
    669          
    670                      /* Enable clock gate to SDHC module */
    671                      SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
   \   00000300   0x.... 0x....      LDR.W    R0,??DataTable9_7  ;; 0x40048030
   \   00000304   0x6800             LDR      R0,[R0, #+0]
   \   00000306   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   0000030A   0x.... 0x....      LDR.W    R1,??DataTable9_7  ;; 0x40048030
   \   0000030E   0x6008             STR      R0,[R1, #+0]
    672                      
    673                      break;
   \   00000310   0xE165             B.N      ??SDHC_ioctl_16
    674                  case IO_IOCTL_ESDHC_SEND_COMMAND:
    675                      val = SDHC_send_command ((ESDHC_COMMAND_STRUCT_PTR)param32_ptr);
   \                     ??SDHC_ioctl_7:
   \   00000312   0x0030             MOVS     R0,R6
   \   00000314   0x.... 0x....      BL       SDHC_send_command
   \   00000318   0x4682             MOV      R10,R0
    676                      if (val > 0)
   \   0000031A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000031E   0xD001             BEQ.N    ??SDHC_ioctl_37
    677                      {
    678                          result = ESDHC_ERROR_COMMAND_FAILED;
   \   00000320   0xF05F 0x0B02      MOVS     R11,#+2
    679                      }
    680                      if (val < 0)
    681                      {
    682                          result = ESDHC_ERROR_COMMAND_TIMEOUT;
    683                      }
    684                      break;
   \                     ??SDHC_ioctl_37:
   \   00000324   0xE15B             B.N      ??SDHC_ioctl_16
    685                  case IO_IOCTL_ESDHC_GET_BAUDRATE:
    686                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_9:
   \   00000326   0x2E00             CMP      R6,#+0
   \   00000328   0xD102             BNE.N    ??SDHC_ioctl_38
    687                      {
    688                          result = BRTOS_INVALID_PARAMETER;
   \   0000032A   0xF05F 0x0B0C      MOVS     R11,#+12
   \   0000032E   0xE011             B.N      ??SDHC_ioctl_39
    689                      } 
    690                      else 
    691                      {
    692                          /* Get actual baudrate */
    693                          val = ((SDHC_SYSCTL & SDHC_SYSCTL_SDCLKFS_MASK) >> SDHC_SYSCTL_SDCLKFS_SHIFT) << 1;
   \                     ??SDHC_ioctl_38:
   \   00000330   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x400b102c
   \   00000334   0x6800             LDR      R0,[R0, #+0]
   \   00000336   0x09C0             LSRS     R0,R0,#+7
   \   00000338   0xF410 0x7AFF      ANDS     R10,R0,#0x1FE
    694                          val *= ((SDHC_SYSCTL & SDHC_SYSCTL_DVS_MASK) >> SDHC_SYSCTL_DVS_SHIFT) + 1;
   \   0000033C   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x400b102c
   \   00000340   0x6800             LDR      R0,[R0, #+0]
   \   00000342   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \   00000346   0x1C40             ADDS     R0,R0,#+1
   \   00000348   0xFB00 0xFA0A      MUL      R10,R0,R10
    695                          *param32_ptr = (U32)((esdhc_init_ptr->CLOCK_SPEED) / val);
   \   0000034C   0x68A8             LDR      R0,[R5, #+8]
   \   0000034E   0xFBB0 0xF0FA      UDIV     R0,R0,R10
   \   00000352   0x6030             STR      R0,[R6, #+0]
    696                      }
    697                      break;
   \                     ??SDHC_ioctl_39:
   \   00000354   0xE143             B.N      ??SDHC_ioctl_16
    698                  case IO_IOCTL_ESDHC_SET_BAUDRATE:
    699                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_10:
   \   00000356   0x2E00             CMP      R6,#+0
   \   00000358   0xD102             BNE.N    ??SDHC_ioctl_40
    700                      {
    701                          result = BRTOS_INVALID_PARAMETER;
   \   0000035A   0xF05F 0x0B0C      MOVS     R11,#+12
   \   0000035E   0xE04E             B.N      ??SDHC_ioctl_41
    702                      } 
    703                      else if (0 == (*param32_ptr)) 
   \                     ??SDHC_ioctl_40:
   \   00000360   0x6830             LDR      R0,[R6, #+0]
   \   00000362   0x2800             CMP      R0,#+0
   \   00000364   0xD102             BNE.N    ??SDHC_ioctl_42
    704                      {
    705                          result = BRTOS_INVALID_PARAMETER;
   \   00000366   0xF05F 0x0B0C      MOVS     R11,#+12
   \   0000036A   0xE048             B.N      ??SDHC_ioctl_41
    706                      } 
    707                      else 
    708                      {
    709                          if (! SDHC_is_running())
   \                     ??SDHC_ioctl_42:
   \   0000036C   0x.... 0x....      BL       SDHC_is_running
   \   00000370   0x2800             CMP      R0,#+0
   \   00000372   0xD142             BNE.N    ??SDHC_ioctl_43
    710                          {
    711                              /* De-Init GPIO */
    712                              PORTE_PCR(0) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
   \   00000374   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x4004d000
   \   00000378   0x2100             MOVS     R1,#+0
   \   0000037A   0x6001             STR      R1,[R0, #+0]
    713                              PORTE_PCR(1) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
   \   0000037C   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x4004d004
   \   00000380   0x2100             MOVS     R1,#+0
   \   00000382   0x6001             STR      R1,[R0, #+0]
    714                              PORTE_PCR(2) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
   \   00000384   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x4004d008
   \   00000388   0x2100             MOVS     R1,#+0
   \   0000038A   0x6001             STR      R1,[R0, #+0]
    715                              PORTE_PCR(3) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
   \   0000038C   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x4004d00c
   \   00000390   0x2100             MOVS     R1,#+0
   \   00000392   0x6001             STR      R1,[R0, #+0]
    716                              PORTE_PCR(4) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
   \   00000394   0x.... 0x....      LDR.W    R0,??DataTable9_5  ;; 0x4004d010
   \   00000398   0x2100             MOVS     R1,#+0
   \   0000039A   0x6001             STR      R1,[R0, #+0]
    717                              PORTE_PCR(5) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
   \   0000039C   0x.... 0x....      LDR.W    R0,??DataTable9_6  ;; 0x4004d014
   \   000003A0   0x2100             MOVS     R1,#+0
   \   000003A2   0x6001             STR      R1,[R0, #+0]
    718          
    719                              /* Set closest baudrate */
    720                              SDHC_set_baudrate (esdhc_init_ptr->CLOCK_SPEED, *param32_ptr);
   \   000003A4   0x6831             LDR      R1,[R6, #+0]
   \   000003A6   0x68A8             LDR      R0,[R5, #+8]
   \   000003A8   0x.... 0x....      BL       SDHC_set_baudrate
    721          
    722                              /* Init GPIO again */
    723                              PORTE_PCR(0) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
   \   000003AC   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x4004d000
   \   000003B0   0xF240 0x4143      MOVW     R1,#+1091
   \   000003B4   0x6001             STR      R1,[R0, #+0]
    724                              PORTE_PCR(1) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
   \   000003B6   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x4004d004
   \   000003BA   0xF240 0x4143      MOVW     R1,#+1091
   \   000003BE   0x6001             STR      R1,[R0, #+0]
    725                              PORTE_PCR(2) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
   \   000003C0   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x4004d008
   \   000003C4   0xF44F 0x6188      MOV      R1,#+1088
   \   000003C8   0x6001             STR      R1,[R0, #+0]
    726                              PORTE_PCR(3) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
   \   000003CA   0x.... 0x....      LDR.W    R0,??DataTable9_4  ;; 0x4004d00c
   \   000003CE   0xF240 0x4143      MOVW     R1,#+1091
   \   000003D2   0x6001             STR      R1,[R0, #+0]
    727                              PORTE_PCR(4) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
   \   000003D4   0x.... 0x....      LDR.W    R0,??DataTable9_5  ;; 0x4004d010
   \   000003D8   0xF240 0x4143      MOVW     R1,#+1091
   \   000003DC   0x6001             STR      R1,[R0, #+0]
    728                              PORTE_PCR(5) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
   \   000003DE   0x.... 0x....      LDR.W    R0,??DataTable9_6  ;; 0x4004d014
   \   000003E2   0xF240 0x4143      MOVW     R1,#+1091
   \   000003E6   0x6001             STR      R1,[R0, #+0]
    729          
    730                              /* Enable clock gate to SDHC module */
    731                              SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
   \   000003E8   0x.... 0x....      LDR.W    R0,??DataTable9_7  ;; 0x40048030
   \   000003EC   0x6800             LDR      R0,[R0, #+0]
   \   000003EE   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   000003F2   0x.... 0x....      LDR.W    R1,??DataTable9_7  ;; 0x40048030
   \   000003F6   0x6008             STR      R0,[R1, #+0]
   \   000003F8   0xE001             B.N      ??SDHC_ioctl_41
    732                          }
    733                          else
    734                          {
    735                              result = IO_ERROR_DEVICE_BUSY;
   \                     ??SDHC_ioctl_43:
   \   000003FA   0xF640 0x2B0A      MOVW     R11,#+2570
    736                          }
    737                      }
    738                      break;
   \                     ??SDHC_ioctl_41:
   \   000003FE   0xE0EE             B.N      ??SDHC_ioctl_16
    739                  case IO_IOCTL_ESDHC_GET_BLOCK_SIZE:
    740                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_13:
   \   00000400   0x2E00             CMP      R6,#+0
   \   00000402   0xD102             BNE.N    ??SDHC_ioctl_44
    741                      {
    742                          result = BRTOS_INVALID_PARAMETER;
   \   00000404   0xF05F 0x0B0C      MOVS     R11,#+12
   \   00000408   0xE005             B.N      ??SDHC_ioctl_45
    743                      } 
    744                      else 
    745                      {
    746                          /* Get actual ESDHC block size */
    747                          *param32_ptr = (SDHC_BLKATTR & SDHC_BLKATTR_BLKSIZE_MASK) >> SDHC_BLKATTR_BLKSIZE_SHIFT;
   \                     ??SDHC_ioctl_44:
   \   0000040A   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x400b1004
   \   0000040E   0x6800             LDR      R0,[R0, #+0]
   \   00000410   0x04C0             LSLS     R0,R0,#+19       ;; ZeroExtS R0,R0,#+19,#+19
   \   00000412   0x0CC0             LSRS     R0,R0,#+19
   \   00000414   0x6030             STR      R0,[R6, #+0]
    748                      }       
    749                      break;
   \                     ??SDHC_ioctl_45:
   \   00000416   0xE0E2             B.N      ??SDHC_ioctl_16
    750                  case IO_IOCTL_ESDHC_SET_BLOCK_SIZE:
    751                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_14:
   \   00000418   0x2E00             CMP      R6,#+0
   \   0000041A   0xD102             BNE.N    ??SDHC_ioctl_46
    752                      {
    753                          result = BRTOS_INVALID_PARAMETER;
   \   0000041C   0xF05F 0x0B0C      MOVS     R11,#+12
   \   00000420   0xE01F             B.N      ??SDHC_ioctl_47
    754                      } 
    755                      else 
    756                      {
    757                          /* Set actual ESDHC block size */
    758                          if (! SDHC_is_running())
   \                     ??SDHC_ioctl_46:
   \   00000422   0x.... 0x....      BL       SDHC_is_running
   \   00000426   0x2800             CMP      R0,#+0
   \   00000428   0xD119             BNE.N    ??SDHC_ioctl_48
    759                          {
    760                              if (*param32_ptr > 0x0FFF)
   \   0000042A   0x6830             LDR      R0,[R6, #+0]
   \   0000042C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000430   0xD302             BCC.N    ??SDHC_ioctl_49
    761                              {
    762                                  result = BRTOS_INVALID_PARAMETER;
   \   00000432   0xF05F 0x0B0C      MOVS     R11,#+12
   \   00000436   0xE014             B.N      ??SDHC_ioctl_47
    763                              }
    764                              else
    765                              {
    766                                  SDHC_BLKATTR &= (~ SDHC_BLKATTR_BLKSIZE_MASK); 
   \                     ??SDHC_ioctl_49:
   \   00000438   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x400b1004
   \   0000043C   0x6800             LDR      R0,[R0, #+0]
   \   0000043E   0x0B40             LSRS     R0,R0,#+13
   \   00000440   0x0340             LSLS     R0,R0,#+13
   \   00000442   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x400b1004
   \   00000446   0x6008             STR      R0,[R1, #+0]
    767                                  SDHC_BLKATTR |= SDHC_BLKATTR_BLKSIZE(*param32_ptr);
   \   00000448   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x400b1004
   \   0000044C   0x6800             LDR      R0,[R0, #+0]
   \   0000044E   0x6831             LDR      R1,[R6, #+0]
   \   00000450   0x04C9             LSLS     R1,R1,#+19       ;; ZeroExtS R1,R1,#+19,#+19
   \   00000452   0x0CC9             LSRS     R1,R1,#+19
   \   00000454   0x4308             ORRS     R0,R1,R0
   \   00000456   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x400b1004
   \   0000045A   0x6008             STR      R0,[R1, #+0]
   \   0000045C   0xE001             B.N      ??SDHC_ioctl_47
    768                              }
    769                          }
    770                          else
    771                          {
    772                              result = IO_ERROR_DEVICE_BUSY;
   \                     ??SDHC_ioctl_48:
   \   0000045E   0xF640 0x2B0A      MOVW     R11,#+2570
    773                          }
    774                      }       
    775                      break;
   \                     ??SDHC_ioctl_47:
   \   00000462   0xE0BC             B.N      ??SDHC_ioctl_16
    776                  case IO_IOCTL_ESDHC_GET_BUS_WIDTH:
    777                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_11:
   \   00000464   0x2E00             CMP      R6,#+0
   \   00000466   0xD102             BNE.N    ??SDHC_ioctl_50
    778                      {
    779                          result = BRTOS_INVALID_PARAMETER;
   \   00000468   0xF05F 0x0B0C      MOVS     R11,#+12
   \   0000046C   0xE018             B.N      ??SDHC_ioctl_51
    780                      } 
    781                      else 
    782                      {
    783                          /* Get actual ESDHC bus width */
    784                          val = (SDHC_PROCTL & SDHC_PROCTL_DTW_MASK) >> SDHC_PROCTL_DTW_SHIFT;
   \                     ??SDHC_ioctl_50:
   \   0000046E   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b1028
   \   00000472   0x6800             LDR      R0,[R0, #+0]
   \   00000474   0xF3C0 0x0A41      UBFX     R10,R0,#+1,#+2
    785                          if (ESDHC_PROCTL_DTW_1BIT == val)
   \   00000478   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000047C   0xD102             BNE.N    ??SDHC_ioctl_52
    786                          {
    787                              *param32_ptr = ESDHC_BUS_WIDTH_1BIT;
   \   0000047E   0x2000             MOVS     R0,#+0
   \   00000480   0x6030             STR      R0,[R6, #+0]
   \   00000482   0xE00D             B.N      ??SDHC_ioctl_51
    788                          }
    789                          else if (ESDHC_PROCTL_DTW_4BIT == val)
   \                     ??SDHC_ioctl_52:
   \   00000484   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000488   0xD102             BNE.N    ??SDHC_ioctl_53
    790                          {
    791                              *param32_ptr = ESDHC_BUS_WIDTH_4BIT;
   \   0000048A   0x2001             MOVS     R0,#+1
   \   0000048C   0x6030             STR      R0,[R6, #+0]
   \   0000048E   0xE007             B.N      ??SDHC_ioctl_51
    792                          }
    793                          else if (ESDHC_PROCTL_DTW_8BIT == val)
   \                     ??SDHC_ioctl_53:
   \   00000490   0xF1BA 0x0F10      CMP      R10,#+16
   \   00000494   0xD102             BNE.N    ??SDHC_ioctl_54
    794                          {
    795                              *param32_ptr = ESDHC_BUS_WIDTH_8BIT;
   \   00000496   0x2002             MOVS     R0,#+2
   \   00000498   0x6030             STR      R0,[R6, #+0]
   \   0000049A   0xE001             B.N      ??SDHC_ioctl_51
    796                          }
    797                          else
    798                          {
    799                              result = ESDHC_ERROR_INVALID_BUS_WIDTH; 
   \                     ??SDHC_ioctl_54:
   \   0000049C   0xF05F 0x0B05      MOVS     R11,#+5
    800                          }
    801                      }       
    802                      break;
   \                     ??SDHC_ioctl_51:
   \   000004A0   0xE09D             B.N      ??SDHC_ioctl_16
    803                  case IO_IOCTL_ESDHC_SET_BUS_WIDTH:
    804                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_12:
   \   000004A2   0x2E00             CMP      R6,#+0
   \   000004A4   0xD102             BNE.N    ??SDHC_ioctl_55
    805                      {
    806                          result = BRTOS_INVALID_PARAMETER;
   \   000004A6   0xF05F 0x0B0C      MOVS     R11,#+12
   \   000004AA   0xE040             B.N      ??SDHC_ioctl_56
    807                      } 
    808                      else 
    809                      {
    810                          /* Set actual ESDHC bus width */
    811                          if (! SDHC_is_running())
   \                     ??SDHC_ioctl_55:
   \   000004AC   0x.... 0x....      BL       SDHC_is_running
   \   000004B0   0x2800             CMP      R0,#+0
   \   000004B2   0xD13A             BNE.N    ??SDHC_ioctl_57
    812                          {
    813                              if (ESDHC_BUS_WIDTH_1BIT == *param32_ptr)
   \   000004B4   0x6830             LDR      R0,[R6, #+0]
   \   000004B6   0x2800             CMP      R0,#+0
   \   000004B8   0xD10E             BNE.N    ??SDHC_ioctl_58
    814                              {
    815                                  SDHC_PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   000004BA   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b1028
   \   000004BE   0x6800             LDR      R0,[R0, #+0]
   \   000004C0   0xF030 0x0006      BICS     R0,R0,#0x6
   \   000004C4   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b1028
   \   000004C8   0x6008             STR      R0,[R1, #+0]
    816                                  SDHC_PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_1BIT);
   \   000004CA   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b1028
   \   000004CE   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b1028
   \   000004D2   0x6809             LDR      R1,[R1, #+0]
   \   000004D4   0x6001             STR      R1,[R0, #+0]
   \   000004D6   0xE02A             B.N      ??SDHC_ioctl_56
    817                              }
    818                              else if (ESDHC_BUS_WIDTH_4BIT == *param32_ptr)
   \                     ??SDHC_ioctl_58:
   \   000004D8   0x6830             LDR      R0,[R6, #+0]
   \   000004DA   0x2801             CMP      R0,#+1
   \   000004DC   0xD110             BNE.N    ??SDHC_ioctl_59
    819                              {
    820                                  SDHC_PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   000004DE   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b1028
   \   000004E2   0x6800             LDR      R0,[R0, #+0]
   \   000004E4   0xF030 0x0006      BICS     R0,R0,#0x6
   \   000004E8   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b1028
   \   000004EC   0x6008             STR      R0,[R1, #+0]
    821                                  SDHC_PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_4BIT);
   \   000004EE   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b1028
   \   000004F2   0x6800             LDR      R0,[R0, #+0]
   \   000004F4   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000004F8   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b1028
   \   000004FC   0x6008             STR      R0,[R1, #+0]
   \   000004FE   0xE016             B.N      ??SDHC_ioctl_56
    822                              }
    823                              else if (ESDHC_BUS_WIDTH_8BIT == *param32_ptr)
   \                     ??SDHC_ioctl_59:
   \   00000500   0x6830             LDR      R0,[R6, #+0]
   \   00000502   0x2802             CMP      R0,#+2
   \   00000504   0xD10E             BNE.N    ??SDHC_ioctl_60
    824                              {
    825                                  SDHC_PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   00000506   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b1028
   \   0000050A   0x6800             LDR      R0,[R0, #+0]
   \   0000050C   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000510   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b1028
   \   00000514   0x6008             STR      R0,[R1, #+0]
    826                                  SDHC_PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_8BIT);
   \   00000516   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400b1028
   \   0000051A   0x.... 0x....      LDR.W    R1,??DataTable8_6  ;; 0x400b1028
   \   0000051E   0x6809             LDR      R1,[R1, #+0]
   \   00000520   0x6001             STR      R1,[R0, #+0]
   \   00000522   0xE004             B.N      ??SDHC_ioctl_56
    827                              }
    828                              else
    829                              {
    830                                  result = ESDHC_ERROR_INVALID_BUS_WIDTH; 
   \                     ??SDHC_ioctl_60:
   \   00000524   0xF05F 0x0B05      MOVS     R11,#+5
   \   00000528   0xE001             B.N      ??SDHC_ioctl_56
    831                              }
    832                          }
    833                          else
    834                          {
    835                              result = IO_ERROR_DEVICE_BUSY;
   \                     ??SDHC_ioctl_57:
   \   0000052A   0xF640 0x2B0A      MOVW     R11,#+2570
    836                          }
    837                      }       
    838                      break;
   \                     ??SDHC_ioctl_56:
   \   0000052E   0xE056             B.N      ??SDHC_ioctl_16
    839                  case IO_IOCTL_ESDHC_GET_CARD:
    840                      if (NULL == param32_ptr) 
   \                     ??SDHC_ioctl_8:
   \   00000530   0x2E00             CMP      R6,#+0
   \   00000532   0xD102             BNE.N    ??SDHC_ioctl_61
    841                      {
    842                          result = BRTOS_INVALID_PARAMETER;
   \   00000534   0xF05F 0x0B0C      MOVS     R11,#+12
   \   00000538   0xE02A             B.N      ??SDHC_ioctl_62
    843                      } 
    844                      else 
    845                      {
    846                          /* 80 clocks to update levels */
    847                          SDHC_SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \                     ??SDHC_ioctl_61:
   \   0000053A   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x400b102c
   \   0000053E   0x6800             LDR      R0,[R0, #+0]
   \   00000540   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000544   0x.... 0x....      LDR.W    R1,??DataTable8  ;; 0x400b102c
   \   00000548   0x6008             STR      R0,[R1, #+0]
    848                          while (SDHC_SYSCTL & SDHC_SYSCTL_INITA_MASK)
   \                     ??SDHC_ioctl_63:
   \   0000054A   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x400b102c
   \   0000054E   0x6800             LDR      R0,[R0, #+0]
   \   00000550   0x0100             LSLS     R0,R0,#+4
   \   00000552   0xD4FA             BMI.N    ??SDHC_ioctl_63
    849                              { };
    850                              
    851                          /* Update and return actual card status */
    852                          if (SDHC_IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \   00000554   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000558   0x6800             LDR      R0,[R0, #+0]
   \   0000055A   0x0600             LSLS     R0,R0,#+24
   \   0000055C   0xD509             BPL.N    ??SDHC_ioctl_64
    853                          {
    854                              SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \   0000055E   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   00000562   0x6800             LDR      R0,[R0, #+0]
   \   00000564   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000568   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   0000056C   0x6008             STR      R0,[R1, #+0]
    855                              esdhc_info_ptr->CARD = ESDHC_CARD_NONE;
   \   0000056E   0x2000             MOVS     R0,#+0
   \   00000570   0x6020             STR      R0,[R4, #+0]
    856                          }
    857                          if (SDHC_PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \                     ??SDHC_ioctl_64:
   \   00000572   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x400b1024
   \   00000576   0x6800             LDR      R0,[R0, #+0]
   \   00000578   0x03C0             LSLS     R0,R0,#+15
   \   0000057A   0xD505             BPL.N    ??SDHC_ioctl_65
    858                          {
    859                              if (ESDHC_CARD_NONE == esdhc_info_ptr->CARD)
   \   0000057C   0x6820             LDR      R0,[R4, #+0]
   \   0000057E   0x2800             CMP      R0,#+0
   \   00000580   0xD104             BNE.N    ??SDHC_ioctl_66
    860                              {
    861                                  esdhc_info_ptr->CARD = ESDHC_CARD_UNKNOWN;
   \   00000582   0x2001             MOVS     R0,#+1
   \   00000584   0x6020             STR      R0,[R4, #+0]
   \   00000586   0xE001             B.N      ??SDHC_ioctl_66
    862                              }
    863                          }
    864                          else
    865                          {
    866                              esdhc_info_ptr->CARD = ESDHC_CARD_NONE;
   \                     ??SDHC_ioctl_65:
   \   00000588   0x2000             MOVS     R0,#+0
   \   0000058A   0x6020             STR      R0,[R4, #+0]
    867                          }
    868                          *param32_ptr = esdhc_info_ptr->CARD;
   \                     ??SDHC_ioctl_66:
   \   0000058C   0x6820             LDR      R0,[R4, #+0]
   \   0000058E   0x6030             STR      R0,[R6, #+0]
    869                      }
    870                      break;
   \                     ??SDHC_ioctl_62:
   \   00000590   0xE025             B.N      ??SDHC_ioctl_16
    871                  case IO_IOCTL_DEVICE_IDENTIFY:
    872                      /* Get ESDHC device parameters */
    873                      param32_ptr[IO_IOCTL_ID_PHY_ELEMENT]  = IO_DEV_TYPE_PHYS_ESDHC;
   \                     ??SDHC_ioctl_5:
   \   00000592   0x201C             MOVS     R0,#+28
   \   00000594   0x6030             STR      R0,[R6, #+0]
    874                      param32_ptr[IO_IOCTL_ID_LOG_ELEMENT]  = IO_DEV_TYPE_LOGICAL_MFS;
   \   00000596   0x2004             MOVS     R0,#+4
   \   00000598   0x6070             STR      R0,[R6, #+4]
    875                      param32_ptr[IO_IOCTL_ID_ATTR_ELEMENT] = IO_ESDHC_ATTRIBS;
   \   0000059A   0xF44F 0x701E      MOV      R0,#+632
   \   0000059E   0x60B0             STR      R0,[R6, #+8]
    876                      /*
    877                      if (esdhc_fd_ptr->FLAGS & IO_O_RDONLY)
    878                      {
    879                          param32_ptr[IO_IOCTL_ID_ATTR_ELEMENT] &= (~ IO_DEV_ATTR_WRITE);
    880                      }
    881                      */
    882                      break;
   \   000005A0   0xE01D             B.N      ??SDHC_ioctl_16
    883                  case IO_IOCTL_FLUSH_OUTPUT:
    884                      /* Wait for transfer complete */
    885                      SDHC_status_wait (SDHC_IRQSTAT_TC_MASK);
   \                     ??SDHC_ioctl_4:
   \   000005A2   0x2002             MOVS     R0,#+2
   \   000005A4   0x.... 0x....      BL       SDHC_status_wait
    886                      if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   000005A8   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000005AC   0x6800             LDR      R0,[R0, #+0]
   \   000005AE   0xF410 0x0FE0      TST      R0,#0x700000
   \   000005B2   0xD009             BEQ.N    ??SDHC_ioctl_67
    887                      {
    888                          SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK;
   \   000005B4   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000005B8   0x6800             LDR      R0,[R0, #+0]
   \   000005BA   0xF450 0x00E0      ORRS     R0,R0,#0x700000
   \   000005BE   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000005C2   0x6008             STR      R0,[R1, #+0]
    889                          result = ESDHC_ERROR_DATA_TRANSFER;
   \   000005C4   0xF05F 0x0B04      MOVS     R11,#+4
    890                      }
    891                      SDHC_IRQSTAT |= SDHC_IRQSTAT_TC_MASK | SDHC_IRQSTAT_BRR_MASK | SDHC_IRQSTAT_BWR_MASK;
   \                     ??SDHC_ioctl_67:
   \   000005C8   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x400b1030
   \   000005CC   0x6800             LDR      R0,[R0, #+0]
   \   000005CE   0xF050 0x0032      ORRS     R0,R0,#0x32
   \   000005D2   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0x400b1030
   \   000005D6   0x6008             STR      R0,[R1, #+0]
    892                      break;
   \   000005D8   0xE001             B.N      ??SDHC_ioctl_16
    893                  default:
    894                      result = IO_ERROR_INVALID_IOCTL_CMD;
   \                     ??SDHC_ioctl_15:
   \   000005DA   0xF640 0x2B09      MOVW     R11,#+2569
    895                      break;
    896              }
    897              return result;
   \                     ??SDHC_ioctl_16:
   \   000005DE   0x4658             MOV      R0,R11
   \                     ??SDHC_ioctl_1:
   \   000005E0   0xB009             ADD      SP,SP,#+36
   \   000005E2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    898          }
    899          
    900          
    901          

   \                                 In section .text, align 2, keep-with-next
    902          U8 disk_initialize (unsigned char drv)
    903          {
   \                     disk_initialize:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
    904              U32                 param, c_size, c_size_mult, read_bl_len;
    905              ESDHC_COMMAND_STRUCT    command;
    906              ESDHC_DEVICE_STRUCT_PTR     esdhc_device_ptr = &SDHC_Device;
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable16_1
    907              SDCARD_STRUCT_PTR   sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable16_4
    908              sdcard_ptr->INIT =  &SDHC_Init;
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable16_5
   \   00000010   0x6022             STR      R2,[R4, #+0]
    909              
    910              if (drv) return STA_NOINIT;         /* Supports only single drive */
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??disk_initialize_0
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE139             B.N      ??disk_initialize_1
    911              if (Stat & STA_NODISK) return Stat; /* No card in the socket */
   \                     ??disk_initialize_0:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x0780             LSLS     R0,R0,#+30
   \   00000024   0xD503             BPL.N    ??disk_initialize_2
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xE130             B.N      ??disk_initialize_1
    912              if ((Stat & 0x03) == 0) return 0;
   \                     ??disk_initialize_2:
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x2203             MOVS     R2,#+3
   \   00000036   0x4210             TST      R0,R2
   \   00000038   0xD101             BNE.N    ??disk_initialize_3
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE128             B.N      ??disk_initialize_1
    913              
    914              /* Check parameters */
    915              if ((NULL == sdcard_ptr) || (NULL == sdcard_ptr->INIT))
   \                     ??disk_initialize_3:
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD002             BEQ.N    ??disk_initialize_4
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD101             BNE.N    ??disk_initialize_5
    916              {
    917                  return FALSE;
   \                     ??disk_initialize_4:
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE121             B.N      ??disk_initialize_1
    918              }
    919              
    920              esdhc_device_ptr->INIT = &K60_SDHC0_init;
   \                     ??disk_initialize_5:
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000050   0x6008             STR      R0,[R1, #+0]
    921              // Indicates one SDHC open
    922              esdhc_device_ptr->COUNT = 1;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x6048             STR      R0,[R1, #+4]
    923          
    924              sdcard_ptr->SD_TIMEOUT = 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x6060             STR      R0,[R4, #+4]
    925              sdcard_ptr->NUM_BLOCKS = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x60A0             STR      R0,[R4, #+8]
    926              sdcard_ptr->ADDRESS = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x6120             STR      R0,[R4, #+16]
    927              sdcard_ptr->SDHC = FALSE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7320             STRB     R0,[R4, #+12]
    928              sdcard_ptr->VERSION2 = FALSE;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x7360             STRB     R0,[R4, #+13]
    929              
    930              /* Enable clock gate to SDHC module */
    931              SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable9_7  ;; 0x40048030
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable9_7  ;; 0x40048030
   \   00000078   0x6008             STR      R0,[R1, #+0]
    932              
    933              /* Initialize and detect card */
    934              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_INIT, NULL))
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0xF241 0x3001      MOVW     R0,#+4865
   \   00000080   0x.... 0x....      BL       SDHC_ioctl
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD001             BEQ.N    ??disk_initialize_6
    935              {
    936                  return FALSE;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE101             B.N      ??disk_initialize_1
    937              }
    938          
    939              /* SDHC check */
    940              param = 0;
   \                     ??disk_initialize_6:
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x9000             STR      R0,[SP, #+0]
    941              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_GET_CARD, &param))
   \   00000090   0xA900             ADD      R1,SP,#+0
   \   00000092   0xF241 0x3003      MOVW     R0,#+4867
   \   00000096   0x.... 0x....      BL       SDHC_ioctl
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD001             BEQ.N    ??disk_initialize_7
    942              {
    943                  return FALSE;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xE0F6             B.N      ??disk_initialize_1
    944              }
    945              if ((ESDHC_CARD_SD == param) || (ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDCOMBO == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??disk_initialize_7:
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD008             BEQ.N    ??disk_initialize_8
   \   000000A8   0x9800             LDR      R0,[SP, #+0]
   \   000000AA   0x2803             CMP      R0,#+3
   \   000000AC   0xD005             BEQ.N    ??disk_initialize_8
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x2805             CMP      R0,#+5
   \   000000B2   0xD002             BEQ.N    ??disk_initialize_8
   \   000000B4   0x9800             LDR      R0,[SP, #+0]
   \   000000B6   0x2806             CMP      R0,#+6
   \   000000B8   0xD131             BNE.N    ??disk_initialize_9
    946              {
    947                  if ((ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??disk_initialize_8:
   \   000000BA   0x9800             LDR      R0,[SP, #+0]
   \   000000BC   0x2803             CMP      R0,#+3
   \   000000BE   0xD002             BEQ.N    ??disk_initialize_10
   \   000000C0   0x9800             LDR      R0,[SP, #+0]
   \   000000C2   0x2806             CMP      R0,#+6
   \   000000C4   0xD101             BNE.N    ??disk_initialize_11
    948                  {
    949                      sdcard_ptr->SDHC = TRUE;
   \                     ??disk_initialize_10:
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x7320             STRB     R0,[R4, #+12]
    950                  }
    951              }
    952              else
    953              {
    954                  return FALSE;
    955              }
    956          
    957              /* Card identify */
    958              command.COMMAND = ESDHC_CMD2;
   \                     ??disk_initialize_11:
   \   000000CA   0x2002             MOVS     R0,#+2
   \   000000CC   0xF88D 0x0004      STRB     R0,[SP, #+4]
    959              command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xF88D 0x0005      STRB     R0,[SP, #+5]
    960              command.ARGUMENT = 0;
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x9002             STR      R0,[SP, #+8]
    961              command.READ = FALSE;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xF88D 0x000C      STRB     R0,[SP, #+12]
    962              command.BLOCKS = 0;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x9004             STR      R0,[SP, #+16]
    963              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000000E4   0xA901             ADD      R1,SP,#+4
   \   000000E6   0xF241 0x3002      MOVW     R0,#+4866
   \   000000EA   0x.... 0x....      BL       SDHC_ioctl
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD117             BNE.N    ??disk_initialize_12
    964              {
    965                  return FALSE;
    966              }
    967          
    968              /* Get card address */
    969              command.COMMAND = ESDHC_CMD3;
   \   000000F2   0x2003             MOVS     R0,#+3
   \   000000F4   0xF88D 0x0004      STRB     R0,[SP, #+4]
    970              command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF88D 0x0005      STRB     R0,[SP, #+5]
    971              command.ARGUMENT = 0;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x9002             STR      R0,[SP, #+8]
    972              command.READ = FALSE;
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0xF88D 0x000C      STRB     R0,[SP, #+12]
    973              command.BLOCKS = 0;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x9004             STR      R0,[SP, #+16]
    974              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   0000010C   0xA901             ADD      R1,SP,#+4
   \   0000010E   0xF241 0x3002      MOVW     R0,#+4866
   \   00000112   0x.... 0x....      BL       SDHC_ioctl
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD005             BEQ.N    ??disk_initialize_13
    975              {
    976                  return FALSE;
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xE0B8             B.N      ??disk_initialize_1
    977              }
   \                     ??disk_initialize_9:
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xE0B6             B.N      ??disk_initialize_1
   \                     ??disk_initialize_12:
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xE0B4             B.N      ??disk_initialize_1
    978              sdcard_ptr->ADDRESS = command.RESPONSE[0] & 0xFFFF0000;
   \                     ??disk_initialize_13:
   \   00000126   0x9805             LDR      R0,[SP, #+20]
   \   00000128   0x0C00             LSRS     R0,R0,#+16
   \   0000012A   0x0400             LSLS     R0,R0,#+16
   \   0000012C   0x6120             STR      R0,[R4, #+16]
    979              
    980              /* Get card parameters */
    981              command.COMMAND = ESDHC_CMD9;
   \   0000012E   0x2009             MOVS     R0,#+9
   \   00000130   0xF88D 0x0004      STRB     R0,[SP, #+4]
    982              command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0xF88D 0x0005      STRB     R0,[SP, #+5]
    983              command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   0000013A   0x6920             LDR      R0,[R4, #+16]
   \   0000013C   0x9002             STR      R0,[SP, #+8]
    984              command.READ = FALSE;
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0xF88D 0x000C      STRB     R0,[SP, #+12]
    985              command.BLOCKS = 0;
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x9004             STR      R0,[SP, #+16]
    986              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000148   0xA901             ADD      R1,SP,#+4
   \   0000014A   0xF241 0x3002      MOVW     R0,#+4866
   \   0000014E   0x.... 0x....      BL       SDHC_ioctl
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD001             BEQ.N    ??disk_initialize_14
    987              {
    988                  return FALSE;
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xE09A             B.N      ??disk_initialize_1
    989              }
    990              if (0 == (command.RESPONSE[3] & 0x00C00000))
   \                     ??disk_initialize_14:
   \   0000015A   0x9808             LDR      R0,[SP, #+32]
   \   0000015C   0xF410 0x0F40      TST      R0,#0xC00000
   \   00000160   0xD119             BNE.N    ??disk_initialize_15
    991              {
    992                  read_bl_len = (command.RESPONSE[2] >> 8) & 0x0F;
   \   00000162   0x9807             LDR      R0,[SP, #+28]
   \   00000164   0xF3C0 0x2203      UBFX     R2,R0,#+8,#+4
    993                  c_size = command.RESPONSE[2] & 0x03;
   \   00000168   0xF89D 0x001C      LDRB     R0,[SP, #+28]
   \   0000016C   0xF010 0x0003      ANDS     R0,R0,#0x3
    994                  c_size = (c_size << 10) | (command.RESPONSE[1] >> 22);
   \   00000170   0x9906             LDR      R1,[SP, #+24]
   \   00000172   0x0D89             LSRS     R1,R1,#+22
   \   00000174   0xEA51 0x2080      ORRS     R0,R1,R0, LSL #+10
    995                  c_size_mult = (command.RESPONSE[1] >> 7) & 0x07;
   \   00000178   0x9906             LDR      R1,[SP, #+24]
   \   0000017A   0xF3C1 0x11C2      UBFX     R1,R1,#+7,#+3
    996                  sdcard_ptr->NUM_BLOCKS = (c_size + 1) * (1 << (c_size_mult + 2)) * (1 << (read_bl_len - 9));
   \   0000017E   0x1C40             ADDS     R0,R0,#+1
   \   00000180   0x2301             MOVS     R3,#+1
   \   00000182   0x1C89             ADDS     R1,R1,#+2
   \   00000184   0xFA13 0xF101      LSLS     R1,R3,R1
   \   00000188   0x4348             MULS     R0,R1,R0
   \   0000018A   0x2101             MOVS     R1,#+1
   \   0000018C   0x3A09             SUBS     R2,R2,#+9
   \   0000018E   0x4091             LSLS     R1,R1,R2
   \   00000190   0x4348             MULS     R0,R1,R0
   \   00000192   0x60A0             STR      R0,[R4, #+8]
   \   00000194   0xE007             B.N      ??disk_initialize_16
    997              }
    998              else
    999              {
   1000                  sdcard_ptr->VERSION2 = TRUE;
   \                     ??disk_initialize_15:
   \   00000196   0x2001             MOVS     R0,#+1
   \   00000198   0x7360             STRB     R0,[R4, #+13]
   1001                  c_size = (command.RESPONSE[1] >> 8) & 0x003FFFFF;
   \   0000019A   0x9806             LDR      R0,[SP, #+24]
   \   0000019C   0xF3C0 0x2015      UBFX     R0,R0,#+8,#+22
   1002                  sdcard_ptr->NUM_BLOCKS = (c_size + 1) << 10;
   \   000001A0   0x1C40             ADDS     R0,R0,#+1
   \   000001A2   0x0280             LSLS     R0,R0,#+10
   \   000001A4   0x60A0             STR      R0,[R4, #+8]
   1003              }
   1004          
   1005              /* Select card */
   1006              command.COMMAND = ESDHC_CMD7;
   \                     ??disk_initialize_16:
   \   000001A6   0x2007             MOVS     R0,#+7
   \   000001A8   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1007              command.TYPE = ESDHC_TYPE_NORMAL;
   \   000001AC   0x2000             MOVS     R0,#+0
   \   000001AE   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1008              command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000001B2   0x6920             LDR      R0,[R4, #+16]
   \   000001B4   0x9002             STR      R0,[SP, #+8]
   1009              command.READ = FALSE;
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1010              command.BLOCKS = 0;
   \   000001BC   0x2000             MOVS     R0,#+0
   \   000001BE   0x9004             STR      R0,[SP, #+16]
   1011              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000001C0   0xA901             ADD      R1,SP,#+4
   \   000001C2   0xF241 0x3002      MOVW     R0,#+4866
   \   000001C6   0x.... 0x....      BL       SDHC_ioctl
   \   000001CA   0x2800             CMP      R0,#+0
   \   000001CC   0xD001             BEQ.N    ??disk_initialize_17
   1012              {
   1013                  return FALSE;
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0xE05E             B.N      ??disk_initialize_1
   1014              }
   1015          
   1016              /* Set block size */
   1017              command.COMMAND = ESDHC_CMD16;
   \                     ??disk_initialize_17:
   \   000001D2   0x2010             MOVS     R0,#+16
   \   000001D4   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1018              command.TYPE = ESDHC_TYPE_NORMAL;
   \   000001D8   0x2000             MOVS     R0,#+0
   \   000001DA   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1019              command.ARGUMENT = IO_SDCARD_BLOCK_SIZE;
   \   000001DE   0xF44F 0x7000      MOV      R0,#+512
   \   000001E2   0x9002             STR      R0,[SP, #+8]
   1020              command.READ = FALSE;
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1021              command.BLOCKS = 0;
   \   000001EA   0x2000             MOVS     R0,#+0
   \   000001EC   0x9004             STR      R0,[SP, #+16]
   1022              if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000001EE   0xA901             ADD      R1,SP,#+4
   \   000001F0   0xF241 0x3002      MOVW     R0,#+4866
   \   000001F4   0x.... 0x....      BL       SDHC_ioctl
   \   000001F8   0x2800             CMP      R0,#+0
   \   000001FA   0xD001             BEQ.N    ??disk_initialize_18
   1023              {
   1024                  return FALSE;
   \   000001FC   0x2000             MOVS     R0,#+0
   \   000001FE   0xE047             B.N      ??disk_initialize_1
   1025              }
   1026          
   1027              if (ESDHC_BUS_WIDTH_4BIT == sdcard_ptr->INIT->SIGNALS)
   \                     ??disk_initialize_18:
   \   00000200   0x6820             LDR      R0,[R4, #+0]
   \   00000202   0x6800             LDR      R0,[R0, #+0]
   \   00000204   0x2801             CMP      R0,#+1
   \   00000206   0xD136             BNE.N    ??disk_initialize_19
   1028              {
   1029                  /* Application specific command */
   1030                  command.COMMAND = ESDHC_CMD55;
   \   00000208   0x2037             MOVS     R0,#+55
   \   0000020A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1031                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000020E   0x2000             MOVS     R0,#+0
   \   00000210   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1032                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   00000214   0x6920             LDR      R0,[R4, #+16]
   \   00000216   0x9002             STR      R0,[SP, #+8]
   1033                  command.READ = FALSE;
   \   00000218   0x2000             MOVS     R0,#+0
   \   0000021A   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1034                  command.BLOCKS = 0;
   \   0000021E   0x2000             MOVS     R0,#+0
   \   00000220   0x9004             STR      R0,[SP, #+16]
   1035                  if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000222   0xA901             ADD      R1,SP,#+4
   \   00000224   0xF241 0x3002      MOVW     R0,#+4866
   \   00000228   0x.... 0x....      BL       SDHC_ioctl
   \   0000022C   0x2800             CMP      R0,#+0
   \   0000022E   0xD001             BEQ.N    ??disk_initialize_20
   1036                  {
   1037                      return FALSE;
   \   00000230   0x2000             MOVS     R0,#+0
   \   00000232   0xE02D             B.N      ??disk_initialize_1
   1038                  }
   1039          
   1040                  /* Set bus width == 4 */
   1041                  command.COMMAND = ESDHC_ACMD6;
   \                     ??disk_initialize_20:
   \   00000234   0x2046             MOVS     R0,#+70
   \   00000236   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1042                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000023A   0x2000             MOVS     R0,#+0
   \   0000023C   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1043                  command.ARGUMENT = 2;
   \   00000240   0x2002             MOVS     R0,#+2
   \   00000242   0x9002             STR      R0,[SP, #+8]
   1044                  command.READ = FALSE;
   \   00000244   0x2000             MOVS     R0,#+0
   \   00000246   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1045                  command.BLOCKS = 0;
   \   0000024A   0x2000             MOVS     R0,#+0
   \   0000024C   0x9004             STR      R0,[SP, #+16]
   1046                  if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   0000024E   0xA901             ADD      R1,SP,#+4
   \   00000250   0xF241 0x3002      MOVW     R0,#+4866
   \   00000254   0x.... 0x....      BL       SDHC_ioctl
   \   00000258   0x2800             CMP      R0,#+0
   \   0000025A   0xD001             BEQ.N    ??disk_initialize_21
   1047                  {
   1048                      return FALSE;
   \   0000025C   0x2000             MOVS     R0,#+0
   \   0000025E   0xE017             B.N      ??disk_initialize_1
   1049                  }
   1050          
   1051                  param = ESDHC_BUS_WIDTH_4BIT;
   \                     ??disk_initialize_21:
   \   00000260   0x2001             MOVS     R0,#+1
   \   00000262   0x9000             STR      R0,[SP, #+0]
   1052                  if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SET_BUS_WIDTH, &param))
   \   00000264   0xA900             ADD      R1,SP,#+0
   \   00000266   0xF241 0x3007      MOVW     R0,#+4871
   \   0000026A   0x.... 0x....      BL       SDHC_ioctl
   \   0000026E   0x2800             CMP      R0,#+0
   \   00000270   0xD001             BEQ.N    ??disk_initialize_19
   1053                  {
   1054                      return FALSE;
   \   00000272   0x2000             MOVS     R0,#+0
   \   00000274   0xE00C             B.N      ??disk_initialize_1
   1055                  }
   1056              }
   1057          
   1058              Stat &= ~STA_NOINIT;        /* Clear STA_NOINIT */
   \                     ??disk_initialize_19:
   \   00000276   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000027A   0x7800             LDRB     R0,[R0, #+0]
   \   0000027C   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000280   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   00000284   0x7008             STRB     R0,[R1, #+0]
   1059              
   1060              return (Stat & 0x03);
   \   00000286   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000028A   0x7800             LDRB     R0,[R0, #+0]
   \   0000028C   0xF010 0x0003      ANDS     R0,R0,#0x3
   \                     ??disk_initialize_1:
   \   00000290   0xB00A             ADD      SP,SP,#+40
   \   00000292   0xBD10             POP      {R4,PC}          ;; return
   1061          }
   1062          
   1063          
   1064          
   1065          /*-----------------------------------------------------------------------*/
   1066          /* Receive a data packet from MMC                                        */
   1067          /*-----------------------------------------------------------------------*/
   1068          

   \                                 In section .text, align 2, keep-with-next
   1069          static int rcvr_datablock (
   1070              U8   *buff,  /* Data buffer to store received data */
   1071              U32  btr /* Byte count (must be multiple of 4) */
   1072          )
   1073          {
   \                     rcvr_datablock:
   \   00000000   0xB410             PUSH     {R4}
   1074              U32 bytes, i, j;
   1075              U32 *ptr = (U32*)buff;
   1076              ESDHC_INFO_STRUCT_PTR   esdhc_info_ptr;
   1077          
   1078              /* Check parameters */
   1079              esdhc_info_ptr = (ESDHC_INFO_STRUCT_PTR)&SDHC_Info;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable16
   1080              
   1081              /* Check parameters */    
   1082              if (NULL == esdhc_info_ptr)
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD101             BNE.N    ??rcvr_datablock_0
   1083              {
   1084                  return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE039             B.N      ??rcvr_datablock_1
   1085              }    
   1086              
   1087              /* Workaround for random bit polling failures - not suitable for IO cards */
   1088              if ((esdhc_info_ptr->CARD == ESDHC_CARD_SD) || (esdhc_info_ptr->CARD == ESDHC_CARD_SDHC) || (esdhc_info_ptr->CARD == ESDHC_CARD_MMC) || (esdhc_info_ptr->CARD == ESDHC_CARD_CEATA))
   \                     ??rcvr_datablock_0:
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0x2B02             CMP      R3,#+2
   \   00000012   0xD008             BEQ.N    ??rcvr_datablock_2
   \   00000014   0x6813             LDR      R3,[R2, #+0]
   \   00000016   0x2B03             CMP      R3,#+3
   \   00000018   0xD005             BEQ.N    ??rcvr_datablock_2
   \   0000001A   0x6813             LDR      R3,[R2, #+0]
   \   0000001C   0x2B07             CMP      R3,#+7
   \   0000001E   0xD002             BEQ.N    ??rcvr_datablock_2
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x2A08             CMP      R2,#+8
   \   00000024   0xD103             BNE.N    ??rcvr_datablock_3
   1089              {
   1090                  while (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA_MASK){};
   \                     ??rcvr_datablock_2:
   \   00000026   0x....             LDR.N    R2,??DataTable8_2  ;; 0x400b1024
   \   00000028   0x6812             LDR      R2,[R2, #+0]
   \   0000002A   0x0752             LSLS     R2,R2,#+29
   \   0000002C   0xD4FB             BMI.N    ??rcvr_datablock_2
   1091              }    
   1092              
   1093              /* Read data in 4 byte counts */
   1094              bytes = btr;
   \                     ??rcvr_datablock_3:
   \   0000002E   0xE000             B.N      ??rcvr_datablock_4
   1095              while (bytes)
   1096              {
   1097                  i = bytes > 512 ? 512 : bytes;
   1098                  for (j = (i + 3) >> 2; j != 0; j--)
   1099                  {
   1100                      if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   1101                      {
   1102                          SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BRR_MASK;
   1103                          return 0;
   1104                      }
   1105                      
   1106                      while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN_MASK)){};
   1107              
   1108          #if BRTOS_ENDIAN == BRTOS_LITTLE_ENDIAN
   1109                      *ptr++ = SDHC_DATPORT;
   1110          #else
   1111                      *ptr++ = _psp_swap4byte (SDHC_DATPORT);
   1112          #endif
   1113                  }
   1114                  bytes -= i;
   \                     ??rcvr_datablock_5:
   \   00000030   0x1A89             SUBS     R1,R1,R2
   \                     ??rcvr_datablock_4:
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD024             BEQ.N    ??rcvr_datablock_6
   \   00000036   0xF5B1 0x7F00      CMP      R1,#+512
   \   0000003A   0xD902             BLS.N    ??rcvr_datablock_7
   \   0000003C   0xF44F 0x7200      MOV      R2,#+512
   \   00000040   0xE000             B.N      ??rcvr_datablock_8
   \                     ??rcvr_datablock_7:
   \   00000042   0x000A             MOVS     R2,R1
   \                     ??rcvr_datablock_8:
   \   00000044   0x1CD3             ADDS     R3,R2,#+3
   \   00000046   0x089B             LSRS     R3,R3,#+2
   \   00000048   0xE009             B.N      ??rcvr_datablock_9
   \                     ??rcvr_datablock_10:
   \   0000004A   0x....             LDR.N    R4,??DataTable8_2  ;; 0x400b1024
   \   0000004C   0x6824             LDR      R4,[R4, #+0]
   \   0000004E   0x0524             LSLS     R4,R4,#+20
   \   00000050   0xD5FB             BPL.N    ??rcvr_datablock_10
   \   00000052   0x.... 0x....      LDR.W    R4,??DataTable16_7  ;; 0x400b1020
   \   00000056   0x6824             LDR      R4,[R4, #+0]
   \   00000058   0x6004             STR      R4,[R0, #+0]
   \   0000005A   0x1D00             ADDS     R0,R0,#+4
   \   0000005C   0x1E5B             SUBS     R3,R3,#+1
   \                     ??rcvr_datablock_9:
   \   0000005E   0x2B00             CMP      R3,#+0
   \   00000060   0xD0E6             BEQ.N    ??rcvr_datablock_5
   \   00000062   0x....             LDR.N    R4,??DataTable10  ;; 0x400b1030
   \   00000064   0x6824             LDR      R4,[R4, #+0]
   \   00000066   0xF414 0x0FE0      TST      R4,#0x700000
   \   0000006A   0xD0EE             BEQ.N    ??rcvr_datablock_10
   \   0000006C   0x....             LDR.N    R0,??DataTable10  ;; 0x400b1030
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000074   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000078   0x....             LDR.N    R1,??DataTable10  ;; 0x400b1030
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE000             B.N      ??rcvr_datablock_1
   1115              }
   1116              
   1117          	return 1;           /* Return with success */    
   \                     ??rcvr_datablock_6:
   \   00000080   0x2001             MOVS     R0,#+1
   \                     ??rcvr_datablock_1:
   \   00000082   0xBC10             POP      {R4}
   \   00000084   0x4770             BX       LR               ;; return
   1118          }
   1119          
   1120          /*-----------------------------------------------------------------------*/
   1121          /* Read Sector(s)                                                        */
   1122          /*-----------------------------------------------------------------------*/
   1123          

   \                                 In section .text, align 2, keep-with-next
   1124          DRESULT disk_read (
   1125              U8  drv,         /* Physical drive nmuber (0) */
   1126              U8  *buff,       /* Pointer to the data buffer to store read data */
   1127              U32 sector,      /* Start sector number (LBA) */
   1128              U8  count        /* Sector count (1..255) */
   1129          )
   1130          {
   \                     disk_read:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x001D             MOVS     R5,R3
   1131              ESDHC_COMMAND_STRUCT command;
   1132              SDCARD_STRUCT_PTR    sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable16_4
   1133              
   1134              if (drv || !count) return RES_PARERR;
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD102             BNE.N    ??disk_read_0
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD101             BNE.N    ??disk_read_1
   \                     ??disk_read_0:
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xE054             B.N      ??disk_read_2
   1135              if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_read_1:
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD501             BPL.N    ??disk_read_3
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xE04D             B.N      ??disk_read_2
   1136                  
   1137              /* Check parameters */
   1138              if ((NULL == buff))
   \                     ??disk_read_3:
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD101             BNE.N    ??disk_read_4
   1139              {
   1140                  return FALSE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE049             B.N      ??disk_read_2
   1141              }   
   1142              if (!sdcard_ptr->SDHC)
   \                     ??disk_read_4:
   \   00000032   0x7B08             LDRB     R0,[R1, #+12]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD102             BNE.N    ??disk_read_5
   1143              {
   1144                  sector *= 512;	/* Convert to byte address if needed */
   \   00000038   0xF44F 0x7000      MOV      R0,#+512
   \   0000003C   0x4342             MULS     R2,R0,R2
   1145              }
   1146          
   1147              if (count == 1)	/* Single block read */
   \                     ??disk_read_5:
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D01             CMP      R5,#+1
   \   00000042   0xD11B             BNE.N    ??disk_read_6
   1148              {
   1149                  command.COMMAND = ESDHC_CMD17;
   \   00000044   0x2011             MOVS     R0,#+17
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1150                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1151                  command.ARGUMENT = sector;
   \   00000050   0x9201             STR      R2,[SP, #+4]
   1152                  command.READ = TRUE;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1153                  command.BLOCKS = count;	
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x9503             STR      R5,[SP, #+12]
   1154                  
   1155                  if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   0000005C   0xA900             ADD      R1,SP,#+0
   \   0000005E   0xF241 0x3002      MOVW     R0,#+4866
   \   00000062   0x.... 0x....      BL       SDHC_ioctl
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD126             BNE.N    ??disk_read_7
   1156                  {
   1157                      if (rcvr_datablock(buff, 512))
   \   0000006A   0xF44F 0x7100      MOV      R1,#+512
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       rcvr_datablock
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD01F             BEQ.N    ??disk_read_7
   1158                      {
   1159                          count = 0;
   \   00000078   0x2500             MOVS     R5,#+0
   \   0000007A   0xE01D             B.N      ??disk_read_7
   1160                      }
   1161                  }
   1162              }
   1163              else 
   1164              {   /* Multiple block read */
   1165                  // N     sei se  17 ou 18 no ESDHC
   1166                  command.COMMAND = ESDHC_CMD18;
   \                     ??disk_read_6:
   \   0000007C   0x2012             MOVS     R0,#+18
   \   0000007E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1167                  //command.COMMAND = ESDHC_CMD17;
   1168                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1169                  command.ARGUMENT = sector;
   \   00000088   0x9201             STR      R2,[SP, #+4]
   1170                  command.READ = TRUE;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1171                  command.BLOCKS = count; 
   \   00000090   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000092   0x9503             STR      R5,[SP, #+12]
   1172                  
   1173                  if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000094   0xA900             ADD      R1,SP,#+0
   \   00000096   0xF241 0x3002      MOVW     R0,#+4866
   \   0000009A   0x.... 0x....      BL       SDHC_ioctl
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD10A             BNE.N    ??disk_read_7
   1174                  {
   1175                      if (rcvr_datablock(buff, 512*count))
   \   000000A2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A4   0xF44F 0x7000      MOV      R0,#+512
   \   000000A8   0xFB00 0xF105      MUL      R1,R0,R5
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       rcvr_datablock
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD000             BEQ.N    ??disk_read_7
   1176                      {
   1177                          count = 0;
   \   000000B6   0x2500             MOVS     R5,#+0
   1178                      }
   1179                  }
   1180              }
   1181          
   1182              return count ? RES_ERROR : RES_OK;
   \                     ??disk_read_7:
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0x2D00             CMP      R5,#+0
   \   000000BC   0xD001             BEQ.N    ??disk_read_8
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xE000             B.N      ??disk_read_9
   \                     ??disk_read_8:
   \   000000C2   0x2000             MOVS     R0,#+0
   \                     ??disk_read_9:
   \   000000C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_read_2:
   \   000000C6   0xB009             ADD      SP,SP,#+36
   \   000000C8   0xBD30             POP      {R4,R5,PC}       ;; return
   1183          }
   1184          
   1185          /*-----------------------------------------------------------------------*/
   1186          /* Send a data packet to MMC                                             */
   1187          /*-----------------------------------------------------------------------*/
   1188          

   \                                 In section .text, align 2, keep-with-next
   1189          static int xmit_datablock (
   1190              const U8 *buff,         /* 512 byte data block to be transmitted */
   1191              U32 btr              /* Byte count (must be multiple of 4) */
   1192          )
   1193          {
   \                     xmit_datablock:
   \   00000000   0xB410             PUSH     {R4}
   1194              U32  bytes, i;
   1195              U32  *ptr = (U32*)buff;
   1196          
   1197              /* Write data in 4 byte counts */
   1198              bytes = btr;
   1199              while (bytes)
   \                     ??xmit_datablock_0:
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD025             BEQ.N    ??xmit_datablock_1
   1200              {
   1201                  i = bytes > 512 ? 512 : bytes;
   \   00000006   0xF5B1 0x7F00      CMP      R1,#+512
   \   0000000A   0xD902             BLS.N    ??xmit_datablock_2
   \   0000000C   0xF44F 0x7200      MOV      R2,#+512
   \   00000010   0xE000             B.N      ??xmit_datablock_3
   \                     ??xmit_datablock_2:
   \   00000012   0x000A             MOVS     R2,R1
   1202                  bytes -= i;
   \                     ??xmit_datablock_3:
   \   00000014   0x1A89             SUBS     R1,R1,R2
   1203                  for (i = (i + 3) >> 2; i != 0; i--)
   \   00000016   0x1CD2             ADDS     R2,R2,#+3
   \   00000018   0x0892             LSRS     R2,R2,#+2
   \   0000001A   0xE008             B.N      ??xmit_datablock_4
   1204                  {
   1205                      if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   1206                      {
   1207                      	SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK | SDHC_IRQSTAT_BWR_MASK;
   1208                          return IO_ERROR;
   1209                      }
   1210                      while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN_MASK)){};
   \                     ??xmit_datablock_5:
   \   0000001C   0x....             LDR.N    R3,??DataTable16_8  ;; 0x400b1024
   \   0000001E   0x681B             LDR      R3,[R3, #+0]
   \   00000020   0x055B             LSLS     R3,R3,#+21
   \   00000022   0xD5FB             BPL.N    ??xmit_datablock_5
   1211          
   1212          #if PSP_ENDIAN == BRTOS_LITTLE_ENDIAN
   1213                      SDHC_DATPORT = *ptr++;
   \   00000024   0x....             LDR.N    R3,??DataTable16_7  ;; 0x400b1020
   \   00000026   0x6804             LDR      R4,[R0, #+0]
   \   00000028   0x601C             STR      R4,[R3, #+0]
   \   0000002A   0x1D00             ADDS     R0,R0,#+4
   \   0000002C   0x1E52             SUBS     R2,R2,#+1
   \                     ??xmit_datablock_4:
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD0E7             BEQ.N    ??xmit_datablock_0
   \   00000032   0x....             LDR.N    R3,??DataTable10  ;; 0x400b1030
   \   00000034   0x681B             LDR      R3,[R3, #+0]
   \   00000036   0xF413 0x0FE0      TST      R3,#0x700000
   \   0000003A   0xD0EF             BEQ.N    ??xmit_datablock_5
   \   0000003C   0x....             LDR.N    R0,??DataTable10  ;; 0x400b1030
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF440 0x00E0      ORR      R0,R0,#0x700000
   \   00000044   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000048   0x....             LDR.N    R1,??DataTable10  ;; 0x400b1030
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   \   0000004C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000050   0xE000             B.N      ??xmit_datablock_6
   1214          #else
   1215                      SDHC_DATPORT = _psp_swap4byte (*ptr++);
   1216          #endif
   1217          
   1218                  }
   1219              }	
   1220          
   1221          
   1222          	return 1;
   \                     ??xmit_datablock_1:
   \   00000052   0x2001             MOVS     R0,#+1
   \                     ??xmit_datablock_6:
   \   00000054   0xBC10             POP      {R4}
   \   00000056   0x4770             BX       LR               ;; return
   1223          }
   1224          
   1225          
   1226          
   1227          /*-----------------------------------------------------------------------*/
   1228          /* Write Sector(s)                                                        */
   1229          /*-----------------------------------------------------------------------*/
   1230          //=========================================================================
   1231          //函数名称：disk_write                                                        
   1232          //功能概要：写数据盘扇区                                                
   1233          //参数说明：drv:设备号
   1234          //         buff:待写入SD卡的数据的缓存区首地址
   1235          //         sector:起始扇区号
   1236          //         count:扇区数
   1237          //函数返回：RES_OK：成功，其它：失败                                                              
   1238          //=========================================================================
   1239          

   \                                 In section .text, align 2, keep-with-next
   1240          DRESULT disk_write (
   1241              U8  drv,     /* Physical drive nmuber (0) */
   1242              const U8  *buff, /* Pointer to the data buffer to store read data */
   1243              U32 sector,      /* Start sector number (LBA) */
   1244              U8  count        /* Sector count (1..255) */
   1245          )
   1246          {
   \                     disk_write:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x001D             MOVS     R5,R3
   1247              ESDHC_COMMAND_STRUCT command;
   1248              SDCARD_STRUCT_PTR    sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;
   \   00000008   0x....             LDR.N    R4,??DataTable16_4
   1249          	
   1250          	if (drv || !count) return RES_PARERR;
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD102             BNE.N    ??disk_write_0
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE.N    ??disk_write_1
   \                     ??disk_write_0:
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0xE07B             B.N      ??disk_write_2
   1251          	if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_write_1:
   \   0000001A   0x....             LDR.N    R0,??DataTable16_6
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD501             BPL.N    ??disk_write_3
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE075             B.N      ??disk_write_2
   1252          	if (Stat & STA_PROTECT) return RES_WRPRT;
   \                     ??disk_write_3:
   \   00000026   0x....             LDR.N    R0,??DataTable16_6
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x0740             LSLS     R0,R0,#+29
   \   0000002C   0xD501             BPL.N    ??disk_write_4
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE06F             B.N      ??disk_write_2
   1253          	
   1254              /* Check parameters */
   1255              if ((NULL == buff))
   \                     ??disk_write_4:
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD101             BNE.N    ??disk_write_5
   1256              {
   1257                  return FALSE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE06B             B.N      ??disk_write_2
   1258              }	
   1259          
   1260              if (!sdcard_ptr->SDHC)
   \                     ??disk_write_5:
   \   0000003A   0x7B20             LDRB     R0,[R4, #+12]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD102             BNE.N    ??disk_write_6
   1261              {
   1262              	sector *= 512;	/* Convert to byte address if needed */
   \   00000040   0xF44F 0x7000      MOV      R0,#+512
   \   00000044   0x4342             MULS     R2,R0,R2
   1263              }
   1264          
   1265          	if (count == 1)	/* Single block write */
   \                     ??disk_write_6:
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D01             CMP      R5,#+1
   \   0000004A   0xD11B             BNE.N    ??disk_write_7
   1266          	{
   1267          	    command.COMMAND = ESDHC_CMD24;
   \   0000004C   0x2018             MOVS     R0,#+24
   \   0000004E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1268          	    command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1269          	    command.ARGUMENT = sector;
   \   00000058   0x9201             STR      R2,[SP, #+4]
   1270          	    command.READ = FALSE;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1271          	    command.BLOCKS = count;
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x9503             STR      R5,[SP, #+12]
   1272          	
   1273          	    if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000064   0xA900             ADD      R1,SP,#+0
   \   00000066   0xF241 0x3002      MOVW     R0,#+4866
   \   0000006A   0x.... 0x....      BL       SDHC_ioctl
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD126             BNE.N    ??disk_write_8
   1274          	    {
   1275          	    	if (xmit_datablock(buff,512))
   \   00000072   0xF44F 0x7100      MOV      R1,#+512
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0x.... 0x....      BL       xmit_datablock
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD01F             BEQ.N    ??disk_write_8
   1276          	    	{
   1277          	    		count = 0;
   \   00000080   0x2500             MOVS     R5,#+0
   \   00000082   0xE01D             B.N      ??disk_write_8
   1278          	    	}
   1279          	    }
   1280          	}
   1281          	else 
   1282          	{
   1283          		//if (CardType & CT_SDC) send_cmd(ACMD23, count);
   1284          		//if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
   1285          		command.COMMAND = ESDHC_CMD25;
   \                     ??disk_write_7:
   \   00000084   0x2019             MOVS     R0,#+25
   \   00000086   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1286          	    command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1287          	    command.ARGUMENT = sector;
   \   00000090   0x9201             STR      R2,[SP, #+4]
   1288          	    command.READ = FALSE;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1289          	    command.BLOCKS = count;
   \   00000098   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009A   0x9503             STR      R5,[SP, #+12]
   1290          	    		
   1291          	    if (ESDHC_OK == SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   0000009C   0xA900             ADD      R1,SP,#+0
   \   0000009E   0xF241 0x3002      MOVW     R0,#+4866
   \   000000A2   0x.... 0x....      BL       SDHC_ioctl
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD10A             BNE.N    ??disk_write_8
   1292          	    {
   1293          	    	if (xmit_datablock(buff,512*count))
   \   000000AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AC   0xF44F 0x7000      MOV      R0,#+512
   \   000000B0   0xFB00 0xF105      MUL      R1,R0,R5
   \   000000B4   0x0030             MOVS     R0,R6
   \   000000B6   0x.... 0x....      BL       xmit_datablock
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD000             BEQ.N    ??disk_write_8
   1294          	    	{
   1295          	    		count = 0;
   \   000000BE   0x2500             MOVS     R5,#+0
   1296          	    	}
   1297          	    }
   1298          	}
   1299          	
   1300          	/* Wait for card ready / transaction state */
   1301              do
   1302              {
   1303                  command.COMMAND = ESDHC_CMD13;
   \                     ??disk_write_8:
   \   000000C0   0x200D             MOVS     R0,#+13
   \   000000C2   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1304                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1305                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000000CC   0x6920             LDR      R0,[R4, #+16]
   \   000000CE   0x9001             STR      R0,[SP, #+4]
   1306                  command.READ = FALSE;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1307                  command.BLOCKS = 0;
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x9003             STR      R0,[SP, #+12]
   1308                  if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000000DA   0xA900             ADD      R1,SP,#+0
   \   000000DC   0xF241 0x3002      MOVW     R0,#+4866
   \   000000E0   0x.... 0x....      BL       SDHC_ioctl
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD001             BEQ.N    ??disk_write_9
   1309                  {
   1310                      return RES_ERROR;
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0xE012             B.N      ??disk_write_2
   1311                  }
   1312          
   1313                  /* Card status error check */
   1314                  if (command.RESPONSE[0] & 0xFFD98008)
   \                     ??disk_write_9:
   \   000000EC   0x9804             LDR      R0,[SP, #+16]
   \   000000EE   0x....             LDR.N    R1,??DataTable16_9  ;; 0xffd98008
   \   000000F0   0x4208             TST      R0,R1
   \   000000F2   0xD001             BEQ.N    ??disk_write_10
   1315                  {
   1316                      return RES_ERROR;
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xE00C             B.N      ??disk_write_2
   1317                  }
   1318              } while (0x000000900 != (command.RESPONSE[0] & 0x00001F00));		
   \                     ??disk_write_10:
   \   000000F8   0x9804             LDR      R0,[SP, #+16]
   \   000000FA   0xF410 0x50F8      ANDS     R0,R0,#0x1F00
   \   000000FE   0xF5B0 0x6F10      CMP      R0,#+2304
   \   00000102   0xD1DD             BNE.N    ??disk_write_8
   1319          	    	
   1320          	return count ? RES_ERROR : RES_OK;
   \   00000104   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000106   0x2D00             CMP      R5,#+0
   \   00000108   0xD001             BEQ.N    ??disk_write_11
   \   0000010A   0x2001             MOVS     R0,#+1
   \   0000010C   0xE000             B.N      ??disk_write_12
   \                     ??disk_write_11:
   \   0000010E   0x2000             MOVS     R0,#+0
   \                     ??disk_write_12:
   \   00000110   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_write_2:
   \   00000112   0xB008             ADD      SP,SP,#+32
   \   00000114   0xBD70             POP      {R4-R6,PC}       ;; return
   1321          }
   1322          
   1323          
   1324          /*-----------------------------------------------------------------------*/
   1325          /* Miscellaneous Functions                                               */
   1326          /*-----------------------------------------------------------------------*/
   1327          

   \                                 In section .text, align 2, keep-with-next
   1328          DRESULT disk_ioctl (
   1329              U8 drv,             /* Physical drive nmuber (0) */
   1330              U8 ctrl,            /* Control code */
   1331              void  *buff         /* Buffer to send/receive control data */
   1332          )
   1333          {
   \                     disk_ioctl:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0014             MOVS     R4,R2
   1334              DRESULT      res;
   1335              ESDHC_COMMAND_STRUCT command;
   1336              SDCARD_STRUCT_PTR	 sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;	
   \   00000006   0x....             LDR.N    R2,??DataTable16_4
   1337          
   1338              if (drv) return RES_PARERR;
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??disk_ioctl_0
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0xE043             B.N      ??disk_ioctl_1
   1339          
   1340              res = RES_ERROR;
   \                     ??disk_ioctl_0:
   \   00000012   0x2001             MOVS     R0,#+1
   1341          
   1342              if (Stat & STA_NOINIT) return RES_NOTRDY;
   \   00000014   0x....             LDR.N    R3,??DataTable16_6
   \   00000016   0x781B             LDRB     R3,[R3, #+0]
   \   00000018   0x07DB             LSLS     R3,R3,#+31
   \   0000001A   0xD501             BPL.N    ??disk_ioctl_2
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xE03C             B.N      ??disk_ioctl_1
   1343          
   1344              switch (ctrl) 
   \                     ??disk_ioctl_2:
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD005             BEQ.N    ??disk_ioctl_3
   \   00000026   0x2902             CMP      R1,#+2
   \   00000028   0xD009             BEQ.N    ??disk_ioctl_4
   \   0000002A   0xD304             BCC.N    ??disk_ioctl_5
   \   0000002C   0x2903             CMP      R1,#+3
   \   0000002E   0xD00B             BEQ.N    ??disk_ioctl_6
   \   00000030   0xE031             B.N      ??disk_ioctl_7
   1345              {
   1346                  case CTRL_SYNC :        /* Make sure that no pending write process. Do not remove this or written sector might not left updated. */		
   1347                      res = RES_OK;
   \                     ??disk_ioctl_3:
   \   00000032   0x2000             MOVS     R0,#+0
   1348                  break;
   \   00000034   0xE030             B.N      ??disk_ioctl_8
   1349          
   1350                  case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
   1351                      *(unsigned long*)buff = sdcard_ptr->NUM_BLOCKS;
   \                     ??disk_ioctl_5:
   \   00000036   0x6890             LDR      R0,[R2, #+8]
   \   00000038   0x6020             STR      R0,[R4, #+0]
   1352                      res = RES_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   1353                  break;  
   \   0000003C   0xE02C             B.N      ??disk_ioctl_8
   1354          
   1355              case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
   1356                  *(unsigned short*)buff = 512;
   \                     ??disk_ioctl_4:
   \   0000003E   0xF44F 0x7000      MOV      R0,#+512
   \   00000042   0x8020             STRH     R0,[R4, #+0]
   1357                  res = RES_OK;
   \   00000044   0x2000             MOVS     R0,#+0
   1358                  break;
   \   00000046   0xE027             B.N      ??disk_ioctl_8
   1359          
   1360              case GET_BLOCK_SIZE :           /* Get erase block size in unit of sector (DWORD) */
   1361                  // Implementar
   1362                  command.COMMAND = ESDHC_CMD9;
   \                     ??disk_ioctl_6:
   \   00000048   0x2009             MOVS     R0,#+9
   \   0000004A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1363                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1364                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   00000054   0x6910             LDR      R0,[R2, #+16]
   \   00000056   0x9001             STR      R0,[SP, #+4]
   1365                  command.READ = FALSE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1366                  command.BLOCKS = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x9003             STR      R0,[SP, #+12]
   1367                  if (ESDHC_OK != SDHC_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000062   0xA900             ADD      R1,SP,#+0
   \   00000064   0xF241 0x3002      MOVW     R0,#+4866
   \   00000068   0x.... 0x....      BL       SDHC_ioctl
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD001             BEQ.N    ??disk_ioctl_9
   1368                  {
   1369                      return RES_ERROR;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xE012             B.N      ??disk_ioctl_1
   1370                  }
   1371                  if (0 == (command.RESPONSE[3] & 0x00C00000))
   \                     ??disk_ioctl_9:
   \   00000074   0x9807             LDR      R0,[SP, #+28]
   \   00000076   0xF410 0x0F40      TST      R0,#0xC00000
   \   0000007A   0xD10A             BNE.N    ??disk_ioctl_10
   1372                  {
   1373                      //SD V1
   1374                      *(unsigned long*)buff = ((((command.RESPONSE[2] >> 18) & 0x7F) + 1) << (((command.RESPONSE[3] >> 8) & 0x03) - 1));
   \   0000007C   0x9806             LDR      R0,[SP, #+24]
   \   0000007E   0xF3C0 0x4086      UBFX     R0,R0,#+18,#+7
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x9907             LDR      R1,[SP, #+28]
   \   00000086   0x0A09             LSRS     R1,R1,#+8
   \   00000088   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   0000008C   0x1E49             SUBS     R1,R1,#+1
   \   0000008E   0x4088             LSLS     R0,R0,R1
   \   00000090   0x6020             STR      R0,[R4, #+0]
   1375                  }
   1376                  else
   1377                  {
   1378                       //SD V2
   1379                      // Implementar
   1380                      //*(DWORD*)buff = (((command.RESPONSE[2] >> 18) & 0x7F) << (((command.RESPONSE[3] >> 8) & 0x03) - 1));
   1381                  }           
   1382                  res = RES_OK;
   \                     ??disk_ioctl_10:
   \   00000092   0x2000             MOVS     R0,#+0
   1383                  break;
   \   00000094   0xE000             B.N      ??disk_ioctl_8
   1384          
   1385              default:
   1386                  res = RES_PARERR;
   \                     ??disk_ioctl_7:
   \   00000096   0x2004             MOVS     R0,#+4
   1387              }
   1388          
   1389              return res;
   \                     ??disk_ioctl_8:
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_ioctl_1:
   \   0000009A   0xB008             ADD      SP,SP,#+32
   \   0000009C   0xBD10             POP      {R4,PC}          ;; return
   1390          }
   1391          
   1392          /*-----------------------------------------------------------------------*/
   1393          /* Get Card Stat                                                         */
   1394          /*-----------------------------------------------------------------------*/
   1395          

   \                                 In section .text, align 2, keep-with-next
   1396          U8 GetCardStat(void)
   1397          {
   1398            return Stat;
   \                     GetCardStat:
   \   00000000   0x....             LDR.N    R0,??DataTable16_6
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1399          }
   1400          
   1401          /*-----------------------------------------------------------------------*/
   1402          /* Set Card Stat                                                         */
   1403          /*-----------------------------------------------------------------------*/
   1404          

   \                                 In section .text, align 2, keep-with-next
   1405          void SetCardStat(U8 state)
   1406          {
   1407            Stat = state;
   \                     SetCardStat:
   \   00000000   0x....             LDR.N    R1,??DataTable16_6
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   1408          }
   \   00000004   0x4770             BX       LR               ;; return
   1409          
   1410          /*-----------------------------------------------------------------------*/
   1411          /* Get Disk Status                                                       */
   1412          /*-----------------------------------------------------------------------*/
   1413          

   \                                 In section .text, align 2, keep-with-next
   1414          DSTATUS disk_status (
   1415              U8 drv      /* Physical drive nmuber (0) */
   1416          )
   1417          {
   1418              if (drv) return STA_NOINIT; /* Supports only single drive */
   \                     disk_status:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD001             BEQ.N    ??disk_status_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE001             B.N      ??disk_status_1
   1419              return Stat;
   \                     ??disk_status_0:
   \   0000000A   0x....             LDR.N    R0,??DataTable16_6
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \                     ??disk_status_1:
   \   0000000E   0x4770             BX       LR               ;; return
   1420          }
   1421          
   1422          
   1423          
   1424          /*-----------------------------------------------------------------------*/
   1425          /* Device Timer Interrupt Procedure                                      */
   1426          /*-----------------------------------------------------------------------*/
   1427          /* This function must be called in period of 10ms                        */
   1428          

   \                                 In section .text, align 2, keep-with-next
   1429          void disk_timerproc (void)
   1430          {
   1431              U8 s;   
   1432              
   1433              Timer++;
   \                     disk_timerproc:
   \   00000000   0x....             LDR.N    R0,??DataTable16_10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0x....             LDR.N    R1,??DataTable16_10
   \   00000008   0x6008             STR      R0,[R1, #+0]
   1434              s = Stat;
   \   0000000A   0x....             LDR.N    R0,??DataTable16_6
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   1435          
   1436              #if (SOCKWP == 1)
   1437              if (SDCARD_GPIO_PROTECT == 0)             
   1438              {
   1439                  s &= ~STA_PROTECT;      /* Write enabled */
   1440              }
   1441              else     
   1442              {
   1443                  s |= STA_PROTECT;       /* Write protected */
   1444              }
   1445              #else
   1446                s &= ~STA_PROTECT;
   \   0000000E   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   1447              #endif
   1448          
   1449              if (SDCARD_GPIO_DETECT == 0)        /* Card inserted */
   1450                  s &= ~STA_NODISK;
   \   00000012   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   1451              else                                /* Socket empty */
   1452                  s |= (STA_NODISK | STA_NOINIT);
   1453          
   1454              Stat = s;                           /* Update MMC status */
   \   00000016   0x....             LDR.N    R1,??DataTable16_6
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   1455          }
   \   0000001A   0x4770             BX       LR               ;; return
   1456          
   1457          
   1458          ////////////////////////////////////////////////////////////
   1459          ////////////////////////////////////////////////////////////
   1460          /////      Return Calendar Function                    /////
   1461          ////////////////////////////////////////////////////////////
   1462          ////////////////////////////////////////////////////////////
   1463          

   \                                 In section .text, align 2, keep-with-next
   1464          void GetFatTimer(U32 *time)
   1465          {
   1466            //UserEnterCritical();
   1467           // *time = Timer;
   1468           // UserExitCritical();
   1469          }
   \                     GetFatTimer:
   \   00000000   0x4770             BX       LR               ;; return
   1470          
   1471          ////////////////////////////////////////////////////////////
   1472          ////////////////////////////////////////////////////////////
   1473          ////////////////////////////////////////////////////////////
   1474          ////////////////////////////////////////////////////////////
   1475          
   1476          
   1477          ////////////////////////////////////////////////////////////
   1478          ////////////////////////////////////////////////////////////
   1479          /////      Set Calendar Function                       /////
   1480          ////////////////////////////////////////////////////////////
   1481          ////////////////////////////////////////////////////////////
   1482          

   \                                 In section .text, align 2, keep-with-next
   1483          void SetFatTimer(U32 time)
   1484          {
   1485            //UserEnterCritical();
   1486            //Timer = time;
   1487            //UserExitCritical();
   1488          }
   \                     SetFatTimer:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0xFFFFF844         DC32     0xfffff844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x400B102C         DC32     0x400b102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0xFFF0000F         DC32     0xfff0000f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x400B1024         DC32     0x400b1024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x01008000         DC32     0x1008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x400B10C0         DC32     0x400b10c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x400B1004         DC32     0x400b1004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x400B1028         DC32     0x400b1028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x400B1044         DC32     0x400b1044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x0005CC60         DC32     0x5cc60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     rtc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x4004D008         DC32     0x4004d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x4004D00C         DC32     0x4004d00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4004D010         DC32     0x4004d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x4004D014         DC32     0x4004d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x400B1030         DC32     0x400b1030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x400B1034         DC32     0x400b1034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x007F00B3         DC32     0x7f00b3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     ESDHC_COMMAND_XFERTYP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x400B1008         DC32     0x400b1008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x400B1000         DC32     0x400b1000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x400B100C         DC32     0x400b100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x000E0001         DC32     0xe0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x400B1010         DC32     0x400b1010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x400B1014         DC32     0x400b1014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x400B1018         DC32     0x400b1018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x400B101C         DC32     0x400b101c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     SDHC_Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     SDHC_Device

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     K60_SDHC0_init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40300000         DC32     0x40300000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     SDHC_Card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     SDHC_Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x400B1020         DC32     0x400b1020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x400B1024         DC32     0x400b1024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0xFFD98008         DC32     0xffd98008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x........         DC32     Timer

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  GetCardStat
        0  GetFatTimer
        8  SDHC_init
              8 -> SDHC_set_baudrate
       72  SDHC_ioctl
             72 -> Delay
             72 -> SDHC_init
             72 -> SDHC_is_running
             72 -> SDHC_send_command
             72 -> SDHC_set_baudrate
             72 -> SDHC_status_wait
        0  SDHC_is_running
       16  SDHC_send_command
             16 -> SDHC_status_wait
       24  SDHC_set_baudrate
             24 -> Delay
        0  SDHC_status_wait
        0  SetCardStat
        0  SetFatTimer
       48  disk_initialize
             48 -> SDHC_ioctl
       40  disk_ioctl
             40 -> SDHC_ioctl
       48  disk_read
             48 -> SDHC_ioctl
             48 -> rcvr_datablock
        0  disk_status
        0  disk_timerproc
       48  disk_write
             48 -> SDHC_ioctl
             48 -> xmit_datablock
        0  get_fattime
        4  rcvr_datablock
        4  xmit_datablock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
     256  ESDHC_COMMAND_XFERTYP
       6  GetCardStat
       2  GetFatTimer
      12  K60_SDHC0_init
      20  SDHC_Card
       8  SDHC_Device
     516  SDHC_Info
       4  SDHC_Init
     246  SDHC_init
    1510  SDHC_ioctl
      24  SDHC_is_running
     388  SDHC_send_command
     164  SDHC_set_baudrate
      16  SDHC_status_wait
       6  SetCardStat
       2  SetFatTimer
       1  Stat
       4  Timer
     660  disk_initialize
     158  disk_ioctl
     202  disk_read
      16  disk_status
      28  disk_timerproc
     278  disk_write
      68  get_fattime
     134  rcvr_datablock
       8  rtc
      88  xmit_datablock

 
   560 bytes in section .bss
     1 byte  in section .data
   268 bytes in section .rodata
 4 160 bytes in section .text
 
 4 160 bytes of CODE  memory
   268 bytes of CONST memory
   561 bytes of DATA  memory

Errors: none
Warnings: 4
