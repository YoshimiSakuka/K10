###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        26/May/2016  12:04:40
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\ye\Desktop\NFS.NO 2 - 副本\common\ADC.c
#    Command line =  
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\common\ADC.c" -D DEBUG -lCN
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\List\" -lB
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\List\" -o
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -Ol --use_c++_inline
#    List file    =  C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\List\ADC.lst
#    Object file  =  C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\Obj\ADC.o
#
###############################################################################

C:\Users\ye\Desktop\NFS.NO 2 - 副本\common\ADC.c
      1          #include "ADC.h"
      2          
      3          
      4          

   \                                 In section .bss, align 4
      5          tADC_Config Master_Adc_Config;          //该结构体包含了需要的ADC/PGA配置
   \                     Master_Adc_Config:
   \   00000000                      DS8 16
      6          

   \                                 In section .data, align 4
      7          volatile struct ADC_MemMap *ADCx[2] = {ADC0_BASE_PTR, ADC1_BASE_PTR}; //定义两个指针数组保存 ADCx 的地址
   \                     ADCx:
   \   00000000   0x4003B000         DC32 4003B000H, 400BB000H
   \              0x400BB000   
      8          
      9          
     10          
     11          
     12          /*
     13          // AD IO 初始化
     14          //
     15          //
     16          //
     17          */

   \                                 In section .text, align 2, keep-with-next
     18          void adc_IO_init(ADCn adcn, ADC_Ch ch)
     19          {
     20              //ASSERT( ((adcn == ADC0) && (ch >= AD8 && ch <= AD18)) || ((adcn == ADC1) && (ch >= AD4a && ch <= AD17)) ) ; //使用断言检测ADCn_CHn是否正常
     21          
     22              switch(adcn)
   \                     adc_IO_init: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD003             BEQ.N    ??adc_IO_init_0
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xF000 0x8086      BEQ.W    ??adc_IO_init_1
   \   0000000C   0xE0F7             B.N      ??adc_IO_init_2
     23              {
     24              case ADC0:       /*   ADC0  */
     25                  SIM_SCGC6 |= (SIM_SCGC6_ADC0_MASK );        //开启ADC0时钟
   \                     ??adc_IO_init_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable4  ;; 0x4004803c
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable4  ;; 0x4004803c
   \   0000001C   0x6010             STR      R0,[R2, #+0]
     26                  SIM_SOPT7 &= ~(SIM_SOPT7_ADC0ALTTRGEN_MASK  | SIM_SOPT7_ADC0PRETRGSEL_MASK);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable4_1  ;; 0x40048018
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF030 0x0090      BICS     R0,R0,#0x90
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable4_1  ;; 0x40048018
   \   0000002C   0x6010             STR      R0,[R2, #+0]
     27                  SIM_SOPT7 = SIM_SOPT7_ADC0TRGSEL(0);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      LDR.W    R2,??DataTable4_1  ;; 0x40048018
   \   00000034   0x6010             STR      R0,[R2, #+0]
     28                  ADC0_SC3 |= (ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(2));
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x4003b024
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable4_2  ;; 0x4003b024
   \   00000044   0x6010             STR      R0,[R2, #+0]
     29                  switch(ch)
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x0008             MOVS     R0,R1
   \   0000004A   0x3808             SUBS     R0,R0,#+8
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD90C             BLS.N    ??adc_IO_init_3
   \   00000050   0x1E80             SUBS     R0,R0,#+2
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD91B             BLS.N    ??adc_IO_init_4
   \   00000056   0x1E80             SUBS     R0,R0,#+2
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD92A             BLS.N    ??adc_IO_init_5
   \   0000005C   0x1E80             SUBS     R0,R0,#+2
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD939             BLS.N    ??adc_IO_init_6
   \   00000062   0x1EC0             SUBS     R0,R0,#+3
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD947             BLS.N    ??adc_IO_init_7
   \   00000068   0xE055             B.N      ??adc_IO_init_8
     30                  {
     31                  case AD8:   //ADC0_SE8 -- PTB0
     32                  case AD9:   //ADC0_SE9 -- PTB1
     33                      SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
   \                     ??adc_IO_init_3: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable4_3  ;; 0x40048038
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000074   0x.... 0x....      LDR.W    R2,??DataTable4_3  ;; 0x40048038
   \   00000078   0x6010             STR      R0,[R2, #+0]
     34                      PORT_PCR_REG(PORTB_BASE_PTR, ch - AD8 + 0) =  PORT_PCR_MUX(0);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007E   0x0089             LSLS     R1,R1,#+2
   \   00000080   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000084   0xF511 0x2194      ADDS     R1,R1,#+303104
   \   00000088   0xF841 0x0C20      STR      R0,[R1, #-32]
     35                      break;
     36                  case AD10:  //ADC0_SE10 -- PTA7
     37                  case AD11:  //ADC0_SE11 -- PTA8
     38                      SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
     39                      PORT_PCR_REG(PORTA_BASE_PTR, ch - AD10 + 7) =  PORT_PCR_MUX(0);
     40                      break;
     41                  case AD12:  //ADC0_SE12 -- PTB2
     42                  case AD13:  //ADC0_SE13 -- PTB3
     43                      SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
     44                      PORT_PCR_REG(PORTB_BASE_PTR, ch - AD12 + 2) =  PORT_PCR_MUX(0);
     45                      break;
     46                  case AD14:  //ADC0_SE14 -- PTC0
     47                  case AD15:  //ADC0_SE15 -- PTC1
     48                      SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
     49                      PORT_PCR_REG(PORTC_BASE_PTR, ch - AD14 + 0) =  PORT_PCR_MUX(0);
     50                      break;
     51                  case AD17:   //ADC0_SE17 -- PTE24
     52                  case AD18:   //ADC0_SE17 -- PTE25
     53                      SIM_SCGC5 |= SIM_SCGC5_PORTE_MASK;
     54                      PORT_PCR_REG(PORTE_BASE_PTR, ch - AD17 + 24) =  PORT_PCR_MUX(0);
     55                      break;
     56                  default:
     57                      return;
     58                  }
     59                  return;
   \                     ??adc_IO_init_9: (+1)
   \   0000008C   0xE0B7             B.N      ??adc_IO_init_10
   \                     ??adc_IO_init_4: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable4_3  ;; 0x40048038
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000098   0x.... 0x....      LDR.W    R2,??DataTable4_3  ;; 0x40048038
   \   0000009C   0x6010             STR      R0,[R2, #+0]
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A2   0x0089             LSLS     R1,R1,#+2
   \   000000A4   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000000A8   0xF511 0x2192      ADDS     R1,R1,#+299008
   \   000000AC   0xF841 0x0C0C      STR      R0,[R1, #-12]
   \   000000B0   0xE7EC             B.N      ??adc_IO_init_9
   \                     ??adc_IO_init_5: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable4_3  ;; 0x40048038
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000BC   0x.... 0x....      LDR.W    R2,??DataTable4_3  ;; 0x40048038
   \   000000C0   0x6010             STR      R0,[R2, #+0]
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C6   0x0089             LSLS     R1,R1,#+2
   \   000000C8   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000000CC   0xF511 0x2194      ADDS     R1,R1,#+303104
   \   000000D0   0xF841 0x0C28      STR      R0,[R1, #-40]
   \   000000D4   0xE7DA             B.N      ??adc_IO_init_9
   \                     ??adc_IO_init_6: (+1)
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable4_3  ;; 0x40048038
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000E0   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40048038
   \   000000E2   0x6010             STR      R0,[R2, #+0]
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000E8   0x0089             LSLS     R1,R1,#+2
   \   000000EA   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000000EE   0xF511 0x2196      ADDS     R1,R1,#+307200
   \   000000F2   0xF841 0x0C38      STR      R0,[R1, #-56]
   \   000000F6   0xE7C9             B.N      ??adc_IO_init_9
   \                     ??adc_IO_init_7: (+1)
   \   000000F8   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40048038
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000100   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40048038
   \   00000102   0x6010             STR      R0,[R2, #+0]
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000108   0x0089             LSLS     R1,R1,#+2
   \   0000010A   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   0000010E   0xF511 0x219A      ADDS     R1,R1,#+315392
   \   00000112   0x61C8             STR      R0,[R1, #+28]
   \   00000114   0xE7BA             B.N      ??adc_IO_init_9
   \                     ??adc_IO_init_8: (+1)
   \   00000116   0xE072             B.N      ??adc_IO_init_10
     60          
     61              case ADC1:       /*   ADC1    */
     62                  SIM_SCGC3 |= (SIM_SCGC3_ADC1_MASK );
   \                     ??adc_IO_init_1: (+1)
   \   00000118   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40048030
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000120   0x....             LDR.N    R2,??DataTable4_4  ;; 0x40048030
   \   00000122   0x6010             STR      R0,[R2, #+0]
     63                  SIM_SOPT7 &= ~(SIM_SOPT7_ADC1ALTTRGEN_MASK  | SIM_SOPT7_ADC1PRETRGSEL_MASK) ;
   \   00000124   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40048018
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0xF430 0x4010      BICS     R0,R0,#0x9000
   \   0000012C   0x....             LDR.N    R2,??DataTable4_1  ;; 0x40048018
   \   0000012E   0x6010             STR      R0,[R2, #+0]
     64                  SIM_SOPT7 = SIM_SOPT7_ADC1TRGSEL(0);
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x....             LDR.N    R2,??DataTable4_1  ;; 0x40048018
   \   00000134   0x6010             STR      R0,[R2, #+0]
     65                  ADC1_SC3 |= (ADC_SC3_AVGE_MASK | ADC_SC3_AVGS(2));
   \   00000136   0x....             LDR.N    R0,??DataTable4_5  ;; 0x400bb024
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   0000013E   0x....             LDR.N    R2,??DataTable4_5  ;; 0x400bb024
   \   00000140   0x6010             STR      R0,[R2, #+0]
     66                  switch(ch)
   \   00000142   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000144   0x0008             MOVS     R0,R1
   \   00000146   0x1F00             SUBS     R0,R0,#+4
   \   00000148   0x2803             CMP      R0,#+3
   \   0000014A   0xD90B             BLS.N    ??adc_IO_init_11
   \   0000014C   0x1F00             SUBS     R0,R0,#+4
   \   0000014E   0x2801             CMP      R0,#+1
   \   00000150   0xD918             BLS.N    ??adc_IO_init_12
   \   00000152   0x1E80             SUBS     R0,R0,#+2
   \   00000154   0x2803             CMP      R0,#+3
   \   00000156   0xD925             BLS.N    ??adc_IO_init_13
   \   00000158   0x1F00             SUBS     R0,R0,#+4
   \   0000015A   0x2801             CMP      R0,#+1
   \   0000015C   0xD932             BLS.N    ??adc_IO_init_14
   \   0000015E   0x1EC0             SUBS     R0,R0,#+3
   \   00000160   0xD040             BEQ.N    ??adc_IO_init_15
   \   00000162   0xE04B             B.N      ??adc_IO_init_16
     67                  {
     68                  case AD4a:   //ADC1_SE4a -- PTE0
     69                  case AD5a:   //ADC1_SE5a -- PTE1
     70                  case AD6a:   //ADC1_SE6a -- PTE2
     71                  case AD7a:   //ADC1_SE7a -- PTE3
     72                      SIM_SCGC5 |= SIM_SCGC5_PORTE_MASK;
   \                     ??adc_IO_init_11: (+1)
   \   00000164   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40048038
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000016C   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40048038
   \   0000016E   0x6010             STR      R0,[R2, #+0]
     73                      PORT_PCR_REG(PORTE_BASE_PTR, ch - AD4a + 0) =  PORT_PCR_MUX(0);
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000174   0x0089             LSLS     R1,R1,#+2
   \   00000176   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   0000017A   0xF511 0x219A      ADDS     R1,R1,#+315392
   \   0000017E   0xF841 0x0C10      STR      R0,[R1, #-16]
     74                      break;
   \   00000182   0xE03B             B.N      ??adc_IO_init_17
     75                  case AD8:  //ADC1_SE8 -- PTB0
     76                  case AD9:  //ADC1_SE9 -- PTB1
     77                      SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
   \                     ??adc_IO_init_12: (+1)
   \   00000184   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40048038
   \   00000186   0x6800             LDR      R0,[R0, #+0]
   \   00000188   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000018C   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40048038
   \   0000018E   0x6010             STR      R0,[R2, #+0]
     78                      PORT_PCR_REG(PORTB_BASE_PTR, ch - AD8 + 0) =  PORT_PCR_MUX(0);
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000194   0x0089             LSLS     R1,R1,#+2
   \   00000196   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   0000019A   0xF511 0x2194      ADDS     R1,R1,#+303104
   \   0000019E   0xF841 0x0C20      STR      R0,[R1, #-32]
     79                      break;
   \   000001A2   0xE02B             B.N      ??adc_IO_init_17
     80                  case AD10:  //ADC1_SE10 -- PTB4
     81                  case AD11:  //ADC1_SE11 -- PTB5
     82                  case AD12:  //ADC1_SE12 -- PTB6
     83                  case AD13:  //ADC1_SE13 -- PTB7
     84                      SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
   \                     ??adc_IO_init_13: (+1)
   \   000001A4   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40048038
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000001AC   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40048038
   \   000001AE   0x6010             STR      R0,[R2, #+0]
     85                      PORT_PCR_REG(PORTB_BASE_PTR, ch - 6) =  PORT_PCR_MUX(0);
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001B4   0x0089             LSLS     R1,R1,#+2
   \   000001B6   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000001BA   0xF511 0x2194      ADDS     R1,R1,#+303104
   \   000001BE   0xF841 0x0C18      STR      R0,[R1, #-24]
     86                      break;
   \   000001C2   0xE01B             B.N      ??adc_IO_init_17
     87                  case AD14:  //ADC1_SE14 -- PTB10
     88                  case AD15:  //ADC1_SE15 -- PTB11
     89                      SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
   \                     ??adc_IO_init_14: (+1)
   \   000001C4   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40048038
   \   000001C6   0x6800             LDR      R0,[R0, #+0]
   \   000001C8   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000001CC   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40048038
   \   000001CE   0x6010             STR      R0,[R2, #+0]
     90                      PORT_PCR_REG(PORTB_BASE_PTR, ch - AD10 + 4) =  PORT_PCR_MUX(0);
   \   000001D0   0x2000             MOVS     R0,#+0
   \   000001D2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001D4   0x0089             LSLS     R1,R1,#+2
   \   000001D6   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   000001DA   0xF511 0x2194      ADDS     R1,R1,#+303104
   \   000001DE   0xF841 0x0C18      STR      R0,[R1, #-24]
     91                      break;
   \   000001E2   0xE00B             B.N      ??adc_IO_init_17
     92                  case AD17:  //ADC1_SE17 -- PTA17
     93                      SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
   \                     ??adc_IO_init_15: (+1)
   \   000001E4   0x....             LDR.N    R0,??DataTable4_3  ;; 0x40048038
   \   000001E6   0x6800             LDR      R0,[R0, #+0]
   \   000001E8   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000001EC   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40048038
   \   000001EE   0x6010             STR      R0,[R2, #+0]
     94                      PORT_PCR_REG(PORTA_BASE_PTR, ch) =  PORT_PCR_MUX(0);
   \   000001F0   0x2000             MOVS     R0,#+0
   \   000001F2   0x....             LDR.N    R2,??DataTable4_6  ;; 0x40049000
   \   000001F4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001F6   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
     95                      break;
   \   000001FA   0xE7FF             B.N      ??adc_IO_init_17
     96                  default:
     97                      break;
     98                  }
     99                  break;
   \                     ??adc_IO_init_16: (+1)
   \                     ??adc_IO_init_17: (+1)
   \   000001FC   0xE7FF             B.N      ??adc_IO_init_18
    100              default:
    101                  break;
    102              }
    103          }
   \                     ??adc_IO_init_2: (+1)
   \                     ??adc_IO_init_18: (+1)
   \                     ??adc_IO_init_10: (+1)
   \   000001FE   0x4770             BX       LR               ;; return
    104          
    105          
    106          
    107          
    108          /*************************************************************************
    109          *                             野火嵌入式开发工作室
    110          *
    111          *  函数名称：ad_once
    112          *  功能说明：采集一次一路模拟量的AD值
    113          *  参数说明：ADCn        模块号（ ADC0、 ADC1）
    114          *            ADC_Channel 通道号
    115          *            ADC_nbit    精度（ ADC_8bit,ADC_12bit, ADC_10bit, ADC_16bit ）
    116          *  函数返回：无符号结果值
    117          *  修改时间：2012-2-10
    118          *  备    注：参考苏州大学的例程，B通道不能软件触发！！！！
    119          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    120          u16 ad_once(ADCn adcn, ADC_Ch ch, ADC_nbit bit) //采集某路模拟量的AD值
    121          {
   \                     ad_once: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    122              u16 result = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    123              //ASSERT( ((adcn == ADC0) && (ch >= AD8 && ch <= AD18)) || ((adcn == ADC1) && (ch >= AD4a && ch <= AD17)) ) ; //使用断言检测ADCn_CHn是否正常
    124          
    125              adc_start(adcn, ch, bit);	  //启动ADC转换
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       adc_start
    126          
    127              while (( ADC_SC1_REG(ADCx[adcn], 0 ) & ADC_SC1_COCO_MASK ) != ADC_SC1_COCO_MASK);
   \                     ??ad_once_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable4_7
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x0600             LSLS     R0,R0,#+24
   \   0000001E   0xD5F8             BPL.N    ??ad_once_0
    128              result = ADC_R_REG(ADCx[adcn], 0);
   \   00000020   0x....             LDR.N    R0,??DataTable4_7
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000028   0x6905             LDR      R5,[R0, #+16]
    129              ADC_SC1_REG(ADCx[adcn], 0) &= ~ADC_SC1_COCO_MASK;
   \   0000002A   0x....             LDR.N    R0,??DataTable4_7
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000038   0x....             LDR.N    R1,??DataTable4_7
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000040   0x6008             STR      R0,[R1, #+0]
    130              return result;
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    131          }
    132          
    133          /*************************************************************************
    134          *                             野火嵌入式开发工作室
    135          *
    136          *  函数名称：ad_mid
    137          *  功能说明：采集三次一路模拟量的AD值，返回 中值
    138          *  参数说明：ADCx        模块号（ ADC0、 ADC1）
    139          *            ADC_Channel 通道号
    140          *            ADC_nbit    精度（ ADC_8bit,ADC_12bit, ADC_10bit, ADC_16bit ）
    141          *  函数返回：无符号结果值
    142          *  修改时间：2012-2-10
    143          *  备    注：修改苏州大学的例程
    144          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    145          u16 ad_mid(ADCn adcn, ADC_Ch ch, ADC_nbit bit)
    146          {
   \                     ad_mid: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    147              u16 i, j, k, tmp;
    148              //ASSERT( ((adcn == ADC0) && (ch >= AD8 && ch <= AD18)) || ((adcn == ADC1) && (ch >= AD4a && ch <= AD17)) ) ; //使用断言检测ADCn_CHn是否正常
    149          
    150              //3次ADC转换
    151              i = ad_once(adcn, ch, bit);
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       ad_once
   \   0000001A   0x0007             MOVS     R7,R0
    152              j = ad_once(adcn, ch, bit);
   \   0000001C   0x0032             MOVS     R2,R6
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       ad_once
   \   0000002C   0x4680             MOV      R8,R0
    153              k = ad_once(adcn, ch, bit);
   \   0000002E   0x0032             MOVS     R2,R6
   \   00000030   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       ad_once
    154          
    155              //取中值
    156              tmp = i > j ? i : j;          //tmp取两者最大值
   \   0000003E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000042   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000044   0x45B8             CMP      R8,R7
   \   00000046   0xD201             BCS.N    ??ad_mid_0
   \   00000048   0x46B8             MOV      R8,R7
   \   0000004A   0xE7FF             B.N      ??ad_mid_1
    157              return k > tmp ?    tmp :  (   k > i  ?    k   :     i  );
   \                     ??ad_mid_0: (+1)
   \                     ??ad_mid_1: (+1)
   \   0000004C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000050   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000052   0x4580             CMP      R8,R0
   \   00000054   0xD201             BCS.N    ??ad_mid_2
   \   00000056   0x4647             MOV      R7,R8
   \   00000058   0xE005             B.N      ??ad_mid_3
   \                     ??ad_mid_2: (+1)
   \   0000005A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000005C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005E   0x4287             CMP      R7,R0
   \   00000060   0xD201             BCS.N    ??ad_mid_4
   \   00000062   0x0007             MOVS     R7,R0
   \   00000064   0xE7FF             B.N      ??ad_mid_3
   \                     ??ad_mid_4: (+1)
   \                     ??ad_mid_3: (+1)
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    158              //                k>tmp>i             tmp>k>i   tmp>i>k
    159          }
    160          
    161          /*************************************************************************
    162          *                             野火嵌入式开发工作室
    163          *
    164          *  函数名称：ad_ave
    165          *  功能说明：多次采样，取平均值
    166          *  参数说明：ADCx        模块号（ ADC0、 ADC1）
    167          *            ADC_Channel 通道号
    168          *            ADC_nbit    精度（ ADC_8bit,ADC_12bit, ADC_10bit, ADC_16bit ）
    169          *            N           均值滤波次数(范围:0~255)
    170          *  函数返回：16位无符号结果值
    171          *  修改时间：2012-2-10
    172          *  备    注：修改苏州大学的例程
    173          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    174          u16 ad_ave(ADCn adcn, ADC_Ch ch, ADC_nbit bit, u8 N) //均值滤波
    175          {
   \                     ad_ave: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    176              u32 tmp = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    177              u8  i;
    178              //ASSERT( ((adcn == ADC0) && (ch >= AD8 && ch <= AD18)) || ((adcn == ADC1) && (ch >= AD4a && ch <= AD17)) ) ; //使用断言检测ADCn_CHn是否正常
    179          
    180              for(i = 0; i < N; i++)
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   \   00000014   0xE00B             B.N      ??ad_ave_0
    181                  tmp += ad_once(adcn, ch, bit);
   \                     ??ad_ave_1: (+1)
   \   00000016   0x0032             MOVS     R2,R6
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x.... 0x....      BL       ad_once
   \   00000026   0xFA18 0xF880      UXTAH    R8,R8,R0
   \   0000002A   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??ad_ave_0: (+1)
   \   0000002E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x45B9             CMP      R9,R7
   \   00000036   0xD3EE             BCC.N    ??ad_ave_1
    182              tmp = tmp / N;
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0xFBB8 0xF8F7      UDIV     R8,R8,R7
    183              return (u16)tmp;
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    184          }
    185          
    186          
    187          /*************************************************************************
    188          *                             野火嵌入式开发工作室
    189          *
    190          *  函数名称：ad_flt
    191          *  功能说明：一次采样后，与前几次采样，求平均值
    192          *  参数说明：ADCx        模块号（ ADC0、 ADC1）
    193          *            ADC_Channel 通道号
    194          *            ADC_nbit    精度（ ADC_8bit,ADC_12bit, ADC_10bit, ADC_16bit ）
    195          *  函数返回：16位无符号结果值
    196          *  修改时间：2012-2-10
    197          *  备    注：
    198          *************************************************************************/
    199          #define SAMP_COUNT  2       //向前滤波 2^SAMP_COUNT 次数  不能太大，不然采样不准

   \                                 In section .text, align 2, keep-with-next
    200          u16 ad_flt(ADCn adcn, ADC_Ch ch, ADC_nbit bit)
    201          {
   \                     ad_flt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    202              static u16 buf[(1<<(SAMP_COUNT))] = {0};  //保存前  2^SAMP_COUNT 次 的采样数据
    203              static u8 n = (u8)(0x100 - (char)(1 << (SAMP_COUNT)));
    204              static u32 sum = 0;
    205          
    206              //ASSERT( ((adcn == ADC0) && (ch >= AD8 && ch <= AD18)) || ((adcn == ADC1) && (ch >= AD4a && ch <= AD17)) ) ; //使用断言检测ADCn_CHn是否正常
    207          
    208              if(n >= (u8)(0x100 - (char)(1 << (SAMP_COUNT))))
   \   00000002   0x....             LDR.N    R3,??DataTable4_8
   \   00000004   0x781B             LDRB     R3,[R3, #+0]
   \   00000006   0x2BFC             CMP      R3,#+252
   \   00000008   0xDB22             BLT.N    ??ad_flt_0
    209              {
    210                  buf[(u8)((1<<(SAMP_COUNT))+n)] = ad_once(adcn, ch, bit);
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       ad_once
   \   00000014   0x....             LDR.N    R1,??DataTable4_9
   \   00000016   0x....             LDR.N    R2,??DataTable4_8
   \   00000018   0x7812             LDRB     R2,[R2, #+0]
   \   0000001A   0x1D12             ADDS     R2,R2,#+4
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0xF821 0x0012      STRH     R0,[R1, R2, LSL #+1]
    211                  sum += buf[(u8)((1<<(SAMP_COUNT))+n)];
   \   00000022   0x....             LDR.N    R0,??DataTable4_10
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x....             LDR.N    R1,??DataTable4_9
   \   00000028   0x....             LDR.N    R2,??DataTable4_8
   \   0000002A   0x7812             LDRB     R2,[R2, #+0]
   \   0000002C   0x1D12             ADDS     R2,R2,#+4
   \   0000002E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000030   0xF831 0x1012      LDRH     R1,[R1, R2, LSL #+1]
   \   00000034   0xFA10 0xF081      UXTAH    R0,R0,R1
   \   00000038   0x....             LDR.N    R1,??DataTable4_10
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    212                  n++;
   \   0000003C   0x....             LDR.N    R0,??DataTable4_8
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x....             LDR.N    R1,??DataTable4_8
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    213                  return ((u16)(sum >> SAMP_COUNT));
   \   00000046   0x....             LDR.N    R0,??DataTable4_10
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x0880             LSRS     R0,R0,#+2
   \   0000004C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004E   0xE02E             B.N      ??ad_flt_1
    214              }
    215          
    216              sum -= buf[n];
   \                     ??ad_flt_0: (+1)
   \   00000050   0x....             LDR.N    R3,??DataTable4_10
   \   00000052   0x681B             LDR      R3,[R3, #+0]
   \   00000054   0x....             LDR.N    R4,??DataTable4_9
   \   00000056   0x....             LDR.N    R5,??DataTable4_8
   \   00000058   0x782D             LDRB     R5,[R5, #+0]
   \   0000005A   0xF834 0x4015      LDRH     R4,[R4, R5, LSL #+1]
   \   0000005E   0x1B1B             SUBS     R3,R3,R4
   \   00000060   0x....             LDR.N    R4,??DataTable4_10
   \   00000062   0x6023             STR      R3,[R4, #+0]
    217              buf[n] = ad_once(adcn, ch, bit);
   \   00000064   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000066   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x.... 0x....      BL       ad_once
   \   0000006E   0x....             LDR.N    R1,??DataTable4_9
   \   00000070   0x....             LDR.N    R2,??DataTable4_8
   \   00000072   0x7812             LDRB     R2,[R2, #+0]
   \   00000074   0xF821 0x0012      STRH     R0,[R1, R2, LSL #+1]
    218              sum += buf[n];
   \   00000078   0x....             LDR.N    R0,??DataTable4_10
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x....             LDR.N    R1,??DataTable4_9
   \   0000007E   0x....             LDR.N    R2,??DataTable4_8
   \   00000080   0x7812             LDRB     R2,[R2, #+0]
   \   00000082   0xF831 0x1012      LDRH     R1,[R1, R2, LSL #+1]
   \   00000086   0xFA10 0xF081      UXTAH    R0,R0,R1
   \   0000008A   0x....             LDR.N    R1,??DataTable4_10
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    219          
    220              if (++n >= (1 << (SAMP_COUNT)))
   \   0000008E   0x....             LDR.N    R0,??DataTable4_8
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0x....             LDR.N    R1,??DataTable4_8
   \   00000096   0x7008             STRB     R0,[R1, #+0]
   \   00000098   0x....             LDR.N    R0,??DataTable4_8
   \   0000009A   0x7800             LDRB     R0,[R0, #+0]
   \   0000009C   0x2804             CMP      R0,#+4
   \   0000009E   0xDB02             BLT.N    ??ad_flt_2
    221              {
    222                  n = 0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x....             LDR.N    R1,??DataTable4_8
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
    223              }
    224              return ((u16)(sum >> SAMP_COUNT)); /* ADC采样值由若干次采样值平均 */
   \                     ??ad_flt_2: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable4_10
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x0880             LSRS     R0,R0,#+2
   \   000000AC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??ad_flt_1: (+1)
   \   000000AE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    225          }

   \                                 In section .bss, align 4
   \                     ??buf:
   \   00000000                      DS8 8

   \                                 In section .data, align 1
   \                     ??n:
   \   00000000   0xFC               DC8 252

   \                                 In section .bss, align 4
   \                     ??sum:
   \   00000000                      DS8 4
    226          #undef  SAMP_COUNT
    227          
    228          
    229          
    230          
    231          /*************************************************************************
    232          *                             野火嵌入式开发工作室
    233          *
    234          *  函数名称：adc_start
    235          *  功能说明：启动adc软件采样，B通道不能用于软件触发！！！！
    236          *  参数说明：ADCx        模块号（ ADC0、 ADC1）
    237          *            ADC_Channel 通道号
    238          *            ADC_nbit    精度（ ADC_8bit,ADC_12bit, ADC_10bit, ADC_16bit ）
    239          *  函数返回：无
    240          *  修改时间：2012-2-10
    241          *  备    注：修改苏州大学的例程
    242          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          void adc_start(ADCn adcn, ADC_Ch ch, ADC_nbit bit)
    244          {
   \                     adc_start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    245          
    246              Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH( ch );
   \   00000002   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000006   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   0000000A   0x....             LDR.N    R3,??DataTable4_11
   \   0000000C   0x7219             STRB     R1,[R3, #+8]
    247          
    248              //初始化ADC默认配置
    249              Master_Adc_Config.CONFIG1  = ADLPC_NORMAL
    250                                           | ADC_CFG1_ADIV(ADIV_4)
    251                                           | ADLSMP_LONG
    252                                           | ADC_CFG1_MODE(bit)
    253                                           | ADC_CFG1_ADICLK(ADICLK_BUS);
   \   0000000E   0x0091             LSLS     R1,R2,#+2
   \   00000010   0xF011 0x010C      ANDS     R1,R1,#0xC
   \   00000014   0xF051 0x0150      ORRS     R1,R1,#0x50
   \   00000018   0x....             LDR.N    R2,??DataTable4_11
   \   0000001A   0x7011             STRB     R1,[R2, #+0]
    254              Master_Adc_Config.CONFIG2  = MUXSEL_ADCA    //MUXSEL_ADCA
    255                                           | ADACKEN_DISABLED
    256                                           | ADHSC_HISPEED
    257                                           | ADC_CFG2_ADLSTS(ADLSTS_20) ;
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x....             LDR.N    R2,??DataTable4_11
   \   00000020   0x7051             STRB     R1,[R2, #+1]
    258          
    259              Master_Adc_Config.COMPARE1 = 0x1234u ;                 //任意值
   \   00000022   0xF241 0x2134      MOVW     R1,#+4660
   \   00000026   0x....             LDR.N    R2,??DataTable4_11
   \   00000028   0x8051             STRH     R1,[R2, #+2]
    260              Master_Adc_Config.COMPARE2 = 0x5678u ;                 //任意值
   \   0000002A   0xF245 0x6178      MOVW     R1,#+22136
   \   0000002E   0x....             LDR.N    R2,??DataTable4_11
   \   00000030   0x8091             STRH     R1,[R2, #+4]
    261          
    262              adc_config_alt(ADCx[adcn], &Master_Adc_Config);       // 配置 ADCn
   \   00000032   0x....             LDR.N    R1,??DataTable4_11
   \   00000034   0x....             LDR.N    R2,??DataTable4_7
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   0000003C   0x.... 0x....      BL       adc_config_alt
    263          }
   \   00000040   0xBD01             POP      {R0,PC}          ;; return
    264          
    265          /*************************************************************************
    266          *                             野火嵌入式开发工作室
    267          *
    268          *  函数名称：adc_stop
    269          *  功能说明：停止ADC转换
    270          *  参数说明：ADCx        模块号（ ADC0、 ADC1）
    271          *            ADC_Channel 通道号
    272          *  函数返回：无
    273          *  修改时间：2012-2-10
    274          *  备    注：修改苏州大学的例程
    275          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    276          void adc_stop(ADCn adcn)
    277          {
   \                     adc_stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    278              Master_Adc_Config.STATUS1A = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(Module_disabled);
   \   00000002   0x215F             MOVS     R1,#+95
   \   00000004   0x....             LDR.N    R2,??DataTable4_11
   \   00000006   0x7211             STRB     R1,[R2, #+8]
    279              adc_config_alt(ADCx[adcn], &Master_Adc_Config);  // 配置ADC0
   \   00000008   0x....             LDR.N    R1,??DataTable4_11
   \   0000000A   0x....             LDR.N    R2,??DataTable4_7
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   00000012   0x.... 0x....      BL       adc_config_alt
    280          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    281          
    282          
    283          /*************************************************************************
    284          *                             野火嵌入式开发工作室
    285          *
    286          *  函数名称：adc_config_alt
    287          *  功能说明：将adc寄存器结构体配置进adc寄存器
    288          *  参数说明：adcmap      adc基址寄存器地址（ADC0_BASE_PTR,ADC1_BASE_PTR）
    289          *            ADC_CfgPtr  存放 寄存器值的结构体
    290          *  函数返回：无
    291          *  修改时间：2012-2-10
    292          *  备    注：修改官方工程的例程
    293          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    294          void adc_config_alt(ADC_MemMapPtr adcmap, tADC_ConfigPtr ADC_CfgPtr)
    295          {
    296              ADC_CFG1_REG(adcmap) = ADC_CfgPtr->CONFIG1;
   \                     adc_config_alt: (+1)
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0x6082             STR      R2,[R0, #+8]
    297              ADC_CFG2_REG(adcmap) = ADC_CfgPtr->CONFIG2;
   \   00000004   0x784A             LDRB     R2,[R1, #+1]
   \   00000006   0x60C2             STR      R2,[R0, #+12]
    298              ADC_CV1_REG(adcmap)  = ADC_CfgPtr->COMPARE1;
   \   00000008   0x884A             LDRH     R2,[R1, #+2]
   \   0000000A   0x6182             STR      R2,[R0, #+24]
    299              ADC_CV2_REG(adcmap)  = ADC_CfgPtr->COMPARE2;
   \   0000000C   0x888A             LDRH     R2,[R1, #+4]
   \   0000000E   0x61C2             STR      R2,[R0, #+28]
    300              ADC_SC2_REG(adcmap)  = ADC_CfgPtr->STATUS2;
   \   00000010   0x798A             LDRB     R2,[R1, #+6]
   \   00000012   0x6202             STR      R2,[R0, #+32]
    301              ADC_SC3_REG(adcmap)  = ADC_CfgPtr->STATUS3;
   \   00000014   0x79CA             LDRB     R2,[R1, #+7]
   \   00000016   0x6242             STR      R2,[R0, #+36]
    302              ADC_PGA_REG(adcmap)  = ADC_CfgPtr->PGA;
   \   00000018   0x68CA             LDR      R2,[R1, #+12]
   \   0000001A   0x6502             STR      R2,[R0, #+80]
    303              ADC_SC1_REG(adcmap, A) = ADC_CfgPtr->STATUS1A;
   \   0000001C   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000001E   0x6002             STR      R2,[R0, #+0]
    304              ADC_SC1_REG(adcmap, B) = ADC_CfgPtr->STATUS1B;
   \   00000020   0x7A49             LDRB     R1,[R1, #+9]
   \   00000022   0x6041             STR      R1,[R0, #+4]
    305          }
   \   00000024   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40048018         DC32     0x40048018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x4003B024         DC32     0x4003b024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x400BB024         DC32     0x400bb024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     ADCx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     ??n

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     ??buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     ??sum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x........         DC32     Master_Adc_Config

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ad_ave
        32   -> ad_once
      16   ad_flt
        16   -> ad_once
      24   ad_mid
        24   -> ad_once
      16   ad_once
        16   -> adc_start
       0   adc_IO_init
       0   adc_config_alt
       8   adc_start
         8   -> adc_config_alt
       8   adc_stop
         8   -> adc_config_alt


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       8  ADCx
      16  Master_Adc_Config
      70  ad_ave
     176  ad_flt
     110  ad_mid
      72  ad_once
     512  adc_IO_init
      38  adc_config_alt
      66  adc_start
      24  adc_stop
       8  buf
       1  n
       4  sum

 
    28 bytes in section .bss
     9 bytes in section .data
 1 116 bytes in section .text
 
 1 116 bytes of CODE memory
    37 bytes of DATA memory

Errors: none
Warnings: none
