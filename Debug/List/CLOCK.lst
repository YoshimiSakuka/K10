###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        26/May/2016  12:04:48
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\ye\Desktop\NFS.NO 2 - 副本\common\CLOCK.c
#    Command line =  
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\common\CLOCK.c" -D DEBUG -lCN
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\List\" -lB
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\List\" -o
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -Ol --use_c++_inline
#    List file    =  C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\List\CLOCK.lst
#    Object file  =  C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\Obj\CLOCK.o
#
###############################################################################

C:\Users\ye\Desktop\NFS.NO 2 - 副本\common\CLOCK.c
      1          #include "CLOCK.h"
      2          
      3          
      4          //#ifdef  __cplusplus
      5          //extern "C" {
      6          //#endif
      7            
      8          
      9          __ramfunc static void SetSysDividers(ULONG uiOutDiv1, ULONG uiOutDiv2, ULONG uiOutDiv3, ULONG uiOutDiv4);  
     10          
     11          
     12          
     13          //时钟参数，便于外部调用
     14          extern u32 core_clk_khz;
     15          extern u32 core_clk_mhz;
     16          extern u32 bus_clk_khz;
     17          
     18          //时钟分频因子

   \                                 In section .data, align 4
     19          struct mcg_div mcg_div = { PRDIV , VDIV , CORE_DIV , BUS_DIV , FLEX_DIV , FLASH_DIV }; //定义的同时，初始化
   \                     mcg_div:
   \   00000000   0x0B 0x1F          DC8 11, 31, 0, 0, 0, 9, 0, 0
   \              0x00 0x00    
   \              0x00 0x09    
   \              0x00 0x00    
     20          /***FUNC+*********************************************************************/
     21          /* Name   : PLL_Init                                                         */
     22          /* Descrp : Initialize PLL                                                   */
     23          /* Input  : None.                                                            */   
     24          /* Output : None.                                                            */
     25          /* Return : None.                                                            */   
     26          /***FUNC-*********************************************************************/
     27            
     28          
     29          

   \                                 In section .text, align 2, keep-with-next
     30          unsigned char pll_init(clk_option opt)
     31          {
   \                     pll_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     32              unsigned char pll_freq;
     33          
     34          //    if(opt  != PLLUSR ) //自定义模式，直接加载全局变量mcg_div的值
     35          //    {
     36                  //设置MCG时钟
     37                  switch(opt)
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2830             CMP      R0,#+48
   \   00000006   0xD02D             BEQ.N    ??pll_init_0
   \   00000008   0x2832             CMP      R0,#+50
   \   0000000A   0xF000 0x8090      BEQ.W    ??pll_init_1
   \   0000000E   0x2860             CMP      R0,#+96
   \   00000010   0xF000 0x8094      BEQ.W    ??pll_init_2
   \   00000014   0x2864             CMP      R0,#+100
   \   00000016   0xF000 0x8098      BEQ.W    ??pll_init_3
   \   0000001A   0x286E             CMP      R0,#+110
   \   0000001C   0xF000 0x809C      BEQ.W    ??pll_init_4
   \   00000020   0x2878             CMP      R0,#+120
   \   00000022   0xF000 0x80A0      BEQ.W    ??pll_init_5
   \   00000026   0x287D             CMP      R0,#+125
   \   00000028   0xF000 0x80A4      BEQ.W    ??pll_init_6
   \   0000002C   0x2882             CMP      R0,#+130
   \   0000002E   0xF000 0x80A8      BEQ.W    ??pll_init_7
   \   00000032   0x288C             CMP      R0,#+140
   \   00000034   0xF000 0x80AC      BEQ.W    ??pll_init_8
   \   00000038   0x2896             CMP      R0,#+150
   \   0000003A   0xF000 0x80B0      BEQ.W    ??pll_init_9
   \   0000003E   0x28A0             CMP      R0,#+160
   \   00000040   0xF000 0x80B4      BEQ.W    ??pll_init_10
   \   00000044   0x28AA             CMP      R0,#+170
   \   00000046   0xF000 0x80B8      BEQ.W    ??pll_init_11
   \   0000004A   0x28B4             CMP      R0,#+180
   \   0000004C   0xF000 0x80BC      BEQ.W    ??pll_init_12
   \   00000050   0x28C8             CMP      R0,#+200
   \   00000052   0xF000 0x80C0      BEQ.W    ??pll_init_13
   \   00000056   0x28E1             CMP      R0,#+225
   \   00000058   0xF000 0x80C4      BEQ.W    ??pll_init_14
   \   0000005C   0x28FA             CMP      R0,#+250
   \   0000005E   0xF000 0x80C8      BEQ.W    ??pll_init_15
   \   00000062   0xE0CD             B.N      ??pll_init_16
     38                  {
     39                  case PLL48:
     40                      mcg_div.prdiv       = 24;
   \                     ??pll_init_0: (+1)
   \   00000064   0x2018             MOVS     R0,#+24
   \   00000066   0x....             LDR.N    R1,??DataTable1
   \   00000068   0x7008             STRB     R0,[R1, #+0]
     41                      mcg_div.vdiv        = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x....             LDR.N    R1,??DataTable1
   \   0000006E   0x7048             STRB     R0,[R1, #+1]
     42                      break;
     43                  case PLL50:
     44                      mcg_div.prdiv       = 24;
     45                      mcg_div.vdiv        = 1;
     46                      break;
     47                  case PLL96:
     48                      mcg_div.prdiv       = 24;
     49                      mcg_div.vdiv        = 24;
     50                      break;
     51                  case PLL100:
     52                      mcg_div.prdiv       = 24;
     53                      mcg_div.vdiv        = 26;
     54                      break;
     55                  case PLL110:
     56                      mcg_div.prdiv       = 24;
     57                      mcg_div.vdiv        = 31;
     58                      break;
     59                  case PLL120:
     60                      mcg_div.prdiv       = 19;
     61                      mcg_div.vdiv        = 24;
     62                      break;
     63                  case PLL125:
     64                      mcg_div.prdiv       = 19;
     65                      mcg_div.vdiv        = 26;
     66                      break;
     67                  case PLL130:
     68                      mcg_div.prdiv       = 19;
     69                      mcg_div.vdiv        = 28;
     70                      break;
     71                  case PLL140:
     72                      mcg_div.prdiv       = 14;
     73                      mcg_div.vdiv        = 18;
     74                      break;
     75                  case PLL150:
     76                      mcg_div.prdiv       = 14;
     77                      mcg_div.vdiv        = 21;
     78                      break;
     79                  case PLL160:
     80                      mcg_div.prdiv       = 14;
     81                      mcg_div.vdiv        = 24;
     82                      break;
     83                  case PLL170:
     84                      mcg_div.prdiv       = 14;
     85                      mcg_div.vdiv        = 27;
     86                      break;
     87                  case PLL180:
     88                      mcg_div.prdiv       = 14;
     89                      mcg_div.vdiv        = 30;
     90                      break;
     91                  case PLL200:
     92                      mcg_div.prdiv       = 12;
     93                      mcg_div.vdiv        = 28;
     94                      break;
     95                  case PLL225:
     96                      mcg_div.prdiv       = 11;
     97                      mcg_div.vdiv        = 30;
     98                      break;
     99                  case PLL250:
    100                      mcg_div.prdiv       = 10;
    101                      mcg_div.vdiv        = 31;
    102                      break;
    103                  default:
    104                      return pll_init(PLL100);        //这情况不会发生。
    105                  }
    106          
    107                  //设置分频
    108                  mcg_div.core_div    = 0;           // core = MCG
   \                     ??pll_init_17: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x....             LDR.N    R1,??DataTable1
   \   00000074   0x7088             STRB     R0,[R1, #+2]
    109          
    110          //        /* 这里提示警告，但是安全的，是为了安全才故意添加进去 */
    111          //        if     (opt <= 1 * MAX_BUS_CLK)   mcg_div.bus_div = 0;    // bus  = MCG
    112          //        else if(opt <= 2 * MAX_BUS_CLK)   mcg_div.bus_div = 1;    // bus  = MCG/2
    113          //        else if(opt <= 3 * MAX_BUS_CLK)   mcg_div.bus_div = 2;    // bus  = MCG/3
    114          //        else if(opt <= 4 * MAX_BUS_CLK)   mcg_div.bus_div = 3;    // bus  = MCG/4    这里提示警告，不过没关系
    115          //        else                            mcg_div.bus_div = 15;     // bus  = MCG/16
    116          //
    117          //        mcg_div.flex_div = mcg_div.bus_div;                       // flex   = bus
    118          //
    119          //        /* 这里提示警告，但是安全的，是为了安全才故意添加进去 */
    120          //        if     (opt <= 1 * MAX_FLASH_CLK)   mcg_div.flash_div = 0; // flash  = MCG
    121          //        else if(opt <= 2 * MAX_FLASH_CLK)   mcg_div.flash_div = 1; // flash  = MCG/2
    122          //        else if(opt <= 3 * MAX_FLASH_CLK)   mcg_div.flash_div = 2; // flash  = MCG/3
    123          //        else if(opt <= 4 * MAX_FLASH_CLK)   mcg_div.flash_div = 3; // flash  = MCG/4
    124          //        else if(opt <= 5 * MAX_FLASH_CLK)   mcg_div.flash_div = 4; // flash  = MCG/5
    125          //        else if(opt <= 6 * MAX_FLASH_CLK)   mcg_div.flash_div = 5; // flash  = MCG/6
    126          //        else if(opt <= 7 * MAX_FLASH_CLK)   mcg_div.flash_div = 6; // flash  = MCG/7
    127          //        else if(opt <= 8 * MAX_FLASH_CLK)   mcg_div.flash_div = 7; // flash  = MCG/8
    128          //        else if(opt <= 9 * MAX_FLASH_CLK)   mcg_div.flash_div = 8; // flash  = MCG/9     这里提示警告，不过没关系
    129          //        else if(opt <= 10 * MAX_FLASH_CLK)  mcg_div.flash_div = 9; // flash  = MCG/10
    130          //        else                              mcg_div.flash_div = 15; // flash  = MCG/16
    131          //
    132          //    }
    133              pll_freq = (u8)(( (u16)50 * (u16)( mcg_div.vdiv + 24 )) / (u16)( mcg_div.prdiv + 1 ) );            //  50/ ( prdiv +1 ) * ( mcg_div.vdiv + 24 )
   \   00000076   0x....             LDR.N    R0,??DataTable1
   \   00000078   0x7840             LDRB     R0,[R0, #+1]
   \   0000007A   0x3018             ADDS     R0,R0,#+24
   \   0000007C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000007E   0x2132             MOVS     R1,#+50
   \   00000080   0x4348             MULS     R0,R1,R0
   \   00000082   0x....             LDR.N    R1,??DataTable1
   \   00000084   0x7809             LDRB     R1,[R1, #+0]
   \   00000086   0x1C49             ADDS     R1,R1,#+1
   \   00000088   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000008A   0xFB90 0xF4F1      SDIV     R4,R0,R1
    134          
    135              //上电复位后，单片机会自动进入 FEI 模式，使用 内部参考时钟
    136              //为了使用外部时钟参考源，我们要先进入 FBE 模式:
    137          #if (defined(K60_CLK) || defined(ASB817))
    138              MCG_C2 = 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x....             LDR.N    R1,??DataTable1_1  ;; 0x40064001
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    139          #else
    140              // Enable external oscillator, RANGE=2, HGO=1, EREFS=1, LP=0, IRCS=0
    141              MCG_C2 = MCG_C2_RANGE(2) | MCG_C2_HGO_MASK | MCG_C2_EREFS_MASK;
    142          #endif
    143          
    144              //初始化晶振后释放锁定状态的振荡器和GPIO
    145              SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
   \   00000094   0x....             LDR.N    R0,??DataTable1_2  ;; 0x40048034
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000009C   0x....             LDR.N    R1,??DataTable1_2  ;; 0x40048034
   \   0000009E   0x6008             STR      R0,[R1, #+0]
    146              LLWU_CS |= LLWU_CS_ACKISO_MASK;
   \   000000A0   0x....             LDR.N    R0,??DataTable1_3  ;; 0x4007c008
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000A8   0x....             LDR.N    R1,??DataTable1_3  ;; 0x4007c008
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
    147          
    148              // Select external oscilator and Reference Divider and clear IREFS to start ext osc
    149              // CLKS=2, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    150              MCG_C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);
   \   000000AC   0x2098             MOVS     R0,#+152
   \   000000AE   0x....             LDR.N    R1,??DataTable1_4  ;; 0x40064000
   \   000000B0   0x7008             STRB     R0,[R1, #+0]
    151          
    152              /* if we aren't using an osc input we don't need to wait for the osc to init */
    153          #if (!defined(K60_CLK) && !defined(ASB817))
    154              while (!(MCG_S & MCG_S_OSCINIT_MASK)) {};  //等待晶振稳定
    155          #endif
    156          
    157              while (MCG_S & MCG_S_IREFST_MASK) {}; // wait for Reference clock Status bit to clear
   \                     ??pll_init_18: (+1)
   \   000000B2   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40064006
   \   000000B4   0x7800             LDRB     R0,[R0, #+0]
   \   000000B6   0x06C0             LSLS     R0,R0,#+27
   \   000000B8   0xD4FB             BMI.N    ??pll_init_18
    158          
    159              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) {}; // Wait for clock status bits to show clock source is ext ref clk
   \                     ??pll_init_19: (+1)
   \   000000BA   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40064006
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0x2802             CMP      R0,#+2
   \   000000C6   0xD1F8             BNE.N    ??pll_init_19
    160          
    161              //进入FBE模式  分频后结果必须在 ：2 MHz ~ 4 MHz.
    162              //    n       (n+1)分频   50M/(n+1)       n为12~24之间
    163              MCG_C5 = MCG_C5_PRDIV(mcg_div.prdiv);   // prdiv +1 分频 ：2M
   \   000000C8   0x....             LDR.N    R0,??DataTable1
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   000000D0   0x....             LDR.N    R1,??DataTable1_6  ;; 0x40064004
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
    164          
    165              MCG_C6 = 0x0;       // Ensure MCG_C6 is at the reset default of 0. LOLIE disabled, PLL disabled, clk monitor disabled, PLL VCO divider is clear
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x....             LDR.N    R1,??DataTable1_7  ;; 0x40064005
   \   000000D8   0x7008             STRB     R0,[R1, #+0]
    166          
    167              // 设置系统分频因子选项
    168              //MCG=PLL, core = MCG/(mcg_div.core_div + 1), bus = MCG/(mcg_div.bus_div + 1),
    169              //FlexBus = MCG/(mcg_div.flex_div + 1), Flash clock= MCG/(mcg_div.flash_div + 1)
    170              SetSysDividers(mcg_div.core_div, mcg_div.bus_div, mcg_div.flex_div, mcg_div.flash_div);
   \   000000DA   0x....             LDR.N    R0,??DataTable1
   \   000000DC   0x7943             LDRB     R3,[R0, #+5]
   \   000000DE   0x....             LDR.N    R0,??DataTable1
   \   000000E0   0x7902             LDRB     R2,[R0, #+4]
   \   000000E2   0x....             LDR.N    R0,??DataTable1
   \   000000E4   0x78C1             LDRB     R1,[R0, #+3]
   \   000000E6   0x....             LDR.N    R0,??DataTable1
   \   000000E8   0x7880             LDRB     R0,[R0, #+2]
   \   000000EA   0x.... 0x....      BL       SetSysDividers
    171          
    172              // Set the VCO divider and enable the PLL for 48MHz, LOLIE=0, PLLS=1, CME=0, VDIV=0
    173              //   n    (n+24)倍频            n为0~31之间
    174              MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(mcg_div.vdiv) ;  //  mcg_div.vdiv + 1 倍频
   \   000000EE   0x....             LDR.N    R0,??DataTable1
   \   000000F0   0x7840             LDRB     R0,[R0, #+1]
   \   000000F2   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   000000F6   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000000FA   0x....             LDR.N    R1,??DataTable1_7  ;; 0x40064005
   \   000000FC   0x7008             STRB     R0,[R1, #+0]
    175          
    176              while (!(MCG_S & MCG_S_PLLST_MASK)) {}; // wait for PLL status bit to set
   \                     ??pll_init_20: (+1)
   \   000000FE   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40064006
   \   00000100   0x7800             LDRB     R0,[R0, #+0]
   \   00000102   0x0680             LSLS     R0,R0,#+26
   \   00000104   0xD5FB             BPL.N    ??pll_init_20
    177          
    178              while (!(MCG_S & MCG_S_LOCK_MASK)) {}; // Wait for LOCK bit to set
   \                     ??pll_init_21: (+1)
   \   00000106   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40064006
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x0640             LSLS     R0,R0,#+25
   \   0000010C   0xD5FB             BPL.N    ??pll_init_21
    179          
    180              // 现在已经进入了 PBE 模式
    181          
    182              // Transition into PEE by setting CLKS to 0
    183              // CLKS=0, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    184              MCG_C1 &= ~MCG_C1_CLKS_MASK;
   \   0000010E   0x....             LDR.N    R0,??DataTable1_4  ;; 0x40064000
   \   00000110   0x7800             LDRB     R0,[R0, #+0]
   \   00000112   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   00000116   0x....             LDR.N    R1,??DataTable1_4  ;; 0x40064000
   \   00000118   0x7008             STRB     R0,[R1, #+0]
    185          
    186              // Wait for clock status bits to update
    187              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) {};
   \                     ??pll_init_22: (+1)
   \   0000011A   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40064006
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \   0000011E   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000122   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000124   0x2803             CMP      R0,#+3
   \   00000126   0xD1F8             BNE.N    ??pll_init_22
    188          
    189              // 现在已经进入了 PEE 模式
    190          
    191              return pll_freq;
   \   00000128   0x0020             MOVS     R0,R4
   \   0000012A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??pll_init_23: (+1)
   \   0000012C   0xBD10             POP      {R4,PC}          ;; return
   \                     ??pll_init_1: (+1)
   \   0000012E   0x2018             MOVS     R0,#+24
   \   00000130   0x....             LDR.N    R1,??DataTable1
   \   00000132   0x7008             STRB     R0,[R1, #+0]
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0x....             LDR.N    R1,??DataTable1
   \   00000138   0x7048             STRB     R0,[R1, #+1]
   \   0000013A   0xE799             B.N      ??pll_init_17
   \                     ??pll_init_2: (+1)
   \   0000013C   0x2018             MOVS     R0,#+24
   \   0000013E   0x....             LDR.N    R1,??DataTable1
   \   00000140   0x7008             STRB     R0,[R1, #+0]
   \   00000142   0x2018             MOVS     R0,#+24
   \   00000144   0x....             LDR.N    R1,??DataTable1
   \   00000146   0x7048             STRB     R0,[R1, #+1]
   \   00000148   0xE792             B.N      ??pll_init_17
   \                     ??pll_init_3: (+1)
   \   0000014A   0x2018             MOVS     R0,#+24
   \   0000014C   0x....             LDR.N    R1,??DataTable1
   \   0000014E   0x7008             STRB     R0,[R1, #+0]
   \   00000150   0x201A             MOVS     R0,#+26
   \   00000152   0x....             LDR.N    R1,??DataTable1
   \   00000154   0x7048             STRB     R0,[R1, #+1]
   \   00000156   0xE78B             B.N      ??pll_init_17
   \                     ??pll_init_4: (+1)
   \   00000158   0x2018             MOVS     R0,#+24
   \   0000015A   0x....             LDR.N    R1,??DataTable1
   \   0000015C   0x7008             STRB     R0,[R1, #+0]
   \   0000015E   0x201F             MOVS     R0,#+31
   \   00000160   0x....             LDR.N    R1,??DataTable1
   \   00000162   0x7048             STRB     R0,[R1, #+1]
   \   00000164   0xE784             B.N      ??pll_init_17
   \                     ??pll_init_5: (+1)
   \   00000166   0x2013             MOVS     R0,#+19
   \   00000168   0x....             LDR.N    R1,??DataTable1
   \   0000016A   0x7008             STRB     R0,[R1, #+0]
   \   0000016C   0x2018             MOVS     R0,#+24
   \   0000016E   0x....             LDR.N    R1,??DataTable1
   \   00000170   0x7048             STRB     R0,[R1, #+1]
   \   00000172   0xE77D             B.N      ??pll_init_17
   \                     ??pll_init_6: (+1)
   \   00000174   0x2013             MOVS     R0,#+19
   \   00000176   0x....             LDR.N    R1,??DataTable1
   \   00000178   0x7008             STRB     R0,[R1, #+0]
   \   0000017A   0x201A             MOVS     R0,#+26
   \   0000017C   0x....             LDR.N    R1,??DataTable1
   \   0000017E   0x7048             STRB     R0,[R1, #+1]
   \   00000180   0xE776             B.N      ??pll_init_17
   \                     ??pll_init_7: (+1)
   \   00000182   0x2013             MOVS     R0,#+19
   \   00000184   0x....             LDR.N    R1,??DataTable1
   \   00000186   0x7008             STRB     R0,[R1, #+0]
   \   00000188   0x201C             MOVS     R0,#+28
   \   0000018A   0x....             LDR.N    R1,??DataTable1
   \   0000018C   0x7048             STRB     R0,[R1, #+1]
   \   0000018E   0xE76F             B.N      ??pll_init_17
   \                     ??pll_init_8: (+1)
   \   00000190   0x200E             MOVS     R0,#+14
   \   00000192   0x....             LDR.N    R1,??DataTable1
   \   00000194   0x7008             STRB     R0,[R1, #+0]
   \   00000196   0x2012             MOVS     R0,#+18
   \   00000198   0x....             LDR.N    R1,??DataTable1
   \   0000019A   0x7048             STRB     R0,[R1, #+1]
   \   0000019C   0xE768             B.N      ??pll_init_17
   \                     ??pll_init_9: (+1)
   \   0000019E   0x200E             MOVS     R0,#+14
   \   000001A0   0x....             LDR.N    R1,??DataTable1
   \   000001A2   0x7008             STRB     R0,[R1, #+0]
   \   000001A4   0x2015             MOVS     R0,#+21
   \   000001A6   0x....             LDR.N    R1,??DataTable1
   \   000001A8   0x7048             STRB     R0,[R1, #+1]
   \   000001AA   0xE761             B.N      ??pll_init_17
   \                     ??pll_init_10: (+1)
   \   000001AC   0x200E             MOVS     R0,#+14
   \   000001AE   0x....             LDR.N    R1,??DataTable1
   \   000001B0   0x7008             STRB     R0,[R1, #+0]
   \   000001B2   0x2018             MOVS     R0,#+24
   \   000001B4   0x....             LDR.N    R1,??DataTable1
   \   000001B6   0x7048             STRB     R0,[R1, #+1]
   \   000001B8   0xE75A             B.N      ??pll_init_17
   \                     ??pll_init_11: (+1)
   \   000001BA   0x200E             MOVS     R0,#+14
   \   000001BC   0x....             LDR.N    R1,??DataTable1
   \   000001BE   0x7008             STRB     R0,[R1, #+0]
   \   000001C0   0x201B             MOVS     R0,#+27
   \   000001C2   0x....             LDR.N    R1,??DataTable1
   \   000001C4   0x7048             STRB     R0,[R1, #+1]
   \   000001C6   0xE753             B.N      ??pll_init_17
   \                     ??pll_init_12: (+1)
   \   000001C8   0x200E             MOVS     R0,#+14
   \   000001CA   0x....             LDR.N    R1,??DataTable1
   \   000001CC   0x7008             STRB     R0,[R1, #+0]
   \   000001CE   0x201E             MOVS     R0,#+30
   \   000001D0   0x....             LDR.N    R1,??DataTable1
   \   000001D2   0x7048             STRB     R0,[R1, #+1]
   \   000001D4   0xE74C             B.N      ??pll_init_17
   \                     ??pll_init_13: (+1)
   \   000001D6   0x200C             MOVS     R0,#+12
   \   000001D8   0x....             LDR.N    R1,??DataTable1
   \   000001DA   0x7008             STRB     R0,[R1, #+0]
   \   000001DC   0x201C             MOVS     R0,#+28
   \   000001DE   0x....             LDR.N    R1,??DataTable1
   \   000001E0   0x7048             STRB     R0,[R1, #+1]
   \   000001E2   0xE745             B.N      ??pll_init_17
   \                     ??pll_init_14: (+1)
   \   000001E4   0x200B             MOVS     R0,#+11
   \   000001E6   0x....             LDR.N    R1,??DataTable1
   \   000001E8   0x7008             STRB     R0,[R1, #+0]
   \   000001EA   0x201E             MOVS     R0,#+30
   \   000001EC   0x....             LDR.N    R1,??DataTable1
   \   000001EE   0x7048             STRB     R0,[R1, #+1]
   \   000001F0   0xE73E             B.N      ??pll_init_17
   \                     ??pll_init_15: (+1)
   \   000001F2   0x200A             MOVS     R0,#+10
   \   000001F4   0x....             LDR.N    R1,??DataTable1
   \   000001F6   0x7008             STRB     R0,[R1, #+0]
   \   000001F8   0x201F             MOVS     R0,#+31
   \   000001FA   0x....             LDR.N    R1,??DataTable1
   \   000001FC   0x7048             STRB     R0,[R1, #+1]
   \   000001FE   0xE737             B.N      ??pll_init_17
   \                     ??pll_init_16: (+1)
   \   00000200   0x2064             MOVS     R0,#+100
   \   00000202   0xF7FF 0xFEFD      BL       pll_init
   \   00000206   0xE791             B.N      ??pll_init_23
    192          } //pll_init
    193          
    194          
    195          
    196          
    197          
    198          
    199          
    200          
    201          
    202          
    203          //
    204          //void PLL_Init(void)
    205          //{
    206          //    //默认开始为FEI  切换到FBE               FEI-FBE-PBE-PEE
    207          //    MCG_C2 = 0;                        // x x RANGE HGO EREFS LP IRCS
    208          //                                       // 0 0   00    0    0   0   0
    209          //                                       // RANGE=00:Low frequency range selected for the crystal oscillator of 32 kHz to 40 kHz
    210          //                                       // HGO  =0 :Configure crystal oscillator for low-power operation     配置晶振为低电源操作
    211          //                                       // EREFS=0 :External reference clock requested       外部时钟参考选择
    212          //    
    213          //    SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;   //llwu时钟允许
    214          //    LLWU_CS |= LLWU_CS_ACKISO_MASK;      //释放GPIO
    215          //    
    216          //    MCG_C1 = MCG_C1_CLKS(2) |          // CLKS FRDIV IREFS IRCLKEN IREFSTEN
    217          //             MCG_C1_FRDIV(3);          //  10   011    1     0        0  
    218          //                                       // CLKS =10 :External reference clock is selected    选择外部晶振
    219          //                                       // FRDIV=011:Divide Factor is 8   分频因子8
    220          //                                       //IREFS = 0 外部时钟被选 启动外部晶振时钟 
    221          //    
    222          //    while (MCG_S & MCG_S_IREFST_MASK)  // wait until source of FLL reference clock is the external reference clock
    223          //    {                                    // IREFST=0时 FLL参考时钟为外部参考时钟 向IREFS写入后该位不立即更新 等待该位更新
    224          //        ;  
    225          //    }
    226          //    
    227          //    while (((MCG_S & MCG_S_CLKST_MASK) // wait until external reference clock is selected
    228          //          >> MCG_S_CLKST_SHIFT) != 0x2)// CLKST为2时 选择外部时钟 CLKS写入后该位不立即更新 等待该位更新
    229          //    {
    230          //        ;   
    231          //    }
    232          //                //已进入FBE 切换到PBE
    233          //    MCG_C5 = MCG_C5_PRDIV(24);       // x PLLCLKEN PLLSTEN PRDIV
    234          //                                       // 0    0        0    11000
    235          //                                       // PRDIV=11000:Divide Factor is 25   得到2Mhz时钟
    236          //       
    237          //    SetSysDividers(0, 1, 1, 3);        // MCG=PLL, core=MCG, bus=MCG/2, FlexBus=MCG/2, Flash clock=MCG/4
    238          //    
    239          //    MCG_C6 = MCG_C6_PLLS_MASK |        // LOLIE PLLS CME VDIV  
    240          //             MCG_C6_VDIV(24);          //   0    1    0  11000    
    241          //                                       // PLLS=1    :PLL is selected    Pll作为MCG时钟
    242          //                                       // VDIV=11000:Multiply Factor is 48  VCO分频器
    243          //                                       // PLL = 2MHz x 48 = 96MHz
    244          //    
    245          //    while (!(MCG_S & MCG_S_PLLST_MASK))// wait until source of PLLS clock is PLL clock  为1时PLLS时钟为PLL时钟 PLLS置位后该位不立即更新
    246          //    {
    247          //        ;   
    248          //    }
    249          //    
    250          //    while (!(MCG_S & MCG_S_LOCK_MASK)) // wait until PLL is locked  等待PLL锁存
    251          //    {
    252          //        ;
    253          //    }
    254          //    
    255          //    MCG_C1 &= ~MCG_C1_CLKS_MASK;       // Output of FLL or PLL is selected  选择FLL或者PLL输出  根据PLLS位
    256          //    
    257          //    while (((MCG_S & MCG_S_CLKST_MASK) // wait until Output of the PLL is selected  等待PLL时钟输出被选择
    258          //          >> MCG_S_CLKST_SHIFT) != 0x3)
    259          //    {
    260          //        ;
    261          //    }
    262          //}
    263          
    264          
    265          /***FUNC+*********************************************************************/
    266          /* Name   : FLL_Init                                                         */
    267          /* Descrp : Initialize PLL                                                   */
    268          /* Input  : None.                                                            */   
    269          /* Output : None.                                                            */
    270          /* Return : None.                                                            */   
    271          /***FUNC-*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    272          void FLL_Init(void)
    273          
    274          {
   \                     FLL_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    275          
    276            
    277          
    278              SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
   \   00000002   0x....             LDR.N    R0,??DataTable1_2  ;; 0x40048034
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000000A   0x....             LDR.N    R1,??DataTable1_2  ;; 0x40048034
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    279          
    280              LLWU_CS |= LLWU_CS_ACKISO_MASK;
   \   0000000E   0x....             LDR.N    R0,??DataTable1_3  ;; 0x4007c008
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000016   0x....             LDR.N    R1,??DataTable1_3  ;; 0x4007c008
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    281          
    282              
    283          
    284              MCG_C1 = (MCG_C1_CLKS(0)                                // CLKS =00:Output of FLL or PLL is selected    FLL或者PLL时钟选择为MCGOUTCLK
    285          
    286                       |MCG_C1_IREFS_MASK);                                 // IREFS= 1:The slow internal reference clock is selected     慢内部参考时钟被选为FLL参考时钟频率
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0x....             LDR.N    R1,??DataTable1_4  ;; 0x40064000
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    287          
    288              
    289          
    290              MCG_C6 = 0;                                                                // PLLS=0:FLL is selected PLLLS为0 选择FLL为MCG时钟
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable1_7  ;; 0x40064005
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    291          
    292              
    293          
    294              
    295          
    296              while (!(MCG_S & MCG_S_IREFST_MASK))          // wait until source of FLL reference clock is the internal reference clock
   \                     ??FLL_Init_0: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40064006
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x06C0             LSLS     R0,R0,#+27
   \   0000002C   0xD5FB             BPL.N    ??FLL_Init_0
    297          
    298              {
    299          
    300                  ;  
    301          
    302              }
    303          
    304              
    305          
    306              while (((MCG_S & MCG_S_CLKST_MASK)            // wait until Output of the FLL is selected
    307          
    308                    >> MCG_S_CLKST_SHIFT) != 0x0)
   \                     ??FLL_Init_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40064006
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F8             BNE.N    ??FLL_Init_1
    309          
    310              {
    311          
    312                  ;   
    313          
    314              }
    315          
    316              
    317          
    318              SetSysDividers(0, 1, 1, 3);                                          // MCG=FLL, core=MCG, bus=MCG/2, FlexBus=MCG/2, Flash clock=MCG/4
   \   0000003C   0x2303             MOVS     R3,#+3
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      BL       SetSysDividers
    319          
    320              
    321          
    322              MCG_C4 = (MCG_C4_DMX32_MASK             // DMX32   = 1:DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
    323          
    324                       |MCG_C4_DRST_DRS(3));                              // DRST_DRS=11:High range
   \   00000048   0x20E0             MOVS     R0,#+224
   \   0000004A   0x....             LDR.N    R1,??DataTable1_8  ;; 0x40064003
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
    325          
    326                                                                                              // DCO=96MHz
    327          
    328              
    329          
    330              while (MCG_S & MCG_S_PLLST_MASK)                // wait until source of PLLS clock is FLL clock
   \                     ??FLL_Init_2: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40064006
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x0680             LSLS     R0,R0,#+26
   \   00000054   0xD4FB             BMI.N    ??FLL_Init_2
    331          
    332              {
    333          
    334                  ;   
    335          
    336              }
    337          
    338                 
    339          
    340          }
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
    341          
    342          
    343          /***FUNC+*********************************************************************/
    344          /* Name   : SetSysDividers                                                   */
    345          /* Descrp : This routine must be placed in RAM.It is a                       */
    346          /*          workaround for errata e2448.Flash prefetch must                  */
    347          /*          be disabled when the flash clock divider is                      */
    348          /*          changed.This cannot be performed while executing                 */
    349          /*          out of flash.There must be a short delay after                   */     //flash时钟分频改变时flash预取须禁止
    350          /*          the clock dividers are changed before prefetch                   */
    351          /*          can be re-enabled.                                               */
    352          /* Input  : None.                                                            */   
    353          /* Output : None.                                                            */
    354          /* Return : None.                                                            */   
    355          /***FUNC-*********************************************************************/

   \                                 In section .textrw, align 4, keep-with-next
    356          __ramfunc static void SetSysDividers(ULONG uiOutDiv1, ULONG uiOutDiv2, ULONG uiOutDiv3, ULONG uiOutDiv4)
    357          {                                    //核心系统时钟分频，外围设备分频，FlexBus时钟分频，闪存时钟分频
   \                     SetSysDividers: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    358          
    359              ULONG uiTemp;
    360            
    361              INT  i;
    362            
    363           
    364              // store present value of FMC_PFAPR
    365              uiTemp = FMC_PFAPR; 
   \   00000002   0x4C10             LDR.N    R4,??SetSysDividers_0  ;; 0x4001f000
   \   00000004   0x6824             LDR      R4,[R4, #+0]
    366            
    367              // set M0PFD through M7PFD to 1 to disable prefetch
    368              FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
    369                        | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
    370                        | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
   \   00000006   0x4D0F             LDR.N    R5,??SetSysDividers_0  ;; 0x4001f000
   \   00000008   0x682D             LDR      R5,[R5, #+0]
   \   0000000A   0xF455 0x057F      ORRS     R5,R5,#0xFF0000
   \   0000000E   0x4E0D             LDR.N    R6,??SetSysDividers_0  ;; 0x4001f000
   \   00000010   0x6035             STR      R5,[R6, #+0]
    371            
    372              // set clock dividers to desired value  
    373              SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(uiOutDiv1) | SIM_CLKDIV1_OUTDIV2(uiOutDiv2) 
    374                          | SIM_CLKDIV1_OUTDIV3(uiOutDiv3) | SIM_CLKDIV1_OUTDIV4(uiOutDiv4);
   \   00000012   0x0609             LSLS     R1,R1,#+24
   \   00000014   0xF011 0x6170      ANDS     R1,R1,#0xF000000
   \   00000018   0xEA51 0x7000      ORRS     R0,R1,R0, LSL #+28
   \   0000001C   0x0511             LSLS     R1,R2,#+20
   \   0000001E   0xF411 0x0170      ANDS     R1,R1,#0xF00000
   \   00000022   0x4308             ORRS     R0,R1,R0
   \   00000024   0x0419             LSLS     R1,R3,#+16
   \   00000026   0xF411 0x2170      ANDS     R1,R1,#0xF0000
   \   0000002A   0x4308             ORRS     R0,R1,R0
   \   0000002C   0x4906             LDR.N    R1,??SetSysDividers_0+0x4  ;; 0x40048044
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    375          
    376              // wait for dividers to change
    377              for (i = 0; i < uiOutDiv4; i++)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE000             B.N      ??SetSysDividers_1
   \                     ??SetSysDividers_2: (+1)
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \                     ??SetSysDividers_1: (+1)
   \   00000036   0x4298             CMP      R0,R3
   \   00000038   0xD3FC             BCC.N    ??SetSysDividers_2
    378              {
    379                  ;   
    380              }
    381           
    382              // re-store original value of FMC_PFAPR
    383              FMC_PFAPR = uiTemp; 
   \   0000003A   0x4802             LDR.N    R0,??SetSysDividers_0  ;; 0x4001f000
   \   0000003C   0x6004             STR      R4,[R0, #+0]
    384            
    385          } 
   \   0000003E   0xBC70             POP      {R4-R6}
   \   00000040   0x4770             BX       LR               ;; return
   \   00000042   0xBF00             Nop      
   \                     ??SetSysDividers_0:
   \   00000044   0x4001F000         DC32     0x4001f000
   \   00000048   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     mcg_div

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x4007C008         DC32     0x4007c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \   00000000   0x40064003         DC32     0x40064003
    386            
    387            
    388            
    389          //#ifdef  __cplusplus
    390          //}
    391          //#endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FLL_Init
         8   -> SetSysDividers
      12   SetSysDividers
       8   pll_init
         8   -> SetSysDividers
         8   -> pll_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
      88  FLL_Init
      76  SetSysDividers
       8  mcg_div
     520  pll_init

 
   8 bytes in section .data
 644 bytes in section .text
  76 bytes in section .textrw
 
 720 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
