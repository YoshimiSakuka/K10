###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        26/May/2016  12:04:39
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\ye\Desktop\NFS.NO 2 - 副本\common\_printf.c
#    Command line =  
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\common\_printf.c" -D DEBUG -lCN
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\List\" -lB
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\List\" -o
#        "C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -Ol --use_c++_inline
#    List file    =  C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\List\_printf.lst
#    Object file  =  C:\Users\ye\Desktop\NFS.NO 2 - 副本\Debug\Obj\_printf.o
#
###############################################################################

C:\Users\ye\Desktop\NFS.NO 2 - 副本\common\_printf.c
      1          //*******************************************************************************************
      2          //  MK60DN512ZVL(K/L/Q)10 Demo - _printf, Ultra-Low Pwr UART 115200 Echo ISR, 50MHz ACLK
      3          //
      4          //           MK60DN512ZVL(K/L/Q)10
      5          //            -----------------
      6          //        /|\|              XIN|-
      7          //         | |                 | 50MHz
      8          //         --|RST          XOUT|-
      9          //           |                 |
     10          //           |                 |
     11          //           |           PTC14 |---->TXD 
     12          //           |           PTC15 |<----RXD
     13          //           |                 |
     14          //           |                 |
     15          //           |                 |
     16          //           |                 | 
     17          //           |                 |
     18          //           |                 |
     19          //           |                 |
     20          //           |                 |
     21          //
     22          //  Copyright (c) 2012.04  WH, All Rights Reserved.
     23          //  WebSite     : http://un-el.taobao.com/
     24          //  QQ群        : 226846867 (Kinetis ARM)
     25          //  Email       : dragonhzw@163.com
     26          //  Description : The _printf module
     27          //  History     :                                                           
     28          //     [Author]   [Date]      [Version]    [Description]                     
     29          //     [1] dragonhzw   2012/04/09  Ver 1.0.0    Initial file.
     30          //
     31          //  Built with IAR Embedded Workbench for ARM 6.30  
     32          //***********************************************************************************************
     33          //#include "..\K60_datatype.h"
     34          
     35          #include "_printf.h"
     36          //#ifdef  __cplusplus
     37          //extern "C" {
     38          //#endif
     39          
     40            
     41          /***FUNC+*********************************************************************/
     42          /* Name   : Init_UART1                                                       */
     43          /* Descrp : init Uart1 port.                                                 */
     44          /* Input  : None.                                                            */   
     45          /* Output : None.                                                            */
     46          /* Return : None.                                                            */   
     47          /***FUNC-*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     48          void UART_Init(U32 SystemClock, U32 BaudRate, U8 UARTChannel)
     49          {
   \                     UART_Init: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
     50            register U16 ubd, brfa;
     51            
     52            UART_MemMapPtr Channel;
     53            
     54            U8 temp;
     55              
     56            switch (UARTChannel)
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD008             BEQ.N    ??UART_Init_0
   \   00000008   0x2A02             CMP      R2,#+2
   \   0000000A   0xD02D             BEQ.N    ??UART_Init_1
   \   0000000C   0xD31A             BCC.N    ??UART_Init_2
   \   0000000E   0x2A04             CMP      R2,#+4
   \   00000010   0xD04A             BEQ.N    ??UART_Init_3
   \   00000012   0xD339             BCC.N    ??UART_Init_4
   \   00000014   0x2A05             CMP      R2,#+5
   \   00000016   0xD057             BEQ.N    ??UART_Init_5
   \   00000018   0xE066             B.N      ??UART_Init_6
     57            {
     58              case UART0:
     59                  /* Enable the UART0_TXD function on PTD6 */
     60                  PORTD_PCR6 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
   \                     ??UART_Init_0: (+1)
   \   0000001A   0xF44F 0x7340      MOV      R3,#+768
   \   0000001E   0x.... 0x....      LDR.W    R4,??DataTable5  ;; 0x4004c018
   \   00000022   0x6023             STR      R3,[R4, #+0]
     61                  /* Enable the UART0_RXD function on PTD7 */
     62                  PORTD_PCR7 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
   \   00000024   0xF44F 0x7340      MOV      R3,#+768
   \   00000028   0x.... 0x....      LDR.W    R4,??DataTable5_1  ;; 0x4004c01c
   \   0000002C   0x6023             STR      R3,[R4, #+0]
     63          
     64                  SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable5_2  ;; 0x40048034
   \   00000032   0x681B             LDR      R3,[R3, #+0]
   \   00000034   0xF453 0x6380      ORRS     R3,R3,#0x400
   \   00000038   0x.... 0x....      LDR.W    R4,??DataTable5_2  ;; 0x40048034
   \   0000003C   0x6023             STR      R3,[R4, #+0]
     65                  Channel = UART_0;
   \   0000003E   0x.... 0x....      LDR.W    R3,??DataTable5_3  ;; 0x4006a000
     66                break;
   \   00000042   0xE051             B.N      ??UART_Init_7
     67                
     68              case UART1:
     69                  /* Enable the UART1_TXD function on PTC4 */
     70                  PORTC_PCR4 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
   \                     ??UART_Init_2: (+1)
   \   00000044   0xF44F 0x7340      MOV      R3,#+768
   \   00000048   0x.... 0x....      LDR.W    R4,??DataTable5_4  ;; 0x4004b010
   \   0000004C   0x6023             STR      R3,[R4, #+0]
     71                  /* Enable the UART1_RXD function on PTC3 */
     72                  PORTC_PCR3 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
   \   0000004E   0xF44F 0x7340      MOV      R3,#+768
   \   00000052   0x.... 0x....      LDR.W    R4,??DataTable5_5  ;; 0x4004b00c
   \   00000056   0x6023             STR      R3,[R4, #+0]
     73          
     74                  SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
   \   00000058   0x....             LDR.N    R3,??DataTable5_2  ;; 0x40048034
   \   0000005A   0x681B             LDR      R3,[R3, #+0]
   \   0000005C   0xF453 0x6300      ORRS     R3,R3,#0x800
   \   00000060   0x....             LDR.N    R4,??DataTable5_2  ;; 0x40048034
   \   00000062   0x6023             STR      R3,[R4, #+0]
     75                  Channel = UART_1;
   \   00000064   0x....             LDR.N    R3,??DataTable5_6  ;; 0x4006b000
     76                break;
   \   00000066   0xE03F             B.N      ??UART_Init_7
     77                
     78              case UART2:
     79                  /* Enable the UART2_TXD function on PTD3 */
     80                  PORTD_PCR3 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
   \                     ??UART_Init_1: (+1)
   \   00000068   0xF44F 0x7340      MOV      R3,#+768
   \   0000006C   0x....             LDR.N    R4,??DataTable5_7  ;; 0x4004c00c
   \   0000006E   0x6023             STR      R3,[R4, #+0]
     81                  /* Enable the UART2_RXD function on PTD2 */
     82                  PORTD_PCR2 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
   \   00000070   0xF44F 0x7340      MOV      R3,#+768
   \   00000074   0x....             LDR.N    R4,??DataTable5_8  ;; 0x4004c008
   \   00000076   0x6023             STR      R3,[R4, #+0]
     83          
     84                  SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;      
   \   00000078   0x....             LDR.N    R3,??DataTable5_2  ;; 0x40048034
   \   0000007A   0x681B             LDR      R3,[R3, #+0]
   \   0000007C   0xF453 0x5380      ORRS     R3,R3,#0x1000
   \   00000080   0x....             LDR.N    R4,??DataTable5_2  ;; 0x40048034
   \   00000082   0x6023             STR      R3,[R4, #+0]
     85                  Channel = UART_2;
   \   00000084   0x....             LDR.N    R3,??DataTable5_9  ;; 0x4006c000
     86                break;
   \   00000086   0xE02F             B.N      ??UART_Init_7
     87                
     88              case UART3:    
     89                  /* Enable the UART3_TXD function on PTC17 */
     90                  PORTC_PCR17 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
   \                     ??UART_Init_4: (+1)
   \   00000088   0xF44F 0x7340      MOV      R3,#+768
   \   0000008C   0x....             LDR.N    R4,??DataTable5_10  ;; 0x4004b044
   \   0000008E   0x6023             STR      R3,[R4, #+0]
     91                  /* Enable the UART3_RXD function on PTC16 */
     92                  PORTC_PCR16 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
   \   00000090   0xF44F 0x7340      MOV      R3,#+768
   \   00000094   0x....             LDR.N    R4,??DataTable5_11  ;; 0x4004b040
   \   00000096   0x6023             STR      R3,[R4, #+0]
     93          
     94                  SIM_SCGC4 |= SIM_SCGC4_UART3_MASK;
   \   00000098   0x....             LDR.N    R3,??DataTable5_2  ;; 0x40048034
   \   0000009A   0x681B             LDR      R3,[R3, #+0]
   \   0000009C   0xF453 0x5300      ORRS     R3,R3,#0x2000
   \   000000A0   0x....             LDR.N    R4,??DataTable5_2  ;; 0x40048034
   \   000000A2   0x6023             STR      R3,[R4, #+0]
     95                  
     96                  Channel = UART_3;
   \   000000A4   0x....             LDR.N    R3,??DataTable5_12  ;; 0x4006d000
     97                break;
   \   000000A6   0xE01F             B.N      ??UART_Init_7
     98                
     99              case UART4:
    100                  /* Enable the UART3_TXD function on PTC17 */
    101                  //PORTC_PCR15 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
    102                  PORTE_PCR24 = PORT_PCR_MUX(0x3);    //tx
   \                     ??UART_Init_3: (+1)
   \   000000A8   0xF44F 0x7340      MOV      R3,#+768
   \   000000AC   0x....             LDR.N    R4,??DataTable5_13  ;; 0x4004d060
   \   000000AE   0x6023             STR      R3,[R4, #+0]
    103                  /* Enable the UART3_RXD function on PTC16 */
    104                  //PORTC_PCR14 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
    105                  PORTE_PCR25 = PORT_PCR_MUX(0x3);    //rx
   \   000000B0   0xF44F 0x7340      MOV      R3,#+768
   \   000000B4   0x....             LDR.N    R4,??DataTable5_14  ;; 0x4004d064
   \   000000B6   0x6023             STR      R3,[R4, #+0]
    106                  SIM_SCGC1 |= SIM_SCGC1_UART4_MASK;      
   \   000000B8   0x....             LDR.N    R3,??DataTable5_15  ;; 0x40048028
   \   000000BA   0x681B             LDR      R3,[R3, #+0]
   \   000000BC   0xF453 0x6380      ORRS     R3,R3,#0x400
   \   000000C0   0x....             LDR.N    R4,??DataTable5_15  ;; 0x40048028
   \   000000C2   0x6023             STR      R3,[R4, #+0]
    107                  Channel = UART_4;
   \   000000C4   0x....             LDR.N    R3,??DataTable5_16  ;; 0x400ea000
    108                break;
   \   000000C6   0xE00F             B.N      ??UART_Init_7
    109                
    110              case UART5:
    111                  /* Enable the UART3_TXD function on PTC17 */
    112                  PORTE_PCR8 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
   \                     ??UART_Init_5: (+1)
   \   000000C8   0xF44F 0x7340      MOV      R3,#+768
   \   000000CC   0x....             LDR.N    R4,??DataTable5_17  ;; 0x4004d020
   \   000000CE   0x6023             STR      R3,[R4, #+0]
    113                  /* Enable the UART3_RXD function on PTC16 */
    114                  PORTE_PCR9 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
   \   000000D0   0xF44F 0x7340      MOV      R3,#+768
   \   000000D4   0x....             LDR.N    R4,??DataTable5_18  ;; 0x4004d024
   \   000000D6   0x6023             STR      R3,[R4, #+0]
    115          
    116                  SIM_SCGC1 |= SIM_SCGC1_UART5_MASK;      
   \   000000D8   0x....             LDR.N    R3,??DataTable5_15  ;; 0x40048028
   \   000000DA   0x681B             LDR      R3,[R3, #+0]
   \   000000DC   0xF453 0x6300      ORRS     R3,R3,#0x800
   \   000000E0   0x....             LDR.N    R4,??DataTable5_15  ;; 0x40048028
   \   000000E2   0x6023             STR      R3,[R4, #+0]
    117          
    118                  Channel = UART_5;
   \   000000E4   0x....             LDR.N    R3,??DataTable5_19  ;; 0x400eb000
    119                break;
   \   000000E6   0xE7FF             B.N      ??UART_Init_7
    120                
    121              default: 
    122                break;
    123            }  
    124          
    125            /* Make sure that the transmitter and receiver are disabled while we
    126            * change settings.
    127            */
    128            UART_C2_REG(Channel) &= ~(UART_C2_TE_MASK | UART_C2_RE_MASK );        //禁止发送接收
   \                     ??UART_Init_6: (+1)
   \                     ??UART_Init_7: (+1)
   \   000000E8   0x78DC             LDRB     R4,[R3, #+3]
   \   000000EA   0xF014 0x04F3      ANDS     R4,R4,#0xF3
   \   000000EE   0x70DC             STRB     R4,[R3, #+3]
    129          
    130            /* Configure the UART for 8-bit mode, no parity */
    131            /* We need all default settings, so entire register is cleared */
    132            UART_C1_REG(Channel) = 0;
   \   000000F0   0x2400             MOVS     R4,#+0
   \   000000F2   0x709C             STRB     R4,[R3, #+2]
    133            if((UART0 == UARTChannel) ||(UART1 == UARTChannel))        //串口01 使用内核时钟 是其他外设时钟的2倍
   \   000000F4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F6   0x2A00             CMP      R2,#+0
   \   000000F8   0xD002             BEQ.N    ??UART_Init_8
   \   000000FA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000FC   0x2A01             CMP      R2,#+1
   \   000000FE   0xD100             BNE.N    ??UART_Init_9
    134            {
    135              SystemClock +=SystemClock;
   \                     ??UART_Init_8: (+1)
   \   00000100   0x1800             ADDS     R0,R0,R0
    136            }
    137            /* Calculate baud settings */
    138            ubd = (U32)((SystemClock)/(BaudRate * 16));   // SBR+BRFA BRFA滤掉
   \                     ??UART_Init_9: (+1)
   \   00000102   0x010A             LSLS     R2,R1,#+4
   \   00000104   0xFBB0 0xF2F2      UDIV     R2,R0,R2
    139          
    140            /* Save off the current value of the UARTx_BDH except for the SBR */
    141            temp = UART_BDH_REG(Channel) & ~(UART_BDH_SBR(0x1F));      //保存其他位的值
   \   00000108   0x781C             LDRB     R4,[R3, #+0]
   \   0000010A   0xF014 0x04E0      ANDS     R4,R4,#0xE0
    142            UART_BDH_REG(Channel) = temp | UART_BDH_SBR(((ubd & 0x1F00) >> 8));   //设置BDH
   \   0000010E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000110   0x0A15             LSRS     R5,R2,#+8
   \   00000112   0xF015 0x051F      ANDS     R5,R5,#0x1F
   \   00000116   0x432C             ORRS     R4,R5,R4
   \   00000118   0x701C             STRB     R4,[R3, #+0]
    143            UART_BDL_REG(Channel) = (U8)(ubd & UART_BDL_SBR_MASK);    //设置BDL
   \   0000011A   0x705A             STRB     R2,[R3, #+1]
    144          
    145            /* Determine if a fractional divider is needed to get closer to the baud rate */
    146            brfa = (((SystemClock*32)/(BaudRate * 16)) - (ubd * 32)); //计算BRFA  精度1/32
   \   0000011C   0x0140             LSLS     R0,R0,#+5
   \   0000011E   0x0109             LSLS     R1,R1,#+4
   \   00000120   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000124   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000126   0xEBB0 0x1042      SUBS     R0,R0,R2, LSL #+5
    147          
    148            /* Save off the current value of the UARTx_C4 register except for the BRFA */
    149            temp = UART_C4_REG(Channel) & ~(UART_C4_BRFA(0x1F));  //保存高3位
   \   0000012A   0x7A99             LDRB     R1,[R3, #+10]
   \   0000012C   0xF011 0x04E0      ANDS     R4,R1,#0xE0
    150            UART_C4_REG(Channel) = temp | UART_C4_BRFA(brfa); //设置BRFA
   \   00000130   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000134   0x4320             ORRS     R0,R0,R4
   \   00000136   0x7298             STRB     R0,[R3, #+10]
    151            
    152            /* Enable receiver and transmitter */
    153            UART_C2_REG(Channel) |= (UART_C2_TE_MASK | UART_C2_RE_MASK);   //使能发送接收
   \   00000138   0x78D8             LDRB     R0,[R3, #+3]
   \   0000013A   0xF050 0x000C      ORRS     R0,R0,#0xC
   \   0000013E   0x70D8             STRB     R0,[R3, #+3]
    154          
    155            return;
   \   00000140   0xBC30             POP      {R4,R5}
   \   00000142   0x4770             BX       LR               ;; return
    156          }
    157          /***FUNC+*********************************************************************/
    158          /* Name   : Uart_Printf                                                      */
    159          /* Descrp : 处理来自串口的发送中断                                           */
    160          /* Input  : None.                                                            */   
    161          /* Output : None.                                                            */
    162          /* Return : None.                                                            */   
    163          /***FUNC-*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    164          void Uart_Printf(const char *fmt,...)
    165          {
   \                     Uart_Printf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB500             PUSH     {LR}
   \   00000004   0xB0C0             SUB      SP,SP,#+256
    166              va_list ap;
    167              char string[256];
    168          
    169              va_start(ap,fmt);
   \   00000006   0xAA41             ADD      R2,SP,#+260
    170              vsprintf(string,fmt,ap);
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x.... 0x....      BL       vsprintf
    171              Uart_SendString(string);
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       Uart_SendString
    172              va_end(ap);
    173              return;
   \   00000016   0xB040             ADD      SP,SP,#+256
   \   00000018   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    174          }
    175          /***FUNC+*********************************************************************/
    176          /* Name   : Uart_SendString                                                  */
    177          /* Descrp : 发送字符串                                                       */
    178          /* Input  : None.                                                            */   
    179          /* Output : None.                                                            */
    180          /* Return : None.                                                            */   
    181          /***FUNC-*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    182          void Uart_SendString(char *pt)
    183          {
   \                     Uart_SendString: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xE004             B.N      ??Uart_SendString_0
    184              while(*pt)
    185              {
    186                  Uart_SendByte(UART4,*pt++);
   \                     ??Uart_SendString_1: (+1)
   \   00000006   0x7821             LDRB     R1,[R4, #+0]
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x.... 0x....      BL       Uart_SendByte
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
    187              }
   \                     ??Uart_SendString_0: (+1)
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD1F7             BNE.N    ??Uart_SendString_1
    188              return;
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    189          }
    190          /***FUNC+*********************************************************************/
    191          /* Name   : Uart_SendByte                                                    */
    192          /* Descrp : 发送数据到串口的发送中断                                         */
    193          /* Input  : None.                                                            */   
    194          /* Output : None.                                                            */
    195          /* Return : None.                                                            */   
    196          /***FUNC-*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    197          void Uart_SendByte(U8 UARTChannel, U8 Char)
    198          {
    199              UART_MemMapPtr Channel;
    200            
    201              switch (UARTChannel)
   \                     Uart_SendByte: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD008             BEQ.N    ??Uart_SendByte_0
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD00A             BEQ.N    ??Uart_SendByte_1
   \   0000000A   0xD307             BCC.N    ??Uart_SendByte_2
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??Uart_SendByte_3
   \   00000010   0xD308             BCC.N    ??Uart_SendByte_4
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD00A             BEQ.N    ??Uart_SendByte_5
   \   00000016   0xE00B             B.N      ??Uart_SendByte_6
    202              {
    203                  case UART0:
    204                      Channel = UART_0;
   \                     ??Uart_SendByte_0: (+1)
   \   00000018   0x....             LDR.N    R2,??DataTable5_3  ;; 0x4006a000
    205                      break;
   \   0000001A   0xE009             B.N      ??Uart_SendByte_7
    206                  case UART1:
    207                      Channel = UART_1;
   \                     ??Uart_SendByte_2: (+1)
   \   0000001C   0x....             LDR.N    R2,??DataTable5_6  ;; 0x4006b000
    208                      break;
   \   0000001E   0xE007             B.N      ??Uart_SendByte_7
    209                  case UART2:
    210                      Channel = UART_2;
   \                     ??Uart_SendByte_1: (+1)
   \   00000020   0x....             LDR.N    R2,??DataTable5_9  ;; 0x4006c000
    211                      break;
   \   00000022   0xE005             B.N      ??Uart_SendByte_7
    212                  case UART3:
    213                      Channel = UART_3;
   \                     ??Uart_SendByte_4: (+1)
   \   00000024   0x....             LDR.N    R2,??DataTable5_12  ;; 0x4006d000
    214                      break;
   \   00000026   0xE003             B.N      ??Uart_SendByte_7
    215                  case UART4:
    216                      Channel = UART_4;
   \                     ??Uart_SendByte_3: (+1)
   \   00000028   0x....             LDR.N    R2,??DataTable5_16  ;; 0x400ea000
    217                      break;
   \   0000002A   0xE001             B.N      ??Uart_SendByte_7
    218                  case UART5:
    219                      Channel = UART_5;
   \                     ??Uart_SendByte_5: (+1)
   \   0000002C   0x....             LDR.N    R2,??DataTable5_19  ;; 0x400eb000
    220                      break;
   \   0000002E   0xE7FF             B.N      ??Uart_SendByte_7
    221                  default: 
    222                      break;
    223              }  
    224              
    225              /* Wait until space is available in the FIFO */
    226              while(!(UART_S1_REG(Channel) & UART_S1_TDRE_MASK))
   \                     ??Uart_SendByte_6: (+1)
   \                     ??Uart_SendByte_7: (+1)
   \   00000030   0x7910             LDRB     R0,[R2, #+4]
   \   00000032   0x0600             LSLS     R0,R0,#+24
   \   00000034   0xD5FC             BPL.N    ??Uart_SendByte_7
    227              {
    228          
    229              }
    230              /* Send the character */
    231              UART_D_REG(Channel) = (S8)Char;
   \   00000036   0x71D1             STRB     R1,[R2, #+7]
    232          
    233              return;
   \   00000038   0x4770             BX       LR               ;; return
    234          }

   \                                 In section .text, align 2, keep-with-next
    235          void Uart_SendByte_4(unsigned char data)     //最简程序
    236          {
    237              while(!(UART_S1_REG(UART4_BASE_PTR) & UART_S1_TDRE_MASK))
   \                     Uart_SendByte_4: (+1)
   \                     ??Uart_SendByte_4_0: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5_20  ;; 0x400ea004
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x0609             LSLS     R1,R1,#+24
   \   00000006   0xD5FB             BPL.N    ??Uart_SendByte_4_0
    238              {
    239          
    240              }
    241              /* Send the character */
    242              UART_D_REG(UART4_BASE_PTR) = (S8)data;
   \   00000008   0x....             LDR.N    R1,??DataTable5_21  ;; 0x400ea007
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    243          }
   \   0000000C   0x4770             BX       LR               ;; return
    244          /***FUNC+*********************************************************************/
    245          /* Name   : Uart_GetString                                                   */
    246          /* Descrp : 获取字符串                                                       */
    247          /* Input  : None.                                                            */   
    248          /* Output : None.                                                            */
    249          /* Return : None.                                                            */   
    250          /***FUNC-*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    251          void Uart_GetString(char *string)
    252          {
   \                     Uart_GetString: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    253              char *string2 = string;
   \   00000004   0x0025             MOVS     R5,R4
   \   00000006   0xE001             B.N      ??Uart_GetString_0
    254              char c;
    255              while((c = Uart_Getch(UART4))!='\r')
    256              {
    257                  if(c=='\b')
    258                  {
    259                      if( (int)string2 < (int)string )
    260                      {
    261                          //Uart_Printf("\b \b");
    262                          string--;
    263                      }
    264                  }
    265                  else 
    266                  {
    267                      *string++ = c;
   \                     ??Uart_GetString_1: (+1)
   \   00000008   0x7020             STRB     R0,[R4, #+0]
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
    268                      //Uart_SendByte(UART4,c);
    269                  }
   \                     ??Uart_GetString_0: (+1)
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0x.... 0x....      BL       Uart_Getch
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x290D             CMP      R1,#+13
   \   00000018   0xD006             BEQ.N    ??Uart_GetString_2
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x2808             CMP      R0,#+8
   \   0000001E   0xD1F3             BNE.N    ??Uart_GetString_1
   \   00000020   0x42A5             CMP      R5,R4
   \   00000022   0xDAF3             BGE.N    ??Uart_GetString_0
   \   00000024   0x1E64             SUBS     R4,R4,#+1
   \   00000026   0xE7F1             B.N      ??Uart_GetString_0
    270              }
    271              *string='\0';
   \                     ??Uart_GetString_2: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7020             STRB     R0,[R4, #+0]
    272              //Uart_SendByte(UART4,'\n');
    273              return;
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    274          }
    275          /***FUNC+*********************************************************************/
    276          /* Name   : Uart_GetIntNum                                                   */
    277          /* Descrp : 获取数据                                                         */
    278          /* Input  : None.                                                            */   
    279          /* Output : None.                                                            */
    280          /* Return : None.                                                            */   
    281          /***FUNC-*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    282          SHORT Uart_GetIntNum(void)
    283          {
   \                     Uart_GetIntNum: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
    284              char str[30];
    285              char *string = str;
   \   00000006   0xAE00             ADD      R6,SP,#+0
    286              unsigned short base     = 10;
   \   00000008   0x270A             MOVS     R7,#+10
    287              unsigned short minus    = 0;
   \   0000000A   0x2500             MOVS     R5,#+0
    288              short result   = 0;
   \   0000000C   0x2400             MOVS     R4,#+0
    289              short lastIndex;    
    290              unsigned short i;
    291              
    292              Uart_GetString(string);
   \   0000000E   0x0030             MOVS     R0,R6
   \   00000010   0x.... 0x....      BL       Uart_GetString
    293              
    294              if(string[0]=='-')
   \   00000014   0x7830             LDRB     R0,[R6, #+0]
   \   00000016   0x282D             CMP      R0,#+45
   \   00000018   0xD101             BNE.N    ??Uart_GetIntNum_0
    295              {
    296                  minus = 1;
   \   0000001A   0x2501             MOVS     R5,#+1
    297                  string++;
   \   0000001C   0x1C76             ADDS     R6,R6,#+1
    298              }
    299              
    300              if(string[0]=='0' && (string[1]=='x' || string[1]=='X'))
   \                     ??Uart_GetIntNum_0: (+1)
   \   0000001E   0x7830             LDRB     R0,[R6, #+0]
   \   00000020   0x2830             CMP      R0,#+48
   \   00000022   0xD107             BNE.N    ??Uart_GetIntNum_1
   \   00000024   0x7870             LDRB     R0,[R6, #+1]
   \   00000026   0x2878             CMP      R0,#+120
   \   00000028   0xD002             BEQ.N    ??Uart_GetIntNum_2
   \   0000002A   0x7870             LDRB     R0,[R6, #+1]
   \   0000002C   0x2858             CMP      R0,#+88
   \   0000002E   0xD101             BNE.N    ??Uart_GetIntNum_1
    301              {
    302                  base    = 16;
   \                     ??Uart_GetIntNum_2: (+1)
   \   00000030   0x2710             MOVS     R7,#+16
    303                  string += 2;
   \   00000032   0x1CB6             ADDS     R6,R6,#+2
    304              }
    305              
    306              lastIndex = strlen(string) - 1;
   \                     ??Uart_GetIntNum_1: (+1)
   \   00000034   0x0030             MOVS     R0,R6
   \   00000036   0x.... 0x....      BL       strlen
   \   0000003A   0xF1B0 0x0801      SUBS     R8,R0,#+1
    307              
    308              if(lastIndex<0)
   \   0000003E   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   00000042   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000046   0xD502             BPL.N    ??Uart_GetIntNum_3
    309                  return -1;
   \   00000048   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004C   0xE055             B.N      ??Uart_GetIntNum_4
    310              
    311              if(string[lastIndex]=='h' || string[lastIndex]=='H' )
   \                     ??Uart_GetIntNum_3: (+1)
   \   0000004E   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   00000052   0xF818 0x0006      LDRB     R0,[R8, R6]
   \   00000056   0x2868             CMP      R0,#+104
   \   00000058   0xD005             BEQ.N    ??Uart_GetIntNum_5
   \   0000005A   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   0000005E   0xF818 0x0006      LDRB     R0,[R8, R6]
   \   00000062   0x2848             CMP      R0,#+72
   \   00000064   0xD107             BNE.N    ??Uart_GetIntNum_6
    312              {
    313                  base = 16;
   \                     ??Uart_GetIntNum_5: (+1)
   \   00000066   0x2710             MOVS     R7,#+16
    314                  string[lastIndex] = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   0000006E   0xF808 0x0006      STRB     R0,[R8, R6]
    315                  lastIndex--;
   \   00000072   0xF1B8 0x0801      SUBS     R8,R8,#+1
    316              }
    317          
    318              if(base==10)
   \                     ??Uart_GetIntNum_6: (+1)
   \   00000076   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000078   0x2F0A             CMP      R7,#+10
   \   0000007A   0xD10C             BNE.N    ??Uart_GetIntNum_7
    319              {
    320                  result = atoi(string);
   \   0000007C   0x0030             MOVS     R0,R6
   \   0000007E   0x.... 0x....      BL       atoi
   \   00000082   0x0004             MOVS     R4,R0
    321                  result = minus ? (-1*result):result;
   \   00000084   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000086   0x2D00             CMP      R5,#+0
   \   00000088   0xD004             BEQ.N    ??Uart_GetIntNum_8
   \   0000008A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000008E   0xFB14 0xF400      SMULBB   R4,R4,R0
   \   00000092   0xE030             B.N      ??Uart_GetIntNum_9
   \                     ??Uart_GetIntNum_8: (+1)
   \   00000094   0xE02F             B.N      ??Uart_GetIntNum_9
    322              }
    323              else
    324              {
    325                  for(i=0;i<=lastIndex;i++)
   \                     ??Uart_GetIntNum_7: (+1)
   \   00000096   0x2700             MOVS     R7,#+0
   \   00000098   0xE006             B.N      ??Uart_GetIntNum_10
    326                  {
    327                      if(isalpha(string[i]))
    328                      {
    329                          if(isupper(string[i]))
    330                              result = (result<<4) + string[i] - 'A' + 10;
    331                          else
    332                              result = (result<<4) + string[i] - 'a' + 10;
    333                      }
    334                      else
    335                          result = (result<<4) + string[i] - '0';
   \                     ??Uart_GetIntNum_11: (+1)
   \   0000009A   0x0120             LSLS     R0,R4,#+4
   \   0000009C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000009E   0x5DB9             LDRB     R1,[R7, R6]
   \   000000A0   0x1840             ADDS     R0,R0,R1
   \   000000A2   0xF1B0 0x0430      SUBS     R4,R0,#+48
   \                     ??Uart_GetIntNum_12: (+1)
   \   000000A6   0x1C7F             ADDS     R7,R7,#+1
   \                     ??Uart_GetIntNum_10: (+1)
   \   000000A8   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   000000AC   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000AE   0x45B8             CMP      R8,R7
   \   000000B0   0xDB19             BLT.N    ??Uart_GetIntNum_13
   \   000000B2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000B4   0x5DB8             LDRB     R0,[R7, R6]
   \   000000B6   0x.... 0x....      BL       isalpha
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD0ED             BEQ.N    ??Uart_GetIntNum_11
   \   000000BE   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000C0   0x5DB8             LDRB     R0,[R7, R6]
   \   000000C2   0x.... 0x....      BL       isupper
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD006             BEQ.N    ??Uart_GetIntNum_14
   \   000000CA   0x0120             LSLS     R0,R4,#+4
   \   000000CC   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000CE   0x5DB9             LDRB     R1,[R7, R6]
   \   000000D0   0x1840             ADDS     R0,R0,R1
   \   000000D2   0xF1B0 0x0437      SUBS     R4,R0,#+55
   \   000000D6   0xE7E6             B.N      ??Uart_GetIntNum_12
   \                     ??Uart_GetIntNum_14: (+1)
   \   000000D8   0x0120             LSLS     R0,R4,#+4
   \   000000DA   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000DC   0x5DB9             LDRB     R1,[R7, R6]
   \   000000DE   0x1840             ADDS     R0,R0,R1
   \   000000E0   0xF1B0 0x0457      SUBS     R4,R0,#+87
   \   000000E4   0xE7DF             B.N      ??Uart_GetIntNum_12
    336                  }
    337                  result = minus ? (-1*result):result;
   \                     ??Uart_GetIntNum_13: (+1)
   \   000000E6   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000E8   0x2D00             CMP      R5,#+0
   \   000000EA   0xD004             BEQ.N    ??Uart_GetIntNum_15
   \   000000EC   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000F0   0xFB14 0xF400      SMULBB   R4,R4,R0
   \   000000F4   0xE7FF             B.N      ??Uart_GetIntNum_9
    338              }
    339              return result;
   \                     ??Uart_GetIntNum_15: (+1)
   \                     ??Uart_GetIntNum_9: (+1)
   \   000000F6   0x0020             MOVS     R0,R4
   \   000000F8   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??Uart_GetIntNum_4: (+1)
   \   000000FA   0xB008             ADD      SP,SP,#+32
   \   000000FC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    340          }
    341          /***FUNC+*********************************************************************/
    342          /* Name   : Uart_Getch                                                       */
    343          /* Descrp : 接收串口数据                                                     */
    344          /* Input  : None.                                                            */   
    345          /* Output : None.                                                            */
    346          /* Return : None.                                                            */   
    347          /***FUNC-*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    348          CHAR Uart_Getch(U8 UARTChannel)
    349          {
    350              UART_MemMapPtr Channel;
    351            
    352              switch (UARTChannel)
   \                     Uart_Getch: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD008             BEQ.N    ??Uart_Getch_0
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD00A             BEQ.N    ??Uart_Getch_1
   \   0000000A   0xD307             BCC.N    ??Uart_Getch_2
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD00B             BEQ.N    ??Uart_Getch_3
   \   00000010   0xD308             BCC.N    ??Uart_Getch_4
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD00A             BEQ.N    ??Uart_Getch_5
   \   00000016   0xE00B             B.N      ??Uart_Getch_6
    353              {
    354                  case UART0:
    355                      Channel = UART_0;
   \                     ??Uart_Getch_0: (+1)
   \   00000018   0x....             LDR.N    R1,??DataTable5_3  ;; 0x4006a000
    356                      break;
   \   0000001A   0xE009             B.N      ??Uart_Getch_7
    357                  case UART1:
    358                      Channel = UART_1;
   \                     ??Uart_Getch_2: (+1)
   \   0000001C   0x....             LDR.N    R1,??DataTable5_6  ;; 0x4006b000
    359                      break;
   \   0000001E   0xE007             B.N      ??Uart_Getch_7
    360                  case UART2:
    361                      Channel = UART_2;
   \                     ??Uart_Getch_1: (+1)
   \   00000020   0x....             LDR.N    R1,??DataTable5_9  ;; 0x4006c000
    362                      break;
   \   00000022   0xE005             B.N      ??Uart_Getch_7
    363                  case UART3:
    364                      Channel = UART_3;
   \                     ??Uart_Getch_4: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable5_12  ;; 0x4006d000
    365                      break;
   \   00000026   0xE003             B.N      ??Uart_Getch_7
    366                  case UART4:
    367                      Channel = UART_4;
   \                     ??Uart_Getch_3: (+1)
   \   00000028   0x....             LDR.N    R1,??DataTable5_16  ;; 0x400ea000
    368                      break;
   \   0000002A   0xE001             B.N      ??Uart_Getch_7
    369                  case UART5:
    370                      Channel = UART_5;
   \                     ??Uart_Getch_5: (+1)
   \   0000002C   0x....             LDR.N    R1,??DataTable5_19  ;; 0x400eb000
    371                      break;
   \   0000002E   0xE7FF             B.N      ??Uart_Getch_7
    372                  default: 
    373                      break;
    374              }  
    375              /* Wait until character has been received */
    376              while (!(UART_S1_REG(Channel) & UART_S1_RDRF_MASK));
   \                     ??Uart_Getch_6: (+1)
   \                     ??Uart_Getch_7: (+1)
   \   00000030   0x7908             LDRB     R0,[R1, #+4]
   \   00000032   0x0680             LSLS     R0,R0,#+26
   \   00000034   0xD5FC             BPL.N    ??Uart_Getch_7
    377              /* Return the 8-bit data from the receiver */
    378              return UART_D_REG(Channel);
   \   00000036   0x79C8             LDRB     R0,[R1, #+7]
   \   00000038   0x4770             BX       LR               ;; return
    379          }
    380          /***FUNC+*********************************************************************/
    381          /* Name   : Delay                                                            */
    382          /* Descrp : 延时                                                             */
    383          /* Input  : None.                                                            */   
    384          /* Output : None.                                                            */
    385          /* Return : None.                                                            */   
    386          /***FUNC-*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    387          void Delay(SHORT sTime)
    388          {
   \                     Delay: (+1)
   \   00000000   0xE000             B.N      ??Delay_0
    389              for(;sTime>0;sTime--)
   \                     ??Delay_1: (+1)
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \                     ??Delay_0: (+1)
   \   00000004   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xDAFB             BGE.N    ??Delay_1
    390              {
    391              }
    392              return; 
   \   0000000A   0x4770             BX       LR               ;; return
    393          }
    394          
    395          
    396          /*************************************************************************
    397          *                             野火嵌入式开发工作室
    398          *
    399          *  函数名称：uart_irq_EN
    400          *  功能说明：开串口接收中断
    401          *  参数说明：UARTn       模块号（UART0~UART5）
    402          *  函数返回：无
    403          *  修改时间：2012-1-20
    404          *  备    注：
    405          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    406          void uart_irq_EN(void)
    407          {
   \                     uart_irq_EN: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    408              UART_C2_REG(UART_4) |= UART_C2_RIE_MASK;    //开放UART接收中断
   \   00000002   0x....             LDR.N    R0,??DataTable5_22  ;; 0x400ea003
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000000A   0x....             LDR.N    R1,??DataTable5_22  ;; 0x400ea003
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    409              enable_irq(53);			        //开接收引脚的IRQ中断
   \   0000000E   0x2035             MOVS     R0,#+53
   \   00000010   0x.... 0x....      BL       enable_irq
    410          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    411          
    412          
    413          /*************************************************************************
    414          *                             野火嵌入式开发工作室
    415          *
    416          *  函数名称：uart_irq_DIS
    417          *  功能说明：关串口接收中断
    418          *  参数说明：UARTn       模块号（UART0~UART5）
    419          *  函数返回：无
    420          *  修改时间：2012-1-20
    421          *  备    注：
    422          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    423          void uart_irq_DIS(void)
    424          {
   \                     uart_irq_DIS: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    425              UART_C2_REG(UART_4) &= ~UART_C2_RIE_MASK;   //禁止UART接收中断
   \   00000002   0x....             LDR.N    R0,??DataTable5_22  ;; 0x400ea003
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   0000000A   0x....             LDR.N    R1,??DataTable5_22  ;; 0x400ea003
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    426              disable_irq(53);			        //关接收引脚的IRQ中断
   \   0000000E   0x2035             MOVS     R0,#+53
   \   00000010   0x.... 0x....      BL       disable_irq
    427          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x4004C018         DC32     0x4004c018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x4004C01C         DC32     0x4004c01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x4004B010         DC32     0x4004b010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x4004B00C         DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x4004C00C         DC32     0x4004c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x4004C008         DC32     0x4004c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x4004B044         DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x4004B040         DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x4004D060         DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x4004D064         DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x40048028         DC32     0x40048028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x400EA000         DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x4004D020         DC32     0x4004d020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x4004D024         DC32     0x4004d024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x400EB000         DC32     0x400eb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x400EA004         DC32     0x400ea004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0x400EA007         DC32     0x400ea007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_22:
   \   00000000   0x400EA003         DC32     0x400ea003
    428          
    429          
    430          
    431          
    432          //#ifdef  __cplusplus
    433          //}
    434          //#endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Delay
       8   UART_Init
      56   Uart_GetIntNum
        56   -> Uart_GetString
        56   -> atoi
        56   -> isalpha
        56   -> isupper
        56   -> strlen
      16   Uart_GetString
        16   -> Uart_Getch
       0   Uart_Getch
     272   Uart_Printf
       272   -> Uart_SendString
       272   -> vsprintf
       0   Uart_SendByte
       0   Uart_SendByte_4
       8   Uart_SendString
         8   -> Uart_SendByte
       8   uart_irq_DIS
         8   -> disable_irq
       8   uart_irq_EN
         8   -> enable_irq


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      12  Delay
     324  UART_Init
     256  Uart_GetIntNum
      46  Uart_GetString
      58  Uart_Getch
      28  Uart_Printf
      58  Uart_SendByte
      14  Uart_SendByte_4
      24  Uart_SendString
      22  uart_irq_DIS
      22  uart_irq_EN

 
 956 bytes in section .text
 
 956 bytes of CODE memory

Errors: none
Warnings: none
